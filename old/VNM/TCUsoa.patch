diff -Ndur '--exclude=.git' ./client/util/logger.hpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/client/util/logger.hpp
--- ./client/util/logger.hpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/client/util/logger.hpp	2018-04-12 13:44:00.864000000 -0400
@@ -32,8 +32,8 @@
 /*
  * uncomment to add more logging
  */
-#define USE_WLAN_ENTER_EXIT
-#define USE_WLAN_TRACE
+//#define USE_WLAN_ENTER_EXIT
+//#define USE_WLAN_TRACE
 #define USE_WLAN_DEBUG
 
 /* DEFINES ********************************************************************/
diff -Ndur '--exclude=.git' ./service/main.cpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/main.cpp
--- ./service/main.cpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/main.cpp	2018-04-12 13:44:00.864000000 -0400
@@ -384,6 +384,16 @@
     }
 #endif /* CONFIG_WLANIPC_FEATURE */
 
+    /* start up vnm-ipc */
+    ctx->vnm_ipc = new VnmIpc((void *)ctx);
+    if ((ctx->vnm_ipc)->start()) {
+        DEBUG("Started vnm_ipc\n");
+    } else {
+        ERROR("Failed to start vnm_ipc\n");
+        rc = -1;
+        goto CLEANUP;
+    }
+
     /* successful init!*/
     ctx->running = true;
     ctx->starting = false;
@@ -410,6 +420,14 @@
     /* signal all threads to end */
     ctx->running = false;
 
+    /* clean up vnm-ipc thread */
+    INFO("Cleaning up vnm ipc\n");
+    (ctx->vnm_ipc)->stop();
+    delete(ctx->vnm_ipc);
+    ctx->vnm_ipc = NULL;
+    INFO("vnm_ipc cleaned up\n");
+
+
 #ifdef CONFIG_WLANIPC_THREAD
     /* clean up wlan-ipc thread */
     INFO("Cleaning up wlan ipc\n");
@@ -982,11 +1000,21 @@
     profile->sec.wep.defaultKeyIndex = 0;
     strncpy(profile->sec.wep.key[0], "12345",
             sizeof(profile->sec.wep.key[0]));
-    profile->ipv4AddrType = Ipv4AddrType::DhcpClient;
+    //profile->ipv4AddrType = Ipv4AddrType::DhcpClient;
+    profile->ipv4AddrType = Ipv4AddrType::Static;
+    strncpy(profile->ipv4.staticIpv4.ip, "192.168.1.149",
+            sizeof(profile->ipv4.staticIpv4.ip));
+    strncpy(profile->ipv4.staticIpv4.netmask, "255.255.255.0",
+            sizeof(profile->ipv4.staticIpv4.netmask));
     profile->ipv6AddrType = Ipv6AddrType::None;
 #else
-    strncpy(profile->ssid, "wlanDemo", sizeof(profile->ssid));
-    profile->securityType = Security::Open;
+    strncpy(profile->ssid, "kylekyle", sizeof(profile->ssid));
+    profile->securityType = Security::WpaPersonal;
+    strncpy(profile->sec.wpaPsk.password, "kylekyle", 8);
+    profile->sec.wpaPsk.password[8] = '\0';
+    profile->sec.wpaPsk.pairCipher = PairwiseCipher::Ccmp;
+    profile->sec.wpaPsk.groupCipher = GroupCipher::Ccmp;
+    //profile->ipv4AddrType = Ipv4AddrType::DhcpClient;
     profile->ipv4AddrType = Ipv4AddrType::Static;
     strncpy(profile->ipv4.staticIpv4.ip, "192.168.1.149",
             sizeof(profile->ipv4.staticIpv4.ip));
diff -Ndur '--exclude=.git' ./service/main.hpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/main.hpp
--- ./service/main.hpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/main.hpp	2018-04-12 13:44:00.864000000 -0400
@@ -27,6 +27,7 @@
 #include "drv_ctrl.hpp"
 #include "wlan_data_types.hpp"
 #include "os_abstraction.hpp"
+#include "vnm_ipc.hpp"
 
 #ifdef CONFIG_WSTAS_FEATURE
 #include "wstas.hpp"
@@ -84,6 +85,7 @@
     HostApd         *hostapd;
     WpaSupp         *wpa_supp;
     DrvCtrl         *drv_ctrl;
+    VnmIpc          *vnm_ipc;
 
 #ifdef CONFIG_WSTAS_FEATURE
     Wstas           *wstas;
@@ -112,6 +114,7 @@
 #ifdef CONFIG_TCUIPC_FEATURE
     TcuIpcClient    *tcu_ipc;
 #endif /* CONFIG_TCUIPC_FEATURE */
+
 } WlanContext_t;
 /******************************************************************************/
 } /* wlan_srv */
diff -Ndur '--exclude=.git' ./service/Makefile /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/Makefile
--- ./service/Makefile	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/Makefile	2018-04-12 13:46:58.136000000 -0400
@@ -17,7 +17,7 @@
 ifeq ($(FORD_ECU),tcu)
 # turn on TCU specific features
     CONFIG_WSTAS_FEATURE=y
-    CONFIG_WHSS_FEATURE=y
+    CONFIG_WHSS_FEATURE=n
     CONFIG_WLANIPC_FEATURE=y
     CONFIG_SOAIPC_FEATURE=y
     CONFIG_TCUIPC_FEATURE=y
@@ -44,6 +44,7 @@
 SRCS += hostapd/hostapd.cpp
 SRCS += hostapd/hostapd_cmds.cpp
 SRCS += drv_ctrl/drv_ctrl.cpp
+SRCS += vnm_ipc/vnm_ipc.cpp
 
 INCLUDES += -I$(SRCDIR)/service/
 INCLUDES += -I$(SRCDIR)/service/wlan_srv
@@ -54,9 +55,10 @@
 INCLUDES += -I$(SRCDIR)/service/wpa_supp
 INCLUDES += -I$(SRCDIR)/service/hostapd
 INCLUDES += -I$(SRCDIR)/service/drv_ctrl
+INCLUDES += -I$(SRCDIR)/service/vnm_ipc
 INCLUDES += -I$(SRCDIR)/public
 
-LIBS += -ltelemetry -lwpa_client
+LIBS += -ltelemetry -lwpa_client -lvnmipc
 
 # add feature specific stuff
 ifdef CONFIG_WLANIPC_FEATURE
@@ -84,13 +86,9 @@
 SRCS += tcu_ipc/tcu_ipc_client.cpp
 SRCS += tcu_ipc/tcu_ipc_utils.cpp
 SRCS += tcu_ipc/service_cand.cpp
-SRCS += tcu_ipc/service_spcm.cpp
 SRCS += $(INSTALL_HDIR)/idl/cand/TcuIpcCand.pb.cc
-SRCS += $(INSTALL_HDIR)/idl/spcm/TcuIpcSpcm.pb.cc
-SRCS += $(INSTALL_HDIR)/idl/spcm/tcu_spcm_common.pb.cc
 INCLUDES += -I$(SRCDIR)/service/tcu_ipc/
 INCLUDES += -I$(INSTALL_HDIR)/idl
-INCLUDES += -I${FORD_ECU_ROOT}/fnv/spcm/include
 LIBS += -lprotobuf -ltcuipc-client -lwlanidl
 CFLAGS += -DCONFIG_TCUIPC_FEATURE
 endif
diff -Ndur '--exclude=.git' ./service/makefile.linux /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/makefile.linux
--- ./service/makefile.linux	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/makefile.linux	2018-04-12 13:44:00.864000000 -0400
@@ -1 +1 @@
-LIBS += -lpthread
+LIBS += -lpthread -lrt
diff -Ndur '--exclude=.git' ./service/makefile.qnx /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/makefile.qnx
--- ./service/makefile.qnx	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/makefile.qnx	2018-04-12 13:44:00.864000000 -0400
@@ -1 +1 @@
-LIBS += -lsocket
+LIBS += -lsocket -lmq
diff -Ndur '--exclude=.git' ./service/utils/wlan_action/wlan_action.cpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/utils/wlan_action/wlan_action.cpp
--- ./service/utils/wlan_action/wlan_action.cpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/utils/wlan_action/wlan_action.cpp	2018-04-12 13:44:00.864000000 -0400
@@ -90,6 +90,7 @@
     cleanUpInteger();
     cleanUpScanRes();
     cleanUpProfile();
+    cleanUpIpAddrUpdate();
 
     if (m_data_cb) {
         DEBUG("Removing packed data from wlan_action id= %lu\n", m_id);
@@ -406,6 +407,9 @@
     case (WlanActionType::WlanSrvTypeEcallDone):
         str = "Wlan_Srv Ecall Done";
         break;
+    case (WlanActionType::WlanSrvTypeIpAddrUpdate):
+        str = "Wlan_Srv IP Address Update";
+        break;
     case (WlanActionType::WlanSrvTypeEmcStart):
         str = "Wlan_Srv Emc Start";
         break;
@@ -466,6 +470,9 @@
     case (WlanActionType::WstasTypeIpAddrError):
         str = "WSTAS IP Addr Error";
         break;
+    case (WlanActionType::WstasTypeIpAddrUpdate):
+        str = "WSTAS IP Address Update";
+        break;
     case (WlanActionType::WstasTypeDisconnect):
         str = "WSTAS Disconnect";
         break;
@@ -538,6 +545,9 @@
     case (WlanActionType::WhssTypeIpAddressSetupComplete):
         str = "WHSS IP Address Setup Complete";
         break;
+    case (WlanActionType::WhssTypeIpAddrUpdate):
+        str = "WHSS IP Address Update";
+        break;
     case (WlanActionType::WhssTypeDhcpServerSetupStart):
         str = "WHSS DHCP Server Setup Start";
         break;
@@ -595,12 +605,6 @@
     case (WlanActionType::WhssTypeDataUsageRefreshNoRsp):
         str = "WHSS Data Usage Req - Refresh No Response";
         break;
-    case (WlanActionType::WhssTypeDataUsageFeatureEnabled):
-        str = "WHSS Data Usage Feature Enabled";
-        break;
-    case (WlanActionType::WhssTypeDataUsageFeatureDisabled):
-        str = "WHSS Data Usage Feature Disabled";
-        break;
     case (WlanActionType::WhssTypeMax):
         str = "WHSS Max";
         break;
@@ -631,6 +635,9 @@
     case (WlanActionType::WapsTypeErrorDone):
         str = "WAPS Error Done";
         break;
+    case (WlanActionType::WapsTypeIpAddrUpdate):
+        str = "WAPS IP Address Update";
+        break;
     case (WlanActionType::WapsTypeApBroadcasting):
         str = "WAPS Max";
         break;
@@ -780,6 +787,9 @@
     case (WlanActionSource::SrcWlanIpc):
         str = "Wlan-IPC";
         break;
+    case (WlanActionSource::SrcVnmIpc):
+        str = "Vnm-IPC";
+        break;
     case (WlanActionSource::SrcMax):
         str = "Max";
         break;
@@ -848,6 +858,7 @@
     case (WlanActionType::WlanSrvTypeMasterResetDone):
     case (WlanActionType::WlanSrvTypeEcall):
     case (WlanActionType::WlanSrvTypeEcallDone):
+    case (WlanActionType::WlanSrvTypeIpAddrUpdate):
     case (WlanActionType::WlanSrvTypeEmcStart):
     case (WlanActionType::WlanSrvTypeEmcDone):
     case (WlanActionType::WlanSrvTypeStart):
@@ -861,6 +872,7 @@
     case (WlanActionType::WstasTypeAuthenticated):
     case (WlanActionType::WstasTypeIpAddrCmplt):
     case (WlanActionType::WstasTypeIpAddrError):
+    case (WlanActionType::WstasTypeIpAddrUpdate):
     case (WlanActionType::WstasTypeDisconnecting):
     case (WlanActionType::WstasTypeDisconnected):
     case (WlanActionType::WstasTypeStart):
@@ -881,6 +893,7 @@
     case (WlanActionType::WhssTypeApBroadcasting):
     case (WlanActionType::WhssTypeIpAddressSetupStart):
     case (WlanActionType::WhssTypeIpAddressSetupComplete):
+    case (WlanActionType::WhssTypeIpAddrUpdate):
     case (WlanActionType::WhssTypeDhcpServerSetupStart):
     case (WlanActionType::WhssTypeDhcpServerSetupComplete):
     case (WlanActionType::WhssTypeApnSetupStart):
@@ -900,14 +913,13 @@
     case (WlanActionType::WhssTypeDataUsageCurrent):
     case (WlanActionType::WhssTypeDataUsageRefresh):
     case (WlanActionType::WhssTypeDataUsageRefreshNoRsp):
-    case (WlanActionType::WhssTypeDataUsageFeatureEnabled):
-    case (WlanActionType::WhssTypeDataUsageFeatureDisabled):
     case (WlanActionType::WapsTypeStart):
     case (WlanActionType::WapsTypeStartDone):
     case (WlanActionType::WapsTypeStop):
     case (WlanActionType::WapsTypeStopDone):
     case (WlanActionType::WapsTypeError):
     case (WlanActionType::WapsTypeErrorDone):
+    case (WlanActionType::WapsTypeIpAddrUpdate):
     case (WlanActionType::WapsTypeApBroadcasting):
         subType = WlanActionSubType::SubTypeEvent;
         break;
@@ -1114,6 +1126,41 @@
     EXIT();
     return;
 } /* WlanAction::cleanUpProfile() */
+
+
+void WlanAction::pack(WlanIpAddrUpdate_t &ipAddrUpdate)
+{
+    ENTER();
+
+    m_ipAddrUpdate = ipAddrUpdate;
+
+    EXIT();
+    return;
+} /* WlanAction::unpack(WlanIpAddrUpdate_t &ipAddrUpdate) */
+
+
+void WlanAction::unpack(WlanIpAddrUpdate_t *ipAddrUpdate)
+{
+    ENTER();
+
+    *ipAddrUpdate = m_ipAddrUpdate;
+
+    EXIT();
+    return;
+} /* WlanAction::unpack(WlanIpAddrUpdate_t *ipAddrUpdate) */
+
+
+void WlanAction::cleanUpIpAddrUpdate()
+{
+    ENTER();
+
+    m_ipAddrUpdate.intf.empty();
+    m_ipAddrUpdate.ipv4AddrType = {Ipv4AddrType::None};
+    memset(&m_ipAddrUpdate.ipv4, 0x0, sizeof(m_ipAddrUpdate.ipv4));
+
+    EXIT();
+    return;
+} /* WlanAction::cleanUpIpAddrUpdate() */
 /******************************************************************************/
 
 }; /* wlan */
diff -Ndur '--exclude=.git' ./service/utils/wlan_action/wlan_action.hpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/utils/wlan_action/wlan_action.hpp
--- ./service/utils/wlan_action/wlan_action.hpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/utils/wlan_action/wlan_action.hpp	2018-04-12 13:44:00.864000000 -0400
@@ -56,6 +56,7 @@
     WlanSrvTypeMasterResetDone,
     WlanSrvTypeEcall,
     WlanSrvTypeEcallDone,
+    WlanSrvTypeIpAddrUpdate,
     WlanSrvTypeEmcStart,
     WlanSrvTypeEmcEnable,
     WlanSrvTypeEmcDisable,
@@ -76,6 +77,7 @@
     WstasTypeAuthenticated,  /* !! netwrok auth NOT AP auth */
     WstasTypeIpAddrCmplt,
     WstasTypeIpAddrError,
+    WstasTypeIpAddrUpdate,
     WstasTypeDisconnect,
     WstasTypeDisconnecting,
     WstasTypeDisconnected,
@@ -96,6 +98,7 @@
     WhssTypeApBroadcasting,
     WhssTypeIpAddressSetupStart,
     WhssTypeIpAddressSetupComplete,
+    WhssTypeIpAddrUpdate,
     WhssTypeDhcpServerSetupStart,
     WhssTypeDhcpServerSetupComplete,
     WhssTypeApnSetupStart,
@@ -121,8 +124,6 @@
     WhssTypeDataUsageCurrent,
     WhssTypeDataUsageRefresh,
     WhssTypeDataUsageRefreshNoRsp,
-    WhssTypeDataUsageFeatureEnabled,
-    WhssTypeDataUsageFeatureDisabled,
     WhssTypeMax = 50000,
     /* waps */
     WapsTypeMin = 50001,
@@ -134,8 +135,9 @@
     WapsTypeStopDone,
     WapsTypeError,
     WapsTypeErrorDone,
+    WapsTypeIpAddrUpdate,
     WapsTypeApBroadcasting,
-    WapsTypeMax,
+    WapsTypeMax = 60000,
     /* Bts */
     BtsTypeMin = 60001,
     BtsTypeRequestFw,
@@ -194,9 +196,34 @@
     SrcSysIpc,
     SrcTcuIpc,
     SrcWlanIpc,
+    SrcVnmIpc,
     SrcMax
 };
 
+
+/**
+ *
+ * @brief Structure used to update Role Servers with IP Address changes
+ *
+ * @details Used by Vmn_ipc to update Roles when a IP Address is changed or modified
+ *
+ */
+typedef struct WlanIpAddrUpdate {
+    std::string         intf;       /**< Interface name that was Updated */
+    Ipv4AddrType        ipv4AddrType = {Ipv4AddrType::DhcpClient};           /**< Type of IPv4 Addressing */
+    union ipv4 {
+        ipv4Addr_t      staticIpv4;             /**< static IPv4 Settings */
+        ipv4() {memset(this, 0, sizeof(ipv4));};
+    } ipv4;
+    // UnComment when IPv6 is supported
+    //Ipv6AddrType        ipv6AddrType = {Ipv6AddrType::None};           /**< IPv6 Addressing */
+    //union ipv6 {
+    //    ipv6Addr_t      staticIpv6;             /**< static IPv6 Settings */
+    //    ipv6() {memset(this, 0, sizeof(ipv6));};
+    //} ipv6;
+} WlanIpAddrUpdate_t;
+
+
 // TODO: add doxygen
 typedef std::function<void(void*)> wlanActionCb_t;
 /******************************************************************************/
@@ -230,6 +257,9 @@
         void pack(WlanProfile_t &profile);
         void unpack(WlanProfile_t *profile);
 
+        void pack(WlanIpAddrUpdate_t &ipAddrUpdate);
+        void unpack(WlanIpAddrUpdate_t *ipAddrUpdate);
+
         void setStartCb(wlanActionCb_t);
         void setEndCb(wlanActionCb_t);
 
@@ -296,6 +326,9 @@
 
         WlanProfile_t m_profile;
         void cleanUpProfile();
+
+        WlanIpAddrUpdate_t m_ipAddrUpdate;
+        void cleanUpIpAddrUpdate();
 };
 
 
diff -Ndur '--exclude=.git' ./service/vnm_ipc/vnm_ipc.cpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/vnm_ipc/vnm_ipc.cpp
--- ./service/vnm_ipc/vnm_ipc.cpp	1969-12-31 19:00:00.000000000 -0500
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/vnm_ipc/vnm_ipc.cpp	2018-04-12 13:44:00.864000000 -0400
@@ -0,0 +1,751 @@
+/*
+ * CONFIDENTIAL - FORD MOTOR COMPANY
+ *
+ * This is an unpublished work, which is a trade secret, created in
+ * 2017.  Ford Motor Company owns all rights to this work and intends
+ * to maintain it in confidence to preserve its trade secret status.
+ * Ford Motor Company reserves the right to protect this work as an
+ * unpublished copyrighted work in the event of an inadvertent or
+ * deliberate unauthorized publication.  Ford Motor Company also
+ * reserves its rights under the copyright laws to protect this work
+ * as a published work.  Those having access to this work may not copy
+ * it, use it, or disclose the information contained in it without
+ * the written authorization of Ford Motor Company.
+ */
+
+/* INCLUDES *******************************************************************/
+#include <algorithm>
+#include <sys/socket.h>
+#include <ifaddrs.h>
+#include <arpa/inet.h>
+
+#ifdef WLAN_TCU
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#endif /* WLAN_TCU */
+
+#ifdef WLAN_SYNC4
+#include <net/if.h>
+#include <net/route.h>
+#endif /* WLAN_SYNC4 */
+
+#include "wlan_srv-logger.hpp"
+#include "vnm/vnmipcif.hpp"
+
+#include "main.hpp"
+/******************************************************************************/
+
+/* NAMESPACE ******************************************************************/
+namespace wlan {
+/******************************************************************************/
+
+/* DEFINES ********************************************************************/
+// TODO: fill in log tag
+static const char* TAG = "vnm_ipc";
+
+#define WRITE_TO_FD 1
+#define INTF_MONITOR_FILE_PATH "/proc/net/fib_trie"
+/* ****************************************************************************/
+
+/* GLOBALS ********************************************************************/
+/******************************************************************************/
+
+/* PROTOTYPES *****************************************************************/
+/******************************************************************************/
+
+/* FUNCTIONS/CLASSES **********************************************************/
+VnmIpc::VnmIpc(void *ctx):
+    m_globalCtx(ctx)
+{
+    ENTER();
+
+    m_running = false;
+
+    m_intfs.clear();
+    m_reqsQ.clear();
+
+    m_signalPipeRead = -1;
+    m_signalPipeWrite = -1;
+    m_signalIntfUpdate = -1;
+
+    FD_ZERO(&m_rfds);
+    m_maxFd = 0;
+
+    EXIT();
+} /* VnmIpc::VnmIpc() */
+
+
+VnmIpc::~VnmIpc()
+{
+    ENTER();
+
+    m_thread = NULL;
+    m_running = NULL;
+
+    m_intfs.clear();
+    m_reqsQ.clear();
+
+    m_signalPipeRead = 0;
+    m_signalPipeWrite = 0;
+    m_signalIntfUpdate = 0;
+
+    FD_ZERO(&m_rfds);
+    m_maxFd = 0;
+
+    EXIT();
+} /* VnmIpc::VnmIpc() */
+
+
+bool VnmIpc::start()
+{
+    int pipeFd[2] = {-1, -1};
+    bool rc = false;
+    int ret = 0;
+#ifdef WLAN_TCU
+    struct sockaddr_nl addr = {0};
+#endif /* WLAN_TCU */
+
+    ENTER();
+
+    /* open our pipe */
+    ret = pipe(pipeFd);
+    if (ret) {
+        ERROR("Failed to allocate pipe - %s\n", strerror(errno));
+
+        if (m_signalPipeRead >= 0) {
+            close(m_signalPipeRead);
+        }
+        if (m_signalPipeWrite >= 0) {
+            close(m_signalPipeWrite);
+        }
+
+        rc = false;
+        goto LEAVE;
+    } else {
+        DEBUG("Successfully created a pipe - fd = %d/%d\n", pipeFd[0], pipeFd[1]);
+    }
+
+    /* save the fd's for the pipe */
+    m_signalPipeRead = pipeFd[0];
+    m_signalPipeWrite = pipeFd[1];
+
+#ifdef WLAN_TCU
+    m_signalIntfUpdate = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+#endif /* WLAN_TCU */
+
+#ifdef WLAN_SYNC4
+    m_signalIntfUpdate = socket(PF_ROUTE, SOCK_RAW, 0);
+#endif /* WLAN_SYNC4 */
+    if (m_signalIntfUpdate < 0) {
+        ERROR("Failed to open network socket\n");
+        if (m_signalIntfUpdate >= 0) {
+            close(m_signalIntfUpdate);
+        }
+        rc = false;
+        goto LEAVE;
+    } else {
+        DEBUG("Successfully opened socket, fd - %d\n", m_signalIntfUpdate);
+    }
+
+#ifdef WLAN_TCU
+    addr.nl_family = AF_NETLINK;
+    addr.nl_groups = RTMGRP_IPV4_IFADDR;
+
+    ret = bind(m_signalIntfUpdate, (struct sockaddr *)&addr, sizeof(addr));
+    if (ret < 0) {
+        ERROR("Failed to bind IntfUpdate pipe - %s\n", strerror(errno));
+        rc = false;
+        goto LEAVE;
+    } else {
+        DEBUG("Successfully Bind'ed the IntfUpdate pipe\n");
+    }
+#endif /* WLAN_TCU */
+
+    m_vnmIpcRetCode = m_vnmIpcInstance.initialize(m_vnmIpcId);
+    if (m_vnmIpcRetCode != fnv::vnm::VNMIPC_SUCCESS) {
+        ERROR("Failed to start vnm_ipc\n");
+        rc = false;
+        goto LEAVE;
+    }
+
+    /* start the mainLoop in it's own thread */
+    m_running = true;
+    m_thread = new std::thread(&VnmIpc::waitForData, this);
+
+    INFO("Successfully started vnm_ipc\n");
+    rc = true;
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::start() */
+
+
+bool VnmIpc::stop()
+{
+    bool rc = false;
+
+    ENTER();
+
+    m_running = false;
+    INFO("waiting for vnm thread to end...\n");
+    m_thread->join();
+    INFO("vnm thread done\n");
+
+    if (m_signalPipeRead >= 0) {
+        close(m_signalPipeRead);
+    }
+
+    if (m_signalPipeWrite >= 0) {
+        close(m_signalPipeWrite);
+    }
+
+    if (m_signalIntfUpdate >= 0) {
+        close(m_signalIntfUpdate);
+    }
+
+    for (auto iter = m_intfs.begin();
+              iter != m_intfs.end();
+              iter++) {
+
+        m_vnmIpcRetCode = m_vnmIpcInstance.setDhcpIdleMode(iter->intf);
+        if (m_vnmIpcRetCode != fnv::vnm::VNMIPC_SUCCESS) {
+            ERROR("Failed to set DHCP Idle Mode for vnm_ipc\n");
+            rc = false;
+        }
+    } /* for() */
+
+    if (rc == false) {
+        ERROR("vnm_ipc may not have been completely stopped / disconnected\n");
+        goto LEAVE;
+    }
+
+    INFO("Successfully stopped vnm_ipc\n");
+    rc = true;
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::stop() */
+
+
+void VnmIpc::waitForData()
+{
+    struct timeval tv = {0};
+    int ret = 0;
+
+    ENTER();
+
+    while (m_running)
+    {
+        TRACE("waiting for new connections...\n");
+
+        setupRfds();
+
+        /* use a time out of 1 sec so shutdown is timely */
+        tv.tv_sec = 1;
+        tv.tv_usec = 0;
+
+        ret = select(m_maxFd + 1, &m_rfds, NULL, NULL, &tv);
+        switch (ret) {
+        case (-1):
+            WARN("select returned error - %s\n", strerror(errno));
+            break;
+        case (0):
+            TRACE("Time out from select()\n");
+            break;
+        default:
+            DEBUG("select returned with data to read\n");
+            handleFdsReady();
+            break;
+        } /* switch (ret) */
+    } /* while (m_running) */
+
+    EXIT();
+    return;
+} /* VnmIpc::waitForData() */
+
+
+void VnmIpc::setupRfds(void)
+{
+    ENTER();
+
+    FD_ZERO(&m_rfds);
+    FD_SET(m_signalPipeRead, &m_rfds);
+
+    TRACE("Added fd = %d to rfds\n", m_signalPipeRead);
+    FD_SET(m_signalIntfUpdate, &m_rfds);
+    TRACE("Added fd = %d to rfds\n", m_signalIntfUpdate);
+
+    m_maxFd = std::fmax(m_signalPipeRead, m_signalIntfUpdate);
+
+    TRACE("Max_FD set to - %d\n", m_maxFd);
+
+    EXIT();
+} /* VnmIpc::setupRfds() */
+
+
+void VnmIpc::handleFdsReady(void)
+{
+    int rc = 0;
+    uint32_t buf = 0;
+    bool ret = false;
+
+    ENTER();
+
+    /* first check if our pipe has anything */
+    if (FD_ISSET(m_signalPipeRead, &m_rfds)) {
+        DEBUG("Data is ready on the VNM_ipc readPipe\n");
+        ret = handleVnmIpcRequest();
+        if (ret == false) {
+            WARN("selectVnmCall() failed\n");
+        } else {
+            DEBUG("selectVnmCall() succeced\n");
+        }
+
+        rc = read(m_signalPipeRead, (void *)(&buf), sizeof(buf));
+        if (rc < 0) {
+            ERROR("Failed to read from wake-up pipe - %s\n", strerror(errno));
+        } else {
+            DEBUG("Successfully cleared the wake-up pipe - %d\n", buf);
+        }
+    } else if (FD_ISSET(m_signalIntfUpdate, &m_rfds)) {
+        DEBUG("Detected a networking change or update, check if it was for a monitored Interface\n");
+        /* The m_signalIntfUpdate pipe is read/cleared within checkIntfIpAddress, no need to manually clear the pipe */
+        ret = checkIntfIpAddress();
+        if (ret == false) {
+            DEBUG("checkIntfAddress() failed\n");
+        } else {
+            DEBUG("checkIntfAddress() succeced\n");
+        }
+    } else {
+        WARN("Select() returned but none of the monitored Fd had data for us....\n");
+    }
+
+    EXIT();
+    return;
+} /* VnmIpc::handleFds() */
+
+
+bool VnmIpc::signalVnmIpc(void)
+{
+    bool rc = false;
+    int ret = 0;
+    uint8_t buf = WRITE_TO_FD;
+
+    ENTER();
+
+    ret = write(m_signalPipeWrite, &buf, sizeof(WRITE_TO_FD));
+    if (ret < 0) {
+        ERROR("Failed to write to wake-up pipe\n");
+        rc = false;
+    } else {
+        INFO("Successfully wrote to wake up vnm_ipc main thread\n");
+        rc = true;
+    }
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::signalVnmIpc() */
+
+
+bool VnmIpc::clearIpv4(const char *intf_request)
+{
+    bool rc = false;
+    VnmIpcReq_t vnmRequest;
+    std::string intf;
+
+    ENTER();
+
+    if (intf_request) {
+        intf = intf_request;
+    }
+
+    INFO("Received clear IPv4 request, queuing request\n");
+
+    vnmRequest.intf = intf;
+    vnmRequest.type = VnmIpcReqType::ClearIpv4;
+    vnmRequest.ipv4Type = Ipv4AddrType::None;
+    vnmRequest.ipv6Type = Ipv6AddrType::None;
+
+    { /* m_qMutex */
+        /* lock the mutex for adding to the memeber queue variable */
+        std::unique_lock<std::mutex> lock(m_qMutex);
+
+        m_reqsQ.push_back(vnmRequest);
+    } /* m_qMutex */
+
+    rc = signalVnmIpc();
+    //error checking
+
+    rc = true;
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::clearIpv4() */
+
+
+bool VnmIpc::requestStaticIpv4(const char *intf_request, ipv4Addr_t &addr)
+{
+    bool rc = false;
+    VnmIpcReq_t vnmRequest;
+    std::string intf;
+
+    ENTER();
+
+    if (intf_request) {
+        intf = intf_request;
+    }
+
+    INFO("Received Static IPv4 request, queuing request\n");
+
+    vnmRequest.intf = intf;
+    vnmRequest.type = VnmIpcReqType::RequestStaticIpv4;
+    vnmRequest.ipv4Type = Ipv4AddrType::Static;
+    vnmRequest.ipv4.staticAddr = addr;
+    vnmRequest.ipv6Type = Ipv6AddrType::None;
+
+    { /* m_qMutex */
+        /* lock the mutex for adding to the memeber queue variable */
+        std::unique_lock<std::mutex> lock(m_qMutex);
+
+        m_reqsQ.push_back(vnmRequest);
+    } /* m_qMutex */
+
+    rc = signalVnmIpc();
+    //error checking
+
+    rc = true;
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::requestStaticIpv4() */
+
+
+bool VnmIpc::requestDhcpClient(const char *intf_request)
+{
+    bool rc = false;
+    VnmIpcReq_t vnmRequest;
+    std::string intf;
+
+    ENTER();
+
+    if (intf_request) {
+        intf = intf_request;
+    }
+
+    INFO("Received DHCP Client request, queuing request\n");
+
+    vnmRequest.intf = intf;
+    vnmRequest.type = VnmIpcReqType::RequestDhcpClient;
+    vnmRequest.ipv4Type = Ipv4AddrType::None;
+    vnmRequest.ipv6Type = Ipv6AddrType::None;
+
+    { /* m_qMutex */
+        /* lock the mutex for adding to the memeber queue variable */
+        std::unique_lock<std::mutex> lock(m_qMutex);
+
+        m_reqsQ.push_back(vnmRequest);
+    } /* m_qMutex */
+
+    rc = signalVnmIpc();
+    //TODO: error checking
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::requestDhcpClient() */
+
+
+bool VnmIpc::requestDhcpServer(const char *intf_request /* server config */)
+{
+    bool rc = false;
+    VnmIpcReq_t vnmRequest;
+    std::string intf;
+
+    ENTER();
+
+    if (intf_request) {
+        intf = intf_request;
+    }
+
+    INFO("Received DHCP Server request, queuing request\n");
+
+    vnmRequest.intf = intf;
+    vnmRequest.type = VnmIpcReqType::RequestDhcpServer;
+    //TODO: update request with Server Config info
+    //      Tracked with TCU-4866
+    vnmRequest.ipv4Type = Ipv4AddrType::None;
+    vnmRequest.ipv6Type = Ipv6AddrType::None;
+
+    { /* m_qMutex */
+        /* lock the mutex for adding to the memeber queue variable */
+        std::unique_lock<std::mutex> lock(m_qMutex);
+
+        m_reqsQ.push_back(vnmRequest);
+    } /* m_qMutex */
+
+    rc = signalVnmIpc();
+    //TODO: error checking
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::requestDhcpServer() */
+
+bool VnmIpc::checkIntfList(std::string intf)
+{
+    bool rc = false;
+    VnmIpcIntf_t intfToAdd;
+
+    ENTER();
+
+    intfToAdd.intf = intf;
+
+    if (m_intfs.empty()){
+        DEBUG("Interface List was empty, adding interface - %s\n",intf.c_str());
+        m_intfs.push_back(intfToAdd);
+    } else {
+        for (auto iter = m_intfs.begin();
+                  iter != m_intfs.end();
+                  iter++) {
+            if (strncmp(iter->intf.c_str(),intf.c_str(),intf.length()) == 0) {
+                DEBUG("Interface was already present in list\n");
+                break;
+            } /* if */
+        } /* for() */
+        DEBUG("Interface was not in our list, adding\n");
+        m_intfs.push_back(intfToAdd);
+    }
+
+    rc = true;
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::findIntfFd() */
+
+
+bool VnmIpc::handleVnmIpcRequest()
+{
+    bool rc = false;
+    VnmIpcReq_t vnmRequest;
+
+    ENTER();
+    DEBUG("Check the vnmRequest Type and select the correct handler function\n");
+
+    { /* m_qMutex */
+        /* lock the mutex for checking the Top request Type */
+        std::unique_lock<std::mutex> lock(m_qMutex);
+
+        if(m_reqsQ.empty()) {
+            ERROR("nothing in the vnmRequest queue\n");
+            rc = false;
+            goto LEAVE;
+        } else {
+            vnmRequest = m_reqsQ.front();
+            m_reqsQ.pop_front();
+        }
+    } /* m_qMutex */
+
+    switch (vnmRequest.type) {
+    case (VnmIpcReqType::ClearIpv4):
+        rc = handleClearIpv4(vnmRequest);
+        break;
+    case (VnmIpcReqType::RequestStaticIpv4):
+        rc = handleRequestStaticIpv4(vnmRequest);
+        break;
+    case (VnmIpcReqType::RequestDhcpClient):
+        rc = handleRequestDhcpClient(vnmRequest);
+        break;
+    case (VnmIpcReqType::RequestDhcpServer):
+        rc = handleRequestDhcpServer(vnmRequest);
+        break;
+    default:
+        ERROR("unknown Vnm_ipc request Type\n");
+        rc = false;
+        break;
+    }
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::handleVnmIpcRequest() */
+
+
+bool VnmIpc::handleClearIpv4(VnmIpcReq_t vnmRequest)
+{
+    bool rc = false;
+
+    ENTER();
+
+    INFO("handling vnm_ipc clearIpv4() request\n");
+    checkIntfList(vnmRequest.intf);
+
+    m_vnmIpcRetCode = m_vnmIpcInstance.clearIpAddress(vnmRequest.intf);
+    if (m_vnmIpcRetCode != fnv::vnm::VNMIPC_SUCCESS) {
+        ERROR("Failed to clear Ip Address using vnm_ipc\n");
+        rc = false;
+        goto LEAVE;
+    }
+    rc = true;
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::handleClearIpv4() */
+
+
+bool VnmIpc::handleRequestDhcpClient(VnmIpcReq_t vnmRequest)
+{
+    bool rc = false;
+
+    ENTER();
+
+    INFO("handling vnm_ipc requestDhcpClient() request\n");
+
+    checkIntfList(vnmRequest.intf);
+    m_vnmIpcRetCode = m_vnmIpcInstance.setDhcpClientMode(vnmRequest.intf);
+    if (m_vnmIpcRetCode != fnv::vnm::VNMIPC_SUCCESS) {
+        ERROR("Failed to enable dhcp client using vnm_ipc\n");
+        rc = false;
+        goto LEAVE;
+    }
+
+    rc = true;
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::handleRequestDhcpClient() */
+
+
+bool VnmIpc::handleRequestStaticIpv4(VnmIpcReq_t vnmRequest)
+{
+    bool rc = false;
+
+    ENTER();
+
+    INFO("handling vnm_ipc requestStaticIpv4() request\n");
+
+    checkIntfList(vnmRequest.intf);
+    m_vnmIpcRetCode = m_vnmIpcInstance.setStaticIpAddress(vnmRequest.intf,
+                                                          vnmRequest.ipv4.staticAddr.ip);
+    if (m_vnmIpcRetCode != fnv::vnm::VNMIPC_SUCCESS) {
+        ERROR("Failed to set %s with Static Ip %s using vnm_ipc\n",
+              vnmRequest.intf.c_str(), vnmRequest.ipv4.staticAddr.ip);
+        rc = false;
+        goto LEAVE;
+    }
+
+    rc = true;
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::handleRequestStaticIpv4() */
+
+
+bool VnmIpc::handleRequestDhcpServer(VnmIpcReq_t vnmRequest)
+{
+    bool rc = false;
+
+    ENTER();
+
+    checkIntfList(vnmRequest.intf);
+    WARN("DHCP Server requests currenly not supported\n");
+    //TODO: update request with Server Config info
+    //      Tracked with TCU-4866
+    //
+    //INFO("calling into vnm_ipc RequestDhcpServer()\n");
+
+    rc = true;
+
+    EXIT();
+    return(rc);
+} /* VnmIpc::handleRequestDhcpServer() */
+
+
+bool VnmIpc::checkIntfIpAddress()
+{
+    bool rc = false;
+    WlanContext_t *ctx = NULL;
+    WlanIpAddrUpdate_t *ipAddrUpdate = NULL;
+    char buf[4096];
+    int ret = 0;
+    struct ifaddrs *ifaddr = NULL;
+    struct ifaddrs *ifa = NULL;
+    char *ipAddrString;
+    //std::string ipAddrString;
+    struct sockaddr_in *sockAddr;
+
+    ENTER();
+
+    ctx = (WlanContext_t *)m_globalCtx;
+    //nlh = (struct nlmsghdr *)buf;
+    ipAddrUpdate = new WlanIpAddrUpdate_t();
+
+    ret = recv(m_signalIntfUpdate, buf, 4096, 0);
+    if (ret < 0) {
+        ERROR("Failed to read from recv for m_signalIntfUpdate\n");
+        rc = false;
+        goto LEAVE;
+    } else {
+        DEBUG("Successfully cleared recv for m_signalIntfUpdate\n");
+    }
+
+    ret = getifaddrs(&ifaddr);
+    if (ret == -1) {
+        ERROR("failed to get interfaces info - %s\n", strerror(errno));
+        goto LEAVE;
+    }
+
+    /* check that the Interface changed is one we are monitoring and update accordingly if yes */
+    for (auto iter = m_intfs.begin(); iter != m_intfs.end(); iter++) {
+        DEBUG("Looking for intf = %s\n", iter->intf.c_str());
+        /* iterate through the list of interfaces for the interface with our name */
+        for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+            if (ifa->ifa_addr->sa_family==AF_INET) {
+                if (strncmp(iter->intf.c_str(), ifa->ifa_name, IFNAMSIZ) == 0) {
+                    DEBUG("found an interface (%s) we are monitoring, checking Address updates\n", iter->intf.c_str());
+                    sockAddr = (struct sockaddr_in *) ifa->ifa_addr;
+                    ipAddrString = inet_ntoa(sockAddr->sin_addr);
+                            DEBUG("%s was assigned ip address of %s\n", iter->intf.c_str(), ipAddrString);
+                    if (iter->hasIpAddr == false || iter->ipAddr != ipAddrString) {
+                        DEBUG("%s been assigned an IP address or the current address has been updated\n",
+                                iter->intf.c_str());
+                        /* check that ip address recv from the socket is a valid one */
+                        if (inet_pton(AF_INET, ipAddrString, &(sockAddr->sin_addr)) > 0) {
+                            DEBUG("%s was assigned ip address of %s\n", iter->intf.c_str(), ipAddrString);
+                            iter->hasIpAddr = true;
+                            iter->ipAddr = ipAddrString;
+
+                            DEBUG("Create wlan_action so that wlan_srv can update all roles\n");
+                            ipAddrUpdate->intf = iter->intf;
+                            strncpy(ipAddrUpdate->ipv4.staticIpv4.ip, ipAddrString, WLAN_IP_LEN);
+
+                            WlanAction *new_action = new WlanAction {
+                                    WlanActionType::WlanSrvTypeIpAddrUpdate,
+                                    WlanActionSource::SrcVnmIpc};
+                            new_action->pack(*ipAddrUpdate);
+                            (ctx->wlan_srv)->queueAction(new_action);
+                        }
+                    } else {
+                        DEBUG("%s already has valid ip address of %s\n", iter->intf.c_str(), iter->ipAddr.c_str());
+                    } /* if (iter->hasIpAddr...) */
+                    break; //change to goto??
+                } else {
+                    DEBUG("None of our Interfaces had updates\n");
+                }/* if (strncmp(iter->....)) */
+            } /* if (ifa->ifa_addr....) */
+        } /* for (ifa...) */
+    } /* for (auto iter...) */
+
+    rc = true;
+
+LEAVE:
+    EXIT();
+    return(rc);
+} /* VnmIpc::checkIntfIpAddress() */
+/******************************************************************************/
+} /* wlan*/
+/******************************************************************************/
+/* EOF */
+
diff -Ndur '--exclude=.git' ./service/vnm_ipc/vnm_ipc.hpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/vnm_ipc/vnm_ipc.hpp
--- ./service/vnm_ipc/vnm_ipc.hpp	1969-12-31 19:00:00.000000000 -0500
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/vnm_ipc/vnm_ipc.hpp	2018-04-12 13:44:00.864000000 -0400
@@ -0,0 +1,171 @@
+/*
+ * CONFIDENTIAL - FORD MOTOR COMPANY
+ *
+ * This is an unpublished work, which is a trade secret, created in
+ * 2017.  Ford Motor Company owns all rights to this work and intends
+ * to maintain it in confidence to preserve its trade secret status.
+ * Ford Motor Company reserves the right to protect this work as an
+ * unpublished copyrighted work in the event of an inadvertent or
+ * deliberate unauthorized publication.  Ford Motor Company also
+ * reserves its rights under the copyright laws to protect this work
+ * as a published work.  Those having access to this work may not copy
+ * it, use it, or disclose the information contained in it without
+ * the written authorization of Ford Motor Company.
+ */
+
+#ifndef WLAN_SRV_VNM_IPC_HPP
+#define WLAN_SRV_VNM_IPC_HPP
+
+/* INCLUDES *******************************************************************/
+#include "wlan_data_types.hpp"
+#include "vnm/vnmipcif.hpp"
+/******************************************************************************/
+
+/* NAMESPACE ******************************************************************/
+namespace wlan {
+/******************************************************************************/
+
+/* DEFINES ********************************************************************/
+typedef struct VnmIpcIntf {
+    std::string     intf;
+    bool hasIpAddr = false;
+    std::string   ipAddr;
+} VnmIpcIntf_t;
+
+
+enum class VnmIpcReqType
+{
+    Min = 0,
+    Add,
+    ClearIpv4,
+    RequestStaticIpv4,
+    RequestDhcpServer,
+    RequestDhcpClient,
+    Max
+};
+
+
+typedef struct VnmIpcReq {
+    std::string     intf;
+    VnmIpcReqType   type = {VnmIpcReqType::Add};
+    Ipv4AddrType    ipv4Type = {Ipv4AddrType::None};
+   union ipv4 {
+        ipv4Addr_t  staticAddr;
+        ipv4() {memset(this, 0, sizeof(ipv4));};
+    } ipv4;
+    Ipv6AddrType    ipv6Type = {Ipv6AddrType::None};
+    union ipv6 {
+        ipv6Addr_t  staticAddr;
+        ipv6() {memset(this, 0, sizeof(ipv6));};
+    } ipv6;
+} VnmIpcReq_t;
+/* ****************************************************************************/
+
+/* GLOBALS ********************************************************************/
+/******************************************************************************/
+
+/* PROTOTYPES *****************************************************************/
+class VnmIpc
+{
+    public:
+        VnmIpc(void *ctx);
+        virtual ~VnmIpc();
+
+        bool start();
+        bool stop();
+
+        /* IPv4 stuff */
+        bool clearIpv4(const char *intf_request);
+        bool requestStaticIpv4(const char *intf_request, ipv4Addr_t &addr);
+        bool requestDhcpClient(const char *intf_request);
+        bool requestDhcpServer(const char *intf_request /*, server config */);
+
+        /* IPv6 stuff */
+
+    private:
+        VnmIpc(const VnmIpc &) = delete;
+        VnmIpc & operator=(const VnmIpc &) = delete;
+
+        void *m_globalCtx;
+
+        bool m_running;
+        std::thread *m_thread;
+
+        std::string m_vnmIpcId = "wlanSrv";
+
+        fnv::vnm::VnmIpc m_vnmIpcInstance;
+        fnv::vnm::VnmIpcRet_t m_vnmIpcRetCode;
+
+        /*
+         * the list of interfaces that have requests on them and that we should
+         * be monitoring for IP addressing changes
+         */
+        std::list<VnmIpcIntf_t> m_intfs;
+
+        /*
+         * a queue for incoming requests
+         */
+        std::deque<VnmIpcReq_t> m_reqsQ;
+
+        /* mutex for queue */
+        std::mutex m_qMutex;
+
+        /* pipe for signalling when we put something in the queue */
+        int m_signalPipeRead;
+        int m_signalPipeWrite;
+        int m_signalIntfUpdate;
+
+        /* stuff for select loop */
+        fd_set m_rfds;
+        int m_maxFd;
+
+        /*
+         * main processing loop for thread
+         */
+        void waitForData(void);
+
+        /*
+         * helper function to setup m_rfds and m_highestFd
+         */
+        void setupRfds();
+
+        /*
+         * determines which fd has something for us to do
+         */
+        void handleFdsReady(void);
+
+        /*
+         * helper function that abstracts signalling the vnm_ipc thread via
+         * the pipe.
+         */
+        bool signalVnmIpc(void);
+
+        /*
+         * helper function that check whether an interface is already being monitored
+         * and adds it to the list if not, keep track of the fd associated with that 
+         * interface.
+         */
+        bool checkIntfList(std::string intf);
+
+        /*
+         * function that checks the type of VNM request we have received and call the
+         * approtiate handleVNM() function
+         */
+        bool handleVnmIpcRequest(void);
+
+        bool handleClearIpv4(VnmIpcReq_t vnmRequest);
+        bool handleRequestStaticIpv4(VnmIpcReq_t vnmRequest);
+        bool handleRequestDhcpClient(VnmIpcReq_t vnmRequest);
+        bool handleRequestDhcpServer(VnmIpcReq_t vnmRequest);
+
+        int getIntfUpdateFd(void);
+        bool checkIntfIpAddress(void);
+
+
+};
+/******************************************************************************/
+} /* wlan */
+#endif /* WLAN_SRV_VNM_IPC_HPP */
+/******************************************************************************/
+/* EOF */
+
diff -Ndur '--exclude=.git' ./service/wlan_srv/wlan_srv.cpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wlan_srv/wlan_srv.cpp
--- ./service/wlan_srv/wlan_srv.cpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wlan_srv/wlan_srv.cpp	2018-04-12 13:44:00.864000000 -0400
@@ -658,18 +658,25 @@
 
     switch (action->getGroup()) {
     case (WlanActionGroup::GroupWlanSrv):
-        action->startOfProcessing();
-        if (StateMachine::handleEvent(action->getType())) {
-            INFO("Successfully handled id = %s (%s)\n",
-                    action->getIdStr().c_str(), action->getTypeStr());
-            rc = 0;
-        } else {
-            ERROR("Failed to handle id = %s (%s)\n",
-                    action->getIdStr().c_str(), action->getTypeStr());
-            // TODO: properly handle this error
-            rc = -1;
+        switch (action->getType()) {
+        case (WlanActionType::WlanSrvTypeIpAddrUpdate):
+            rc = handleIpAddrUpdate(action);
+            break;
+        default:
+            action->startOfProcessing();
+            if (StateMachine::handleEvent(action->getType())) {
+                INFO("Successfully handled id = %s (%s)\n",
+                        action->getIdStr().c_str(), action->getTypeStr());
+                rc = 0;
+            } else {
+                ERROR("Failed to handle id = %s (%s)\n",
+                        action->getIdStr().c_str(), action->getTypeStr());
+                // TODO: properly handle this error
+                rc = -1;
+            }
+            action->endOfProcessing();
+            break;
         }
-        action->endOfProcessing();
         break;
 #ifdef CONFIG_WSTAS_FEATURE
     case (WlanActionGroup::GroupWstas):
@@ -1059,6 +1066,46 @@
 
 
 // TODO: add doxygen
+int WlanSrv::handleIpAddrUpdate(WlanAction *action)
+{
+    WlanContext_t *ctx = NULL;
+    WlanAction *new_action[3] = {NULL};
+    WlanIpAddrUpdate_t *ipAddrUpdate = NULL;
+    int i = 0;
+    int rc = 0;
+
+    ENTER();
+
+    action->startOfProcessing();
+    ctx = (WlanContext *)m_globalCtx;
+
+    ipAddrUpdate = new WlanIpAddrUpdate_t();
+
+    INFO("Recieved wlanAction %s. Sending IpAddrUpdate to all roles\n",
+            action->getTypeStr());
+
+    action->unpack(ipAddrUpdate);
+
+    /* Create 3 IpAddrUpdates for each role, Wstas, Whss, Waps */
+    new_action[0] = new WlanAction {WlanActionType::WstasTypeIpAddrUpdate,
+                                          WlanActionSource::SrcInternal};
+    new_action[1] = new WlanAction {WlanActionType::WhssTypeIpAddrUpdate,
+                                          WlanActionSource::SrcInternal};
+    new_action[2] = new WlanAction {WlanActionType::WapsTypeIpAddrUpdate,
+                                          WlanActionSource::SrcInternal};
+
+    for (i = 0; i < 3; i++) {
+        new_action[i]->pack(*ipAddrUpdate);
+        (ctx->wlan_srv)->queueAction(new_action[i]);
+    }
+    action->endOfProcessing();
+
+    EXIT();
+    return(rc);
+} /* WlanSrv::handleIpAddrUpdate(WlanAction *action) */
+
+
+// TODO: add doxygen
 const char* WlanSrv::currentState()
 {
     const char *str = NULL;
diff -Ndur '--exclude=.git' ./service/wlan_srv/wlan_srv.hpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wlan_srv/wlan_srv.hpp
--- ./service/wlan_srv/wlan_srv.hpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wlan_srv/wlan_srv.hpp	2018-04-12 13:44:00.864000000 -0400
@@ -79,6 +79,8 @@
 
         int processWlanAction(WlanAction *action);
 
+        int handleIpAddrUpdate(WlanAction *action);
+
         int priorityQueueAction(WlanAction *action);
 
         int queueApiAction(WlanAction *action, bool priority);
diff -Ndur '--exclude=.git' ./service/wpa_supp/wpa_supp.cpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wpa_supp/wpa_supp.cpp
--- ./service/wpa_supp/wpa_supp.cpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wpa_supp/wpa_supp.cpp	2018-04-12 13:44:00.864000000 -0400
@@ -1043,8 +1043,9 @@
                                          WlanActionSource::SrcInternal};
 
     /* queue the action with wlan_srv */
-    (ctx->wlan_srv)->queueAction(action);
-
+    if (ctx->wlan_srv) {
+        (ctx->wlan_srv)->queueAction(action);
+    }
     EXIT();
     return(rc);
 } /* WpaSupp::stopWpaSupplicant() */
diff -Ndur '--exclude=.git' ./service/wstas/wstas.cpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wstas/wstas.cpp
--- ./service/wstas/wstas.cpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wstas/wstas.cpp	2018-04-12 13:44:00.864000000 -0400
@@ -551,6 +551,9 @@
     case (WlanActionType::WstasTypeScanResults):
         handleEventScanResults(action);
         break;
+    case (WlanActionType::WstasTypeIpAddrUpdate):
+        handleEventIpAddrUpdate(action);
+        break;
     case (WlanActionType::WstasTypeDisconnected):
         if (StateMachine::state() != StaSmState::Disconnecting) {
             INFO("Received Event Disconnected, need to move to State Disconnecting before processing\n");
@@ -1348,7 +1351,6 @@
 {
     WlanContext_t *ctx = NULL;
     WlanProfile_t* profile = NULL;
-    WlanAction* new_action = NULL;
     int rc = 0;
 
     ENTER();
@@ -1406,17 +1408,6 @@
 
     action->endOfProcessing();
 
-    /*
-     * TODO: remove this when VNM network API is available.
-     * Eventually this action will be received on another
-     * IPC mechanism originating from VNM - for now create
-     * and queue it internally.
-     */
-    new_action = new WlanAction {WlanActionType::WstasTypeIpAddrCmplt,
-                                 WlanActionSource::SrcInternal};
-
-    (ctx->wlan_srv)->queueAction(new_action);
-
     /* Clean-up */
     if (profile) {
         delete(profile);
@@ -1495,45 +1486,62 @@
 } /* Wstas::handleEventScanResults */
 
 
-// TODO: add Doxygen
-int Wstas::setIpv4AddressStatic(ipv4Addr_t ip)
+// TODO: add doxygen
+void Wstas::handleEventIpAddrUpdate(WlanAction *action)
 {
-#ifndef OFF_TARGET_BUILD
-    const char ifconfigCmd[MAX_LEN_START_CMD] = {'\0'};
-    WlanContext_t* ctx = NULL;
+    WlanContext_t *ctx = NULL;
+    WlanIpAddrUpdate_t *ipAddrUpdate = NULL;
     std::string ifname;
-    int rc = 0;
+    ipAddrUpdate = new WlanIpAddrUpdate_t();
+
     ENTER();
 
-    ctx = (WlanContext_t*)m_globalCtx;
+    action->startOfProcessing();
+
+    INFO("Received an Ip Address Update Event, check if it's for our interface \n");
+
+    ctx = (WlanContext *)m_globalCtx;
     (ctx->wpa_supp)->interface(ifname);
-    // TODO: handle this error
 
-    /*
-     * TODO: call API to set interface with static IP...sendMsg(???)
-     * Temporary solution is to do it ourselves until VNM API is
-     * available
-     */
-    INFO("Setting static IP address on interface = %s\n", ifname.c_str());
-    rc = snprintf((char*)ifconfigCmd, MAX_LEN_START_CMD,
-            "ifconfig %s %s netmask %s",
-            ifname.c_str(),
-            ip.ip,
-            ip.netmask);
+    action->unpack(ipAddrUpdate);
 
-    rc = os_system(ifconfigCmd);
-    if (rc) {
-        ERROR("Failed to set IP address with \"%s\" - %d\n", ifconfigCmd, rc);
-        rc = -1;
+    if(ipAddrUpdate->intf == ifname) {
+        DEBUG("Event was for our interface's (%s), send an IpAddrCmplt Action\n",
+                ipAddrUpdate->intf.c_str());
+
+        WlanAction *new_action = new WlanAction {
+                WlanActionType::WstasTypeIpAddrCmplt,
+                WlanActionSource::SrcInternal,
+        };
+
+        queueAction(new_action);
     } else {
-        INFO("Successfully set static IP address - \"%s\"\n", ifconfigCmd);
+        DEBUG("The Ip Address Update was not for our interface, ignoring\n");
     }
-#else
+
+    action->endOfProcessing();
+
+    EXIT();
+    return;
+} /* Wstas::handleEventIpAddrUpdate */
+
+
+// TODO: add Doxygen
+int Wstas::setIpv4AddressStatic(ipv4Addr_t ip)
+{
+    WlanContext_t* ctx = NULL;
+    std::string ifname;
     int rc = 0;
+
     ENTER();
 
-    WARN("Skipping static IP addressing for off-target mode\n");
-#endif /* OFF_TARGET_BUILD */
+    ctx = (WlanContext_t*)m_globalCtx;
+
+    INFO("Called into VMN_IPC STATIC\n");
+    (ctx->wpa_supp)->interface(ifname);
+    // TODO: handle this error
+
+    ctx->vnm_ipc->requestStaticIpv4(ifname.c_str(), ip);
 
     EXIT();
     return rc;
@@ -1543,40 +1551,18 @@
 // TODO: add Doxygen
 int Wstas::setIpv4AddressDynamic()
 {
-#ifndef OFF_TARGET_BUILD
-    const char dhclientCmd[MAX_LEN_START_CMD] = {'\0'};
     WlanContext_t* ctx = NULL;
     std::string ifname;
     int rc = 0;
+
     ENTER();
 
     ctx = (WlanContext_t*)m_globalCtx;
     (ctx->wpa_supp)->interface(ifname);
     // TODO: handle this error
 
-    /*
-     * TODO: call API to set interface with DHCP address...
-     * sendMsg(DHCP_IPV4_START, <interface name>)
-     * Temporary solution is to do it ourselves until VNM API is
-     * available
-     */
-    INFO("Starting dhclient on interface = %s\n", ifname.c_str());
-    rc = snprintf((char*)dhclientCmd, MAX_LEN_START_CMD,
-            "dhclient %s", ifname.c_str());
-
-    rc = os_system(dhclientCmd);
-    if (rc) {
-        ERROR("Failed to start dhclient with \"%s\" - %d\n", dhclientCmd, rc);
-        rc = -1;
-    } else {
-        INFO("dhclient started successfully - \"%s\"\n", dhclientCmd);
-    }
-#else
-    int rc = 0;
-    ENTER();
-
-    WARN("Skipping dynamic IP addressing for off-target mode\n");
-#endif /* OFF_TARGET_BUILD */
+    ctx->vnm_ipc->requestDhcpClient(ifname.c_str());
+    INFO("Called into VMN_IPC Dhcp Client");
 
     EXIT();
     return rc;
diff -Ndur '--exclude=.git' ./service/wstas/wstas.hpp /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wstas/wstas.hpp
--- ./service/wstas/wstas.hpp	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/service/wstas/wstas.hpp	2018-04-12 13:44:00.864000000 -0400
@@ -101,7 +101,8 @@
         int handleDisablingToError();
         int handleErrorToOff();
         int handleEventAuthenticated(WlanAction* action);
-        void handleEventScanResults(WlanAction  *action);
+        void handleEventScanResults(WlanAction *action);
+        void handleEventIpAddrUpdate(WlanAction *action);
 
         int setIpv4AddressStatic(ipv4Addr_t ip);
         int setIpv4AddressDynamic();
diff -Ndur '--exclude=.git' ./shared/wlan_ipc/proto/wlan_ipc.pb.cc /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/shared/wlan_ipc/proto/wlan_ipc.pb.cc
--- ./shared/wlan_ipc/proto/wlan_ipc.pb.cc	1969-12-31 19:00:00.000000000 -0500
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/shared/wlan_ipc/proto/wlan_ipc.pb.cc	2018-04-12 13:57:49.692000000 -0400
@@ -0,0 +1,11360 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: wlan_ipc.proto
+
+#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
+#include "wlan_ipc.pb.h"
+
+#include <algorithm>
+
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/stubs/port.h>
+#include <google/protobuf/stubs/once.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/wire_format_lite_inl.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/generated_message_reflection.h>
+#include <google/protobuf/reflection_ops.h>
+#include <google/protobuf/wire_format.h>
+// @@protoc_insertion_point(includes)
+class StaReqScanDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaReqScan> {
+} _StaReqScan_default_instance_;
+class StaRspScanDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaRspScan> {
+} _StaRspScan_default_instance_;
+class StaScanResultDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaScanResult> {
+} _StaScanResult_default_instance_;
+class StaScanResultsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaScanResults> {
+} _StaScanResults_default_instance_;
+class StaWepSecDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaWepSec> {
+} _StaWepSec_default_instance_;
+class StaWpsSecDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaWpsSec> {
+} _StaWpsSec_default_instance_;
+class StaPskSecDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaPskSec> {
+} _StaPskSec_default_instance_;
+class StaEapSecDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaEapSec> {
+} _StaEapSec_default_instance_;
+class StaStaticIpv4DefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaStaticIpv4> {
+} _StaStaticIpv4_default_instance_;
+class StaStaticIpv6DefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaStaticIpv6> {
+} _StaStaticIpv6_default_instance_;
+class StaReqConnectDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaReqConnect> {
+} _StaReqConnect_default_instance_;
+class StaRspConnectDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaRspConnect> {
+} _StaRspConnect_default_instance_;
+class StaReqDisconnectDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaReqDisconnect> {
+} _StaReqDisconnect_default_instance_;
+class StaRspDisconnectDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaRspDisconnect> {
+} _StaRspDisconnect_default_instance_;
+class StaStatusUpdateDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StaStatusUpdate> {
+} _StaStatusUpdate_default_instance_;
+class BtReqRequestFwDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BtReqRequestFw> {
+} _BtReqRequestFw_default_instance_;
+class BtRspRequestFwDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BtRspRequestFw> {
+} _BtRspRequestFw_default_instance_;
+class BtReqDeclineFwDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BtReqDeclineFw> {
+} _BtReqDeclineFw_default_instance_;
+class BtRspDeclineFwDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<BtRspDeclineFw> {
+} _BtRspDeclineFw_default_instance_;
+class WlanIpcCmdDataDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<WlanIpcCmdData> {
+} _WlanIpcCmdData_default_instance_;
+class WlanIpcMsgDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<WlanIpcMsg> {
+} _WlanIpcMsg_default_instance_;
+
+namespace protobuf_wlan_5fipc_2eproto {
+
+
+namespace {
+
+::google::protobuf::Metadata file_level_metadata[21];
+const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];
+
+}  // namespace
+
+PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
+    const TableStruct::entries[] = {
+  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
+};
+
+PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
+    const TableStruct::aux[] = {
+  ::google::protobuf::internal::AuxillaryParseTableField(),
+};
+PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
+    TableStruct::schema[] = {
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+  { NULL, NULL, 0, -1, -1, false },
+};
+
+const ::google::protobuf::uint32 TableStruct::offsets[] = {
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqScan, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqScan, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqScan, ssid_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqScan, channel_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqScan, type_),
+  ~0u,
+  ~0u,
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspScan, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspScan, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspScan, scan_id_),
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, ssid_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, bssid_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, ch_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, bw_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, rssi_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, sec_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, wps_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResult, ess_),
+  0,
+  1,
+  2,
+  3,
+  4,
+  5,
+  6,
+  7,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, scan_id_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, success_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, params_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, count_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaScanResults, res_),
+  1,
+  2,
+  0,
+  3,
+  ~0u,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, key0_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, key1_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, key2_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, key3_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWepSec, defaultkey_),
+  0,
+  1,
+  2,
+  3,
+  4,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWpsSec, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWpsSec, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWpsSec, type_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaWpsSec, pin_),
+  1,
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaPskSec, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaPskSec, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaPskSec, password_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaPskSec, paircipher_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaPskSec, groupcipher_),
+  0,
+  1,
+  2,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaEapSec, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaEapSec, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStaticIpv4, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStaticIpv4, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStaticIpv6, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStaticIpv6, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, ssid_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, bssid_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, channel_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, sectype_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, wepsec_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, wpssec_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, psksec_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, eapsec_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, ipv4type_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, staticipv4_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, ipv6type_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqConnect, staticipv6_),
+  0,
+  1,
+  8,
+  9,
+  2,
+  3,
+  4,
+  5,
+  10,
+  6,
+  11,
+  7,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspConnect, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspConnect, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspConnect, rsp_),
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqDisconnect, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaReqDisconnect, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspDisconnect, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspDisconnect, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaRspDisconnect, rsp_),
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, macaddr_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, smstate_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, constate_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, ssid_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, security_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, paircipher_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, groupcipher_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, channel_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, bw_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, tech_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, datarate_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, rssi_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, noise_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, snr_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, ip_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, netmask_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, gateway_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, dnspref_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StaStatusUpdate, dnsalt_),
+  0,
+  7,
+  8,
+  1,
+  9,
+  10,
+  11,
+  12,
+  13,
+  14,
+  15,
+  16,
+  17,
+  18,
+  2,
+  3,
+  4,
+  5,
+  6,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtReqRequestFw, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtReqRequestFw, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtRspRequestFw, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtRspRequestFw, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtRspRequestFw, rsp_),
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtReqDeclineFw, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtReqDeclineFw, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtRspDeclineFw, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtRspDeclineFw, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BtRspDeclineFw, rsp_),
+  0,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, reqscan_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, rspscan_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, reqconnect_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, rspconnect_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, reqdisconnect_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, rspdisconnect_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, reqrequestfw_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, rsprequestfw_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, reqdeclinefw_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, rspdeclinefw_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, scanres_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcCmdData, stastatus_),
+  0,
+  1,
+  2,
+  3,
+  4,
+  5,
+  6,
+  7,
+  8,
+  9,
+  10,
+  11,
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcMsg, _has_bits_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcMsg, _internal_metadata_),
+  ~0u,  // no _extensions_
+  ~0u,  // no _oneof_case_
+  ~0u,  // no _weak_field_map_
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcMsg, ver_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcMsg, type_),
+  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WlanIpcMsg, data_),
+  1,
+  2,
+  0,
+};
+
+static const ::google::protobuf::internal::MigrationSchema schemas[] = {
+  { 0, 8, sizeof(StaReqScan)},
+  { 11, 17, sizeof(StaRspScan)},
+  { 18, 31, sizeof(StaScanResult)},
+  { 39, 49, sizeof(StaScanResults)},
+  { 54, 64, sizeof(StaWepSec)},
+  { 69, 76, sizeof(StaWpsSec)},
+  { 78, 86, sizeof(StaPskSec)},
+  { 89, 94, sizeof(StaEapSec)},
+  { 94, 99, sizeof(StaStaticIpv4)},
+  { 99, 104, sizeof(StaStaticIpv6)},
+  { 104, 121, sizeof(StaReqConnect)},
+  { 133, 139, sizeof(StaRspConnect)},
+  { 140, 145, sizeof(StaReqDisconnect)},
+  { 145, 151, sizeof(StaRspDisconnect)},
+  { 152, 176, sizeof(StaStatusUpdate)},
+  { 195, 200, sizeof(BtReqRequestFw)},
+  { 200, 206, sizeof(BtRspRequestFw)},
+  { 207, 212, sizeof(BtReqDeclineFw)},
+  { 212, 218, sizeof(BtRspDeclineFw)},
+  { 219, 236, sizeof(WlanIpcCmdData)},
+  { 248, 256, sizeof(WlanIpcMsg)},
+};
+
+static ::google::protobuf::Message const * const file_default_instances[] = {
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaReqScan_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaRspScan_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaScanResult_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaScanResults_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaWepSec_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaWpsSec_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaPskSec_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaEapSec_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaStaticIpv4_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaStaticIpv6_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaReqConnect_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaRspConnect_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaReqDisconnect_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaRspDisconnect_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_StaStatusUpdate_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_BtReqRequestFw_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_BtRspRequestFw_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_BtReqDeclineFw_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_BtRspDeclineFw_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_WlanIpcCmdData_default_instance_),
+  reinterpret_cast<const ::google::protobuf::Message*>(&_WlanIpcMsg_default_instance_),
+};
+
+namespace {
+
+void protobuf_AssignDescriptors() {
+  AddDescriptors();
+  ::google::protobuf::MessageFactory* factory = NULL;
+  AssignDescriptors(
+      "wlan_ipc.proto", schemas, file_default_instances, TableStruct::offsets, factory,
+      file_level_metadata, file_level_enum_descriptors, NULL);
+}
+
+void protobuf_AssignDescriptorsOnce() {
+  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
+  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
+}
+
+void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
+void protobuf_RegisterTypes(const ::std::string&) {
+  protobuf_AssignDescriptorsOnce();
+  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 21);
+}
+
+}  // namespace
+
+void TableStruct::Shutdown() {
+  _StaReqScan_default_instance_.Shutdown();
+  delete file_level_metadata[0].reflection;
+  _StaRspScan_default_instance_.Shutdown();
+  delete file_level_metadata[1].reflection;
+  _StaScanResult_default_instance_.Shutdown();
+  delete file_level_metadata[2].reflection;
+  _StaScanResults_default_instance_.Shutdown();
+  delete file_level_metadata[3].reflection;
+  _StaWepSec_default_instance_.Shutdown();
+  delete file_level_metadata[4].reflection;
+  _StaWpsSec_default_instance_.Shutdown();
+  delete file_level_metadata[5].reflection;
+  _StaPskSec_default_instance_.Shutdown();
+  delete file_level_metadata[6].reflection;
+  _StaEapSec_default_instance_.Shutdown();
+  delete file_level_metadata[7].reflection;
+  _StaStaticIpv4_default_instance_.Shutdown();
+  delete file_level_metadata[8].reflection;
+  _StaStaticIpv6_default_instance_.Shutdown();
+  delete file_level_metadata[9].reflection;
+  _StaReqConnect_default_instance_.Shutdown();
+  delete file_level_metadata[10].reflection;
+  _StaRspConnect_default_instance_.Shutdown();
+  delete file_level_metadata[11].reflection;
+  _StaReqDisconnect_default_instance_.Shutdown();
+  delete file_level_metadata[12].reflection;
+  _StaRspDisconnect_default_instance_.Shutdown();
+  delete file_level_metadata[13].reflection;
+  _StaStatusUpdate_default_instance_.Shutdown();
+  delete file_level_metadata[14].reflection;
+  _BtReqRequestFw_default_instance_.Shutdown();
+  delete file_level_metadata[15].reflection;
+  _BtRspRequestFw_default_instance_.Shutdown();
+  delete file_level_metadata[16].reflection;
+  _BtReqDeclineFw_default_instance_.Shutdown();
+  delete file_level_metadata[17].reflection;
+  _BtRspDeclineFw_default_instance_.Shutdown();
+  delete file_level_metadata[18].reflection;
+  _WlanIpcCmdData_default_instance_.Shutdown();
+  delete file_level_metadata[19].reflection;
+  _WlanIpcMsg_default_instance_.Shutdown();
+  delete file_level_metadata[20].reflection;
+}
+
+void TableStruct::InitDefaultsImpl() {
+  GOOGLE_PROTOBUF_VERIFY_VERSION;
+
+  ::google::protobuf::internal::InitProtobufDefaults();
+  _StaReqScan_default_instance_.DefaultConstruct();
+  _StaRspScan_default_instance_.DefaultConstruct();
+  _StaScanResult_default_instance_.DefaultConstruct();
+  _StaScanResults_default_instance_.DefaultConstruct();
+  _StaWepSec_default_instance_.DefaultConstruct();
+  _StaWpsSec_default_instance_.DefaultConstruct();
+  _StaPskSec_default_instance_.DefaultConstruct();
+  _StaEapSec_default_instance_.DefaultConstruct();
+  _StaStaticIpv4_default_instance_.DefaultConstruct();
+  _StaStaticIpv6_default_instance_.DefaultConstruct();
+  _StaReqConnect_default_instance_.DefaultConstruct();
+  _StaRspConnect_default_instance_.DefaultConstruct();
+  _StaReqDisconnect_default_instance_.DefaultConstruct();
+  _StaRspDisconnect_default_instance_.DefaultConstruct();
+  _StaStatusUpdate_default_instance_.DefaultConstruct();
+  _BtReqRequestFw_default_instance_.DefaultConstruct();
+  _BtRspRequestFw_default_instance_.DefaultConstruct();
+  _BtReqDeclineFw_default_instance_.DefaultConstruct();
+  _BtRspDeclineFw_default_instance_.DefaultConstruct();
+  _WlanIpcCmdData_default_instance_.DefaultConstruct();
+  _WlanIpcMsg_default_instance_.DefaultConstruct();
+  _StaScanResults_default_instance_.get_mutable()->params_ = const_cast< ::StaReqScan*>(
+      ::StaReqScan::internal_default_instance());
+  _StaReqConnect_default_instance_.get_mutable()->wepsec_ = const_cast< ::StaWepSec*>(
+      ::StaWepSec::internal_default_instance());
+  _StaReqConnect_default_instance_.get_mutable()->wpssec_ = const_cast< ::StaWpsSec*>(
+      ::StaWpsSec::internal_default_instance());
+  _StaReqConnect_default_instance_.get_mutable()->psksec_ = const_cast< ::StaPskSec*>(
+      ::StaPskSec::internal_default_instance());
+  _StaReqConnect_default_instance_.get_mutable()->eapsec_ = const_cast< ::StaEapSec*>(
+      ::StaEapSec::internal_default_instance());
+  _StaReqConnect_default_instance_.get_mutable()->staticipv4_ = const_cast< ::StaStaticIpv4*>(
+      ::StaStaticIpv4::internal_default_instance());
+  _StaReqConnect_default_instance_.get_mutable()->staticipv6_ = const_cast< ::StaStaticIpv6*>(
+      ::StaStaticIpv6::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->reqscan_ = const_cast< ::StaReqScan*>(
+      ::StaReqScan::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->rspscan_ = const_cast< ::StaRspScan*>(
+      ::StaRspScan::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->reqconnect_ = const_cast< ::StaReqConnect*>(
+      ::StaReqConnect::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->rspconnect_ = const_cast< ::StaRspConnect*>(
+      ::StaRspConnect::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->reqdisconnect_ = const_cast< ::StaReqDisconnect*>(
+      ::StaReqDisconnect::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->rspdisconnect_ = const_cast< ::StaRspDisconnect*>(
+      ::StaRspDisconnect::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->reqrequestfw_ = const_cast< ::BtReqRequestFw*>(
+      ::BtReqRequestFw::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->rsprequestfw_ = const_cast< ::BtRspRequestFw*>(
+      ::BtRspRequestFw::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->reqdeclinefw_ = const_cast< ::BtReqDeclineFw*>(
+      ::BtReqDeclineFw::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->rspdeclinefw_ = const_cast< ::BtRspDeclineFw*>(
+      ::BtRspDeclineFw::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->scanres_ = const_cast< ::StaScanResults*>(
+      ::StaScanResults::internal_default_instance());
+  _WlanIpcCmdData_default_instance_.get_mutable()->stastatus_ = const_cast< ::StaStatusUpdate*>(
+      ::StaStatusUpdate::internal_default_instance());
+  _WlanIpcMsg_default_instance_.get_mutable()->data_ = const_cast< ::WlanIpcCmdData*>(
+      ::WlanIpcCmdData::internal_default_instance());
+}
+
+void InitDefaults() {
+  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
+  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
+}
+void AddDescriptorsImpl() {
+  InitDefaults();
+  static const char descriptor[] = {
+      "\n\016wlan_ipc.proto\"Y\n\nStaReqScan\022\014\n\004ssid\030\001"
+      " \003(\014\022\017\n\007channel\030\002 \003(\r\022,\n\004type\030\003 \001(\0162\014.St"
+      "aScanType:\020SCAN_TYPE_ACTIVE\"\035\n\nStaRspSca"
+      "n\022\017\n\007scan_id\030\002 \001(\005\"y\n\rStaScanResult\022\014\n\004s"
+      "sid\030\001 \001(\014\022\r\n\005bssid\030\002 \001(\014\022\n\n\002ch\030\003 \001(\r\022\n\n\002"
+      "bw\030\004 \001(\r\022\014\n\004rssi\030\005 \001(\005\022\013\n\003sec\030\006 \001(\r\022\013\n\003w"
+      "ps\030\007 \001(\010\022\013\n\003ess\030\010 \001(\010\"{\n\016StaScanResults\022"
+      "\017\n\007scan_id\030\001 \001(\005\022\017\n\007success\030\002 \001(\010\022\033\n\006par"
+      "ams\030\003 \001(\0132\013.StaReqScan\022\r\n\005count\030\004 \001(\005\022\033\n"
+      "\003res\030\005 \003(\0132\016.StaScanResult\"W\n\tStaWepSec\022"
+      "\014\n\004key0\030\001 \001(\014\022\014\n\004key1\030\002 \001(\014\022\014\n\004key2\030\003 \001("
+      "\014\022\014\n\004key3\030\004 \001(\014\022\022\n\ndefaultKey\030\005 \001(\r\"&\n\tS"
+      "taWpsSec\022\014\n\004type\030\001 \001(\r\022\013\n\003pin\030\002 \001(\014\"F\n\tS"
+      "taPskSec\022\020\n\010password\030\001 \001(\014\022\022\n\npairCipher"
+      "\030\002 \001(\r\022\023\n\013groupCipher\030\003 \001(\r\"\013\n\tStaEapSec"
+      "\"\017\n\rStaStaticIpv4\"\017\n\rStaStaticIpv6\"\252\002\n\rS"
+      "taReqConnect\022\014\n\004ssid\030\001 \001(\014\022\r\n\005bssid\030\002 \001("
+      "\014\022\017\n\007channel\030\003 \001(\r\022\017\n\007secType\030\004 \001(\r\022\032\n\006w"
+      "epSec\030\005 \001(\0132\n.StaWepSec\022\032\n\006wpsSec\030\006 \001(\0132"
+      "\n.StaWpsSec\022\032\n\006pskSec\030\007 \001(\0132\n.StaPskSec\022"
+      "\032\n\006eapSec\030\010 \001(\0132\n.StaEapSec\022\020\n\010ipv4Type\030"
+      "\t \001(\r\022\"\n\nstaticIpv4\030\n \001(\0132\016.StaStaticIpv"
+      "4\022\020\n\010ipv6Type\030\013 \001(\r\022\"\n\nstaticIpv6\030\014 \001(\0132"
+      "\016.StaStaticIpv6\",\n\rStaRspConnect\022\033\n\003rsp\030"
+      "\001 \001(\0162\016.WlanIpcCmdRsp\"\022\n\020StaReqDisconnec"
+      "t\"/\n\020StaRspDisconnect\022\033\n\003rsp\030\001 \001(\0162\016.Wla"
+      "nIpcCmdRsp\"\304\002\n\017StaStatusUpdate\022\017\n\007macAdd"
+      "r\030\001 \001(\014\022\017\n\007smState\030\002 \001(\r\022\020\n\010conState\030\003 \001"
+      "(\r\022\014\n\004ssid\030\004 \001(\014\022\020\n\010security\030\005 \001(\r\022\022\n\npa"
+      "irCipher\030\006 \001(\r\022\023\n\013groupCipher\030\007 \001(\r\022\017\n\007c"
+      "hannel\030\010 \001(\r\022\n\n\002bw\030\t \001(\r\022\014\n\004tech\030\n \001(\r\022\020"
+      "\n\010dataRate\030\013 \001(\r\022\014\n\004rssi\030\014 \001(\005\022\r\n\005noise\030"
+      "\r \001(\005\022\013\n\003snr\030\016 \001(\005\022\n\n\002ip\030\017 \001(\014\022\017\n\007netmas"
+      "k\030\020 \001(\014\022\017\n\007gateway\030\021 \001(\014\022\017\n\007dnsPref\030\022 \001("
+      "\014\022\016\n\006dnsAlt\030\023 \001(\014\"\020\n\016BtReqRequestFw\"-\n\016B"
+      "tRspRequestFw\022\033\n\003rsp\030\001 \001(\0162\016.WlanIpcCmdR"
+      "sp\"\020\n\016BtReqDeclineFw\"-\n\016BtRspDeclineFw\022\033"
+      "\n\003rsp\030\001 \001(\0162\016.WlanIpcCmdRsp\"\321\003\n\016WlanIpcC"
+      "mdData\022\034\n\007reqScan\030\001 \001(\0132\013.StaReqScan\022\034\n\007"
+      "rspScan\030\002 \001(\0132\013.StaRspScan\022\"\n\nreqConnect"
+      "\030\003 \001(\0132\016.StaReqConnect\022\"\n\nrspConnect\030\004 \001"
+      "(\0132\016.StaRspConnect\022(\n\rreqDisconnect\030\005 \001("
+      "\0132\021.StaReqDisconnect\022(\n\rrspDisconnect\030\006 "
+      "\001(\0132\021.StaRspDisconnect\022&\n\014reqRequestFw\030\255"
+      "\002 \001(\0132\017.BtReqRequestFw\022&\n\014rspRequestFw\030\256"
+      "\002 \001(\0132\017.BtRspRequestFw\022&\n\014reqDeclineFw\030\257"
+      "\002 \001(\0132\017.BtReqDeclineFw\022&\n\014rspDeclineFw\030\260"
+      "\002 \001(\0132\017.BtRspDeclineFw\022!\n\007scanRes\030\221\003 \001(\013"
+      "2\017.StaScanResults\022$\n\tstaStatus\030\222\003 \001(\0132\020."
+      "StaStatusUpdate\"W\n\nWlanIpcMsg\022\013\n\003ver\030\001 \002"
+      "(\005\022\035\n\004type\030\002 \002(\0162\017.WlanIpcCmdType\022\035\n\004dat"
+      "a\030\003 \001(\0132\017.WlanIpcCmdData*\344\002\n\016WlanIpcCmdT"
+      "ype\022\020\n\014STA_REQ_SCAN\020\001\022\020\n\014STA_RSP_SCAN\020\002\022"
+      "\023\n\017STA_REQ_CONNECT\020\003\022\023\n\017STA_RSP_CONNECT\020"
+      "\004\022\026\n\022STA_REQ_DISCONNECT\020\005\022\026\n\022STA_RSP_DIS"
+      "CONNECT\020\006\022\026\n\021BT_REQ_REQUEST_FW\020\255\002\022\026\n\021BT_"
+      "RSP_REQUEST_FW\020\256\002\022\026\n\021BT_REQ_DECLINE_FW\020\257"
+      "\002\022\026\n\021BT_RSP_DECLINE_FW\020\260\002\022\024\n\017BT_REQ_RESE"
+      "T_FW\020\261\002\022\024\n\017BT_RSP_RESET_FW\020\262\002\022\025\n\020STA_SCA"
+      "N_RESULTS\020\221\003\022\026\n\021STA_STATUS_UPDATE\020\222\003\022\031\n\024"
+      "STA_PKT_STATS_UPDATE\020\223\003*/\n\rWlanIpcCmdRsp"
+      "\022\017\n\013RSP_SUCCESS\020\000\022\r\n\tRSP_ERROR\020\001*:\n\013StaS"
+      "canType\022\024\n\020SCAN_TYPE_ACTIVE\020\000\022\025\n\021SCAN_TY"
+      "PE_PASSIVE\020\001"
+  };
+  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
+      descriptor, 2532);
+  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
+    "wlan_ipc.proto", &protobuf_RegisterTypes);
+  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
+}
+
+void AddDescriptors() {
+  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
+  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
+}
+// Force AddDescriptors() to be called at static initialization time.
+struct StaticDescriptorInitializer {
+  StaticDescriptorInitializer() {
+    AddDescriptors();
+  }
+} static_descriptor_initializer;
+
+}  // namespace protobuf_wlan_5fipc_2eproto
+
+const ::google::protobuf::EnumDescriptor* WlanIpcCmdType_descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_enum_descriptors[0];
+}
+bool WlanIpcCmdType_IsValid(int value) {
+  switch (value) {
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 301:
+    case 302:
+    case 303:
+    case 304:
+    case 305:
+    case 306:
+    case 401:
+    case 402:
+    case 403:
+      return true;
+    default:
+      return false;
+  }
+}
+
+const ::google::protobuf::EnumDescriptor* WlanIpcCmdRsp_descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_enum_descriptors[1];
+}
+bool WlanIpcCmdRsp_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+      return true;
+    default:
+      return false;
+  }
+}
+
+const ::google::protobuf::EnumDescriptor* StaScanType_descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_enum_descriptors[2];
+}
+bool StaScanType_IsValid(int value) {
+  switch (value) {
+    case 0:
+    case 1:
+      return true;
+    default:
+      return false;
+  }
+}
+
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaReqScan::kSsidFieldNumber;
+const int StaReqScan::kChannelFieldNumber;
+const int StaReqScan::kTypeFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaReqScan::StaReqScan()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaReqScan)
+}
+StaReqScan::StaReqScan(const StaReqScan& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0),
+      ssid_(from.ssid_),
+      channel_(from.channel_) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  type_ = from.type_;
+  // @@protoc_insertion_point(copy_constructor:StaReqScan)
+}
+
+void StaReqScan::SharedCtor() {
+  _cached_size_ = 0;
+  type_ = 0;
+}
+
+StaReqScan::~StaReqScan() {
+  // @@protoc_insertion_point(destructor:StaReqScan)
+  SharedDtor();
+}
+
+void StaReqScan::SharedDtor() {
+}
+
+void StaReqScan::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaReqScan::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaReqScan& StaReqScan::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaReqScan* StaReqScan::New(::google::protobuf::Arena* arena) const {
+  StaReqScan* n = new StaReqScan;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaReqScan::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaReqScan)
+  ssid_.Clear();
+  channel_.Clear();
+  type_ = 0;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaReqScan::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaReqScan)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // repeated bytes ssid = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->add_ssid()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // repeated uint32 channel = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(16u)) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 1, 16u, input, this->mutable_channel())));
+        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
+                   static_cast< ::google::protobuf::uint8>(18u)) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, this->mutable_channel())));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(24u)) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::StaScanType_IsValid(value)) {
+            set_type(static_cast< ::StaScanType >(value));
+          } else {
+            mutable_unknown_fields()->AddVarint(3, value);
+          }
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaReqScan)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaReqScan)
+  return false;
+#undef DO_
+}
+
+void StaReqScan::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaReqScan)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // repeated bytes ssid = 1;
+  for (int i = 0, n = this->ssid_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytes(
+      1, this->ssid(i), output);
+  }
+
+  // repeated uint32 channel = 2;
+  for (int i = 0, n = this->channel_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
+      2, this->channel(i), output);
+  }
+
+  cached_has_bits = _has_bits_[0];
+  // optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      3, this->type(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaReqScan)
+}
+
+::google::protobuf::uint8* StaReqScan::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaReqScan)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  // repeated bytes ssid = 1;
+  for (int i = 0, n = this->ssid_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      WriteBytesToArray(1, this->ssid(i), target);
+  }
+
+  // repeated uint32 channel = 2;
+  target = ::google::protobuf::internal::WireFormatLite::
+    WriteUInt32ToArray(2, this->channel_, target);
+
+  cached_has_bits = _has_bits_[0];
+  // optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
+      3, this->type(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaReqScan)
+  return target;
+}
+
+size_t StaReqScan::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaReqScan)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // repeated bytes ssid = 1;
+  total_size += 1 *
+      ::google::protobuf::internal::FromIntSize(this->ssid_size());
+  for (int i = 0, n = this->ssid_size(); i < n; i++) {
+    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
+      this->ssid(i));
+  }
+
+  // repeated uint32 channel = 2;
+  {
+    size_t data_size = ::google::protobuf::internal::WireFormatLite::
+      UInt32Size(this->channel_);
+    total_size += 1 *
+                  ::google::protobuf::internal::FromIntSize(this->channel_size());
+    total_size += data_size;
+  }
+
+  // optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+  if (has_type()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaReqScan::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaReqScan)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaReqScan* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaReqScan>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaReqScan)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaReqScan)
+    MergeFrom(*source);
+  }
+}
+
+void StaReqScan::MergeFrom(const StaReqScan& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaReqScan)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  ssid_.MergeFrom(from.ssid_);
+  channel_.MergeFrom(from.channel_);
+  if (from.has_type()) {
+    set_type(from.type());
+  }
+}
+
+void StaReqScan::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaReqScan)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaReqScan::CopyFrom(const StaReqScan& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaReqScan)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaReqScan::IsInitialized() const {
+  return true;
+}
+
+void StaReqScan::Swap(StaReqScan* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaReqScan::InternalSwap(StaReqScan* other) {
+  ssid_.InternalSwap(&other->ssid_);
+  channel_.InternalSwap(&other->channel_);
+  std::swap(type_, other->type_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaReqScan::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaReqScan
+
+// repeated bytes ssid = 1;
+int StaReqScan::ssid_size() const {
+  return ssid_.size();
+}
+void StaReqScan::clear_ssid() {
+  ssid_.Clear();
+}
+const ::std::string& StaReqScan::ssid(int index) const {
+  // @@protoc_insertion_point(field_get:StaReqScan.ssid)
+  return ssid_.Get(index);
+}
+::std::string* StaReqScan::mutable_ssid(int index) {
+  // @@protoc_insertion_point(field_mutable:StaReqScan.ssid)
+  return ssid_.Mutable(index);
+}
+void StaReqScan::set_ssid(int index, const ::std::string& value) {
+  // @@protoc_insertion_point(field_set:StaReqScan.ssid)
+  ssid_.Mutable(index)->assign(value);
+}
+#if LANG_CXX11
+void StaReqScan::set_ssid(int index, ::std::string&& value) {
+  // @@protoc_insertion_point(field_set:StaReqScan.ssid)
+  ssid_.Mutable(index)->assign(std::move(value));
+}
+#endif
+void StaReqScan::set_ssid(int index, const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  ssid_.Mutable(index)->assign(value);
+  // @@protoc_insertion_point(field_set_char:StaReqScan.ssid)
+}
+void StaReqScan::set_ssid(int index, const void* value, size_t size) {
+  ssid_.Mutable(index)->assign(
+    reinterpret_cast<const char*>(value), size);
+  // @@protoc_insertion_point(field_set_pointer:StaReqScan.ssid)
+}
+::std::string* StaReqScan::add_ssid() {
+  // @@protoc_insertion_point(field_add_mutable:StaReqScan.ssid)
+  return ssid_.Add();
+}
+void StaReqScan::add_ssid(const ::std::string& value) {
+  ssid_.Add()->assign(value);
+  // @@protoc_insertion_point(field_add:StaReqScan.ssid)
+}
+#if LANG_CXX11
+void StaReqScan::add_ssid(::std::string&& value) {
+  ssid_.Add(std::move(value));
+  // @@protoc_insertion_point(field_add:StaReqScan.ssid)
+}
+#endif
+void StaReqScan::add_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  ssid_.Add()->assign(value);
+  // @@protoc_insertion_point(field_add_char:StaReqScan.ssid)
+}
+void StaReqScan::add_ssid(const void* value, size_t size) {
+  ssid_.Add()->assign(reinterpret_cast<const char*>(value), size);
+  // @@protoc_insertion_point(field_add_pointer:StaReqScan.ssid)
+}
+const ::google::protobuf::RepeatedPtrField< ::std::string>&
+StaReqScan::ssid() const {
+  // @@protoc_insertion_point(field_list:StaReqScan.ssid)
+  return ssid_;
+}
+::google::protobuf::RepeatedPtrField< ::std::string>*
+StaReqScan::mutable_ssid() {
+  // @@protoc_insertion_point(field_mutable_list:StaReqScan.ssid)
+  return &ssid_;
+}
+
+// repeated uint32 channel = 2;
+int StaReqScan::channel_size() const {
+  return channel_.size();
+}
+void StaReqScan::clear_channel() {
+  channel_.Clear();
+}
+::google::protobuf::uint32 StaReqScan::channel(int index) const {
+  // @@protoc_insertion_point(field_get:StaReqScan.channel)
+  return channel_.Get(index);
+}
+void StaReqScan::set_channel(int index, ::google::protobuf::uint32 value) {
+  channel_.Set(index, value);
+  // @@protoc_insertion_point(field_set:StaReqScan.channel)
+}
+void StaReqScan::add_channel(::google::protobuf::uint32 value) {
+  channel_.Add(value);
+  // @@protoc_insertion_point(field_add:StaReqScan.channel)
+}
+const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
+StaReqScan::channel() const {
+  // @@protoc_insertion_point(field_list:StaReqScan.channel)
+  return channel_;
+}
+::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
+StaReqScan::mutable_channel() {
+  // @@protoc_insertion_point(field_mutable_list:StaReqScan.channel)
+  return &channel_;
+}
+
+// optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+bool StaReqScan::has_type() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaReqScan::set_has_type() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaReqScan::clear_has_type() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaReqScan::clear_type() {
+  type_ = 0;
+  clear_has_type();
+}
+::StaScanType StaReqScan::type() const {
+  // @@protoc_insertion_point(field_get:StaReqScan.type)
+  return static_cast< ::StaScanType >(type_);
+}
+void StaReqScan::set_type(::StaScanType value) {
+  assert(::StaScanType_IsValid(value));
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:StaReqScan.type)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaRspScan::kScanIdFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaRspScan::StaRspScan()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaRspScan)
+}
+StaRspScan::StaRspScan(const StaRspScan& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  scan_id_ = from.scan_id_;
+  // @@protoc_insertion_point(copy_constructor:StaRspScan)
+}
+
+void StaRspScan::SharedCtor() {
+  _cached_size_ = 0;
+  scan_id_ = 0;
+}
+
+StaRspScan::~StaRspScan() {
+  // @@protoc_insertion_point(destructor:StaRspScan)
+  SharedDtor();
+}
+
+void StaRspScan::SharedDtor() {
+}
+
+void StaRspScan::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaRspScan::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaRspScan& StaRspScan::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaRspScan* StaRspScan::New(::google::protobuf::Arena* arena) const {
+  StaRspScan* n = new StaRspScan;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaRspScan::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaRspScan)
+  scan_id_ = 0;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaRspScan::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaRspScan)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional int32 scan_id = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(16u)) {
+          set_has_scan_id();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &scan_id_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaRspScan)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaRspScan)
+  return false;
+#undef DO_
+}
+
+void StaRspScan::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaRspScan)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional int32 scan_id = 2;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->scan_id(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaRspScan)
+}
+
+::google::protobuf::uint8* StaRspScan::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaRspScan)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional int32 scan_id = 2;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->scan_id(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaRspScan)
+  return target;
+}
+
+size_t StaRspScan::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaRspScan)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // optional int32 scan_id = 2;
+  if (has_scan_id()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::Int32Size(
+        this->scan_id());
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaRspScan::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaRspScan)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaRspScan* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaRspScan>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaRspScan)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaRspScan)
+    MergeFrom(*source);
+  }
+}
+
+void StaRspScan::MergeFrom(const StaRspScan& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaRspScan)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from.has_scan_id()) {
+    set_scan_id(from.scan_id());
+  }
+}
+
+void StaRspScan::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaRspScan)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaRspScan::CopyFrom(const StaRspScan& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaRspScan)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaRspScan::IsInitialized() const {
+  return true;
+}
+
+void StaRspScan::Swap(StaRspScan* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaRspScan::InternalSwap(StaRspScan* other) {
+  std::swap(scan_id_, other->scan_id_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaRspScan::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaRspScan
+
+// optional int32 scan_id = 2;
+bool StaRspScan::has_scan_id() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaRspScan::set_has_scan_id() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaRspScan::clear_has_scan_id() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaRspScan::clear_scan_id() {
+  scan_id_ = 0;
+  clear_has_scan_id();
+}
+::google::protobuf::int32 StaRspScan::scan_id() const {
+  // @@protoc_insertion_point(field_get:StaRspScan.scan_id)
+  return scan_id_;
+}
+void StaRspScan::set_scan_id(::google::protobuf::int32 value) {
+  set_has_scan_id();
+  scan_id_ = value;
+  // @@protoc_insertion_point(field_set:StaRspScan.scan_id)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaScanResult::kSsidFieldNumber;
+const int StaScanResult::kBssidFieldNumber;
+const int StaScanResult::kChFieldNumber;
+const int StaScanResult::kBwFieldNumber;
+const int StaScanResult::kRssiFieldNumber;
+const int StaScanResult::kSecFieldNumber;
+const int StaScanResult::kWpsFieldNumber;
+const int StaScanResult::kEssFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaScanResult::StaScanResult()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaScanResult)
+}
+StaScanResult::StaScanResult(const StaScanResult& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_ssid()) {
+    ssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ssid_);
+  }
+  bssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_bssid()) {
+    bssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bssid_);
+  }
+  ::memcpy(&ch_, &from.ch_,
+    reinterpret_cast<char*>(&ess_) -
+    reinterpret_cast<char*>(&ch_) + sizeof(ess_));
+  // @@protoc_insertion_point(copy_constructor:StaScanResult)
+}
+
+void StaScanResult::SharedCtor() {
+  _cached_size_ = 0;
+  ssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  bssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ::memset(&ch_, 0, reinterpret_cast<char*>(&ess_) -
+    reinterpret_cast<char*>(&ch_) + sizeof(ess_));
+}
+
+StaScanResult::~StaScanResult() {
+  // @@protoc_insertion_point(destructor:StaScanResult)
+  SharedDtor();
+}
+
+void StaScanResult::SharedDtor() {
+  ssid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  bssid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void StaScanResult::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaScanResult::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaScanResult& StaScanResult::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaScanResult* StaScanResult::New(::google::protobuf::Arena* arena) const {
+  StaScanResult* n = new StaScanResult;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaScanResult::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaScanResult)
+  if (_has_bits_[0 / 32] & 3u) {
+    if (has_ssid()) {
+      GOOGLE_DCHECK(!ssid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*ssid_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_bssid()) {
+      GOOGLE_DCHECK(!bssid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*bssid_.UnsafeRawStringPointer())->clear();
+    }
+  }
+  if (_has_bits_[0 / 32] & 252u) {
+    ::memset(&ch_, 0, reinterpret_cast<char*>(&ess_) -
+      reinterpret_cast<char*>(&ch_) + sizeof(ess_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaScanResult::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaScanResult)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional bytes ssid = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_ssid()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes bssid = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(18u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_bssid()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 ch = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(24u)) {
+          set_has_ch();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &ch_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 bw = 4;
+      case 4: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(32u)) {
+          set_has_bw();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &bw_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional int32 rssi = 5;
+      case 5: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(40u)) {
+          set_has_rssi();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &rssi_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 sec = 6;
+      case 6: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(48u)) {
+          set_has_sec();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &sec_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bool wps = 7;
+      case 7: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(56u)) {
+          set_has_wps();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, &wps_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bool ess = 8;
+      case 8: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(64u)) {
+          set_has_ess();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, &ess_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaScanResult)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaScanResult)
+  return false;
+#undef DO_
+}
+
+void StaScanResult::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaScanResult)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes ssid = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      1, this->ssid(), output);
+  }
+
+  // optional bytes bssid = 2;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      2, this->bssid(), output);
+  }
+
+  // optional uint32 ch = 3;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ch(), output);
+  }
+
+  // optional uint32 bw = 4;
+  if (cached_has_bits & 0x00000008u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->bw(), output);
+  }
+
+  // optional int32 rssi = 5;
+  if (cached_has_bits & 0x00000010u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->rssi(), output);
+  }
+
+  // optional uint32 sec = 6;
+  if (cached_has_bits & 0x00000020u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->sec(), output);
+  }
+
+  // optional bool wps = 7;
+  if (cached_has_bits & 0x00000040u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->wps(), output);
+  }
+
+  // optional bool ess = 8;
+  if (cached_has_bits & 0x00000080u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->ess(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaScanResult)
+}
+
+::google::protobuf::uint8* StaScanResult::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaScanResult)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes ssid = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        1, this->ssid(), target);
+  }
+
+  // optional bytes bssid = 2;
+  if (cached_has_bits & 0x00000002u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        2, this->bssid(), target);
+  }
+
+  // optional uint32 ch = 3;
+  if (cached_has_bits & 0x00000004u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->ch(), target);
+  }
+
+  // optional uint32 bw = 4;
+  if (cached_has_bits & 0x00000008u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->bw(), target);
+  }
+
+  // optional int32 rssi = 5;
+  if (cached_has_bits & 0x00000010u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->rssi(), target);
+  }
+
+  // optional uint32 sec = 6;
+  if (cached_has_bits & 0x00000020u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->sec(), target);
+  }
+
+  // optional bool wps = 7;
+  if (cached_has_bits & 0x00000040u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->wps(), target);
+  }
+
+  // optional bool ess = 8;
+  if (cached_has_bits & 0x00000080u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->ess(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaScanResult)
+  return target;
+}
+
+size_t StaScanResult::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaScanResult)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 255u) {
+    // optional bytes ssid = 1;
+    if (has_ssid()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->ssid());
+    }
+
+    // optional bytes bssid = 2;
+    if (has_bssid()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->bssid());
+    }
+
+    // optional uint32 ch = 3;
+    if (has_ch()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->ch());
+    }
+
+    // optional uint32 bw = 4;
+    if (has_bw()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->bw());
+    }
+
+    // optional int32 rssi = 5;
+    if (has_rssi()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->rssi());
+    }
+
+    // optional uint32 sec = 6;
+    if (has_sec()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->sec());
+    }
+
+    // optional bool wps = 7;
+    if (has_wps()) {
+      total_size += 1 + 1;
+    }
+
+    // optional bool ess = 8;
+    if (has_ess()) {
+      total_size += 1 + 1;
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaScanResult::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaScanResult)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaScanResult* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaScanResult>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaScanResult)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaScanResult)
+    MergeFrom(*source);
+  }
+}
+
+void StaScanResult::MergeFrom(const StaScanResult& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaScanResult)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 255u) {
+    if (cached_has_bits & 0x00000001u) {
+      set_has_ssid();
+      ssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ssid_);
+    }
+    if (cached_has_bits & 0x00000002u) {
+      set_has_bssid();
+      bssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bssid_);
+    }
+    if (cached_has_bits & 0x00000004u) {
+      ch_ = from.ch_;
+    }
+    if (cached_has_bits & 0x00000008u) {
+      bw_ = from.bw_;
+    }
+    if (cached_has_bits & 0x00000010u) {
+      rssi_ = from.rssi_;
+    }
+    if (cached_has_bits & 0x00000020u) {
+      sec_ = from.sec_;
+    }
+    if (cached_has_bits & 0x00000040u) {
+      wps_ = from.wps_;
+    }
+    if (cached_has_bits & 0x00000080u) {
+      ess_ = from.ess_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaScanResult::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaScanResult)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaScanResult::CopyFrom(const StaScanResult& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaScanResult)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaScanResult::IsInitialized() const {
+  return true;
+}
+
+void StaScanResult::Swap(StaScanResult* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaScanResult::InternalSwap(StaScanResult* other) {
+  ssid_.Swap(&other->ssid_);
+  bssid_.Swap(&other->bssid_);
+  std::swap(ch_, other->ch_);
+  std::swap(bw_, other->bw_);
+  std::swap(rssi_, other->rssi_);
+  std::swap(sec_, other->sec_);
+  std::swap(wps_, other->wps_);
+  std::swap(ess_, other->ess_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaScanResult::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaScanResult
+
+// optional bytes ssid = 1;
+bool StaScanResult::has_ssid() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaScanResult::set_has_ssid() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaScanResult::clear_has_ssid() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaScanResult::clear_ssid() {
+  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ssid();
+}
+const ::std::string& StaScanResult::ssid() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.ssid)
+  return ssid_.GetNoArena();
+}
+void StaScanResult::set_ssid(const ::std::string& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaScanResult.ssid)
+}
+#if LANG_CXX11
+void StaScanResult::set_ssid(::std::string&& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaScanResult.ssid)
+}
+#endif
+void StaScanResult::set_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaScanResult.ssid)
+}
+void StaScanResult::set_ssid(const void* value, size_t size) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaScanResult.ssid)
+}
+::std::string* StaScanResult::mutable_ssid() {
+  set_has_ssid();
+  // @@protoc_insertion_point(field_mutable:StaScanResult.ssid)
+  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaScanResult::release_ssid() {
+  // @@protoc_insertion_point(field_release:StaScanResult.ssid)
+  clear_has_ssid();
+  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaScanResult::set_allocated_ssid(::std::string* ssid) {
+  if (ssid != NULL) {
+    set_has_ssid();
+  } else {
+    clear_has_ssid();
+  }
+  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
+  // @@protoc_insertion_point(field_set_allocated:StaScanResult.ssid)
+}
+
+// optional bytes bssid = 2;
+bool StaScanResult::has_bssid() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaScanResult::set_has_bssid() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaScanResult::clear_has_bssid() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaScanResult::clear_bssid() {
+  bssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_bssid();
+}
+const ::std::string& StaScanResult::bssid() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.bssid)
+  return bssid_.GetNoArena();
+}
+void StaScanResult::set_bssid(const ::std::string& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaScanResult.bssid)
+}
+#if LANG_CXX11
+void StaScanResult::set_bssid(::std::string&& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaScanResult.bssid)
+}
+#endif
+void StaScanResult::set_bssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaScanResult.bssid)
+}
+void StaScanResult::set_bssid(const void* value, size_t size) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaScanResult.bssid)
+}
+::std::string* StaScanResult::mutable_bssid() {
+  set_has_bssid();
+  // @@protoc_insertion_point(field_mutable:StaScanResult.bssid)
+  return bssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaScanResult::release_bssid() {
+  // @@protoc_insertion_point(field_release:StaScanResult.bssid)
+  clear_has_bssid();
+  return bssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaScanResult::set_allocated_bssid(::std::string* bssid) {
+  if (bssid != NULL) {
+    set_has_bssid();
+  } else {
+    clear_has_bssid();
+  }
+  bssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bssid);
+  // @@protoc_insertion_point(field_set_allocated:StaScanResult.bssid)
+}
+
+// optional uint32 ch = 3;
+bool StaScanResult::has_ch() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void StaScanResult::set_has_ch() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void StaScanResult::clear_has_ch() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void StaScanResult::clear_ch() {
+  ch_ = 0u;
+  clear_has_ch();
+}
+::google::protobuf::uint32 StaScanResult::ch() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.ch)
+  return ch_;
+}
+void StaScanResult::set_ch(::google::protobuf::uint32 value) {
+  set_has_ch();
+  ch_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.ch)
+}
+
+// optional uint32 bw = 4;
+bool StaScanResult::has_bw() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void StaScanResult::set_has_bw() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void StaScanResult::clear_has_bw() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void StaScanResult::clear_bw() {
+  bw_ = 0u;
+  clear_has_bw();
+}
+::google::protobuf::uint32 StaScanResult::bw() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.bw)
+  return bw_;
+}
+void StaScanResult::set_bw(::google::protobuf::uint32 value) {
+  set_has_bw();
+  bw_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.bw)
+}
+
+// optional int32 rssi = 5;
+bool StaScanResult::has_rssi() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void StaScanResult::set_has_rssi() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void StaScanResult::clear_has_rssi() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void StaScanResult::clear_rssi() {
+  rssi_ = 0;
+  clear_has_rssi();
+}
+::google::protobuf::int32 StaScanResult::rssi() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.rssi)
+  return rssi_;
+}
+void StaScanResult::set_rssi(::google::protobuf::int32 value) {
+  set_has_rssi();
+  rssi_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.rssi)
+}
+
+// optional uint32 sec = 6;
+bool StaScanResult::has_sec() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+void StaScanResult::set_has_sec() {
+  _has_bits_[0] |= 0x00000020u;
+}
+void StaScanResult::clear_has_sec() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+void StaScanResult::clear_sec() {
+  sec_ = 0u;
+  clear_has_sec();
+}
+::google::protobuf::uint32 StaScanResult::sec() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.sec)
+  return sec_;
+}
+void StaScanResult::set_sec(::google::protobuf::uint32 value) {
+  set_has_sec();
+  sec_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.sec)
+}
+
+// optional bool wps = 7;
+bool StaScanResult::has_wps() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+void StaScanResult::set_has_wps() {
+  _has_bits_[0] |= 0x00000040u;
+}
+void StaScanResult::clear_has_wps() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+void StaScanResult::clear_wps() {
+  wps_ = false;
+  clear_has_wps();
+}
+bool StaScanResult::wps() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.wps)
+  return wps_;
+}
+void StaScanResult::set_wps(bool value) {
+  set_has_wps();
+  wps_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.wps)
+}
+
+// optional bool ess = 8;
+bool StaScanResult::has_ess() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+void StaScanResult::set_has_ess() {
+  _has_bits_[0] |= 0x00000080u;
+}
+void StaScanResult::clear_has_ess() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+void StaScanResult::clear_ess() {
+  ess_ = false;
+  clear_has_ess();
+}
+bool StaScanResult::ess() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.ess)
+  return ess_;
+}
+void StaScanResult::set_ess(bool value) {
+  set_has_ess();
+  ess_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.ess)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaScanResults::kScanIdFieldNumber;
+const int StaScanResults::kSuccessFieldNumber;
+const int StaScanResults::kParamsFieldNumber;
+const int StaScanResults::kCountFieldNumber;
+const int StaScanResults::kResFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaScanResults::StaScanResults()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaScanResults)
+}
+StaScanResults::StaScanResults(const StaScanResults& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0),
+      res_(from.res_) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from.has_params()) {
+    params_ = new ::StaReqScan(*from.params_);
+  } else {
+    params_ = NULL;
+  }
+  ::memcpy(&scan_id_, &from.scan_id_,
+    reinterpret_cast<char*>(&count_) -
+    reinterpret_cast<char*>(&scan_id_) + sizeof(count_));
+  // @@protoc_insertion_point(copy_constructor:StaScanResults)
+}
+
+void StaScanResults::SharedCtor() {
+  _cached_size_ = 0;
+  ::memset(&params_, 0, reinterpret_cast<char*>(&count_) -
+    reinterpret_cast<char*>(&params_) + sizeof(count_));
+}
+
+StaScanResults::~StaScanResults() {
+  // @@protoc_insertion_point(destructor:StaScanResults)
+  SharedDtor();
+}
+
+void StaScanResults::SharedDtor() {
+  if (this != internal_default_instance()) {
+    delete params_;
+  }
+}
+
+void StaScanResults::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaScanResults::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaScanResults& StaScanResults::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaScanResults* StaScanResults::New(::google::protobuf::Arena* arena) const {
+  StaScanResults* n = new StaScanResults;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaScanResults::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaScanResults)
+  res_.Clear();
+  if (has_params()) {
+    GOOGLE_DCHECK(params_ != NULL);
+    params_->::StaReqScan::Clear();
+  }
+  if (_has_bits_[0 / 32] & 14u) {
+    ::memset(&scan_id_, 0, reinterpret_cast<char*>(&count_) -
+      reinterpret_cast<char*>(&scan_id_) + sizeof(count_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaScanResults::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaScanResults)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional int32 scan_id = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          set_has_scan_id();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &scan_id_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bool success = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(16u)) {
+          set_has_success();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, &success_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaReqScan params = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(26u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_params()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional int32 count = 4;
+      case 4: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(32u)) {
+          set_has_count();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &count_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // repeated .StaScanResult res = 5;
+      case 5: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(42u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+                input, add_res()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaScanResults)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaScanResults)
+  return false;
+#undef DO_
+}
+
+void StaScanResults::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaScanResults)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional int32 scan_id = 1;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->scan_id(), output);
+  }
+
+  // optional bool success = 2;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->success(), output);
+  }
+
+  // optional .StaReqScan params = 3;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      3, *this->params_, output);
+  }
+
+  // optional int32 count = 4;
+  if (cached_has_bits & 0x00000008u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->count(), output);
+  }
+
+  // repeated .StaScanResult res = 5;
+  for (unsigned int i = 0, n = this->res_size(); i < n; i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      5, this->res(i), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaScanResults)
+}
+
+::google::protobuf::uint8* StaScanResults::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaScanResults)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional int32 scan_id = 1;
+  if (cached_has_bits & 0x00000002u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->scan_id(), target);
+  }
+
+  // optional bool success = 2;
+  if (cached_has_bits & 0x00000004u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->success(), target);
+  }
+
+  // optional .StaReqScan params = 3;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        3, *this->params_, deterministic, target);
+  }
+
+  // optional int32 count = 4;
+  if (cached_has_bits & 0x00000008u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->count(), target);
+  }
+
+  // repeated .StaScanResult res = 5;
+  for (unsigned int i = 0, n = this->res_size(); i < n; i++) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        5, this->res(i), deterministic, target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaScanResults)
+  return target;
+}
+
+size_t StaScanResults::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaScanResults)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // repeated .StaScanResult res = 5;
+  {
+    unsigned int count = this->res_size();
+    total_size += 1UL * count;
+    for (unsigned int i = 0; i < count; i++) {
+      total_size +=
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->res(i));
+    }
+  }
+
+  if (_has_bits_[0 / 32] & 15u) {
+    // optional .StaReqScan params = 3;
+    if (has_params()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->params_);
+    }
+
+    // optional int32 scan_id = 1;
+    if (has_scan_id()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->scan_id());
+    }
+
+    // optional bool success = 2;
+    if (has_success()) {
+      total_size += 1 + 1;
+    }
+
+    // optional int32 count = 4;
+    if (has_count()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->count());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaScanResults::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaScanResults)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaScanResults* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaScanResults>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaScanResults)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaScanResults)
+    MergeFrom(*source);
+  }
+}
+
+void StaScanResults::MergeFrom(const StaScanResults& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaScanResults)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  res_.MergeFrom(from.res_);
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 15u) {
+    if (cached_has_bits & 0x00000001u) {
+      mutable_params()->::StaReqScan::MergeFrom(from.params());
+    }
+    if (cached_has_bits & 0x00000002u) {
+      scan_id_ = from.scan_id_;
+    }
+    if (cached_has_bits & 0x00000004u) {
+      success_ = from.success_;
+    }
+    if (cached_has_bits & 0x00000008u) {
+      count_ = from.count_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaScanResults::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaScanResults)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaScanResults::CopyFrom(const StaScanResults& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaScanResults)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaScanResults::IsInitialized() const {
+  return true;
+}
+
+void StaScanResults::Swap(StaScanResults* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaScanResults::InternalSwap(StaScanResults* other) {
+  res_.InternalSwap(&other->res_);
+  std::swap(params_, other->params_);
+  std::swap(scan_id_, other->scan_id_);
+  std::swap(success_, other->success_);
+  std::swap(count_, other->count_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaScanResults::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaScanResults
+
+// optional int32 scan_id = 1;
+bool StaScanResults::has_scan_id() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaScanResults::set_has_scan_id() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaScanResults::clear_has_scan_id() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaScanResults::clear_scan_id() {
+  scan_id_ = 0;
+  clear_has_scan_id();
+}
+::google::protobuf::int32 StaScanResults::scan_id() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.scan_id)
+  return scan_id_;
+}
+void StaScanResults::set_scan_id(::google::protobuf::int32 value) {
+  set_has_scan_id();
+  scan_id_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResults.scan_id)
+}
+
+// optional bool success = 2;
+bool StaScanResults::has_success() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void StaScanResults::set_has_success() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void StaScanResults::clear_has_success() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void StaScanResults::clear_success() {
+  success_ = false;
+  clear_has_success();
+}
+bool StaScanResults::success() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.success)
+  return success_;
+}
+void StaScanResults::set_success(bool value) {
+  set_has_success();
+  success_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResults.success)
+}
+
+// optional .StaReqScan params = 3;
+bool StaScanResults::has_params() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaScanResults::set_has_params() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaScanResults::clear_has_params() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaScanResults::clear_params() {
+  if (params_ != NULL) params_->::StaReqScan::Clear();
+  clear_has_params();
+}
+const ::StaReqScan& StaScanResults::params() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.params)
+  return params_ != NULL ? *params_
+                         : *::StaReqScan::internal_default_instance();
+}
+::StaReqScan* StaScanResults::mutable_params() {
+  set_has_params();
+  if (params_ == NULL) {
+    params_ = new ::StaReqScan;
+  }
+  // @@protoc_insertion_point(field_mutable:StaScanResults.params)
+  return params_;
+}
+::StaReqScan* StaScanResults::release_params() {
+  // @@protoc_insertion_point(field_release:StaScanResults.params)
+  clear_has_params();
+  ::StaReqScan* temp = params_;
+  params_ = NULL;
+  return temp;
+}
+void StaScanResults::set_allocated_params(::StaReqScan* params) {
+  delete params_;
+  params_ = params;
+  if (params) {
+    set_has_params();
+  } else {
+    clear_has_params();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaScanResults.params)
+}
+
+// optional int32 count = 4;
+bool StaScanResults::has_count() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void StaScanResults::set_has_count() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void StaScanResults::clear_has_count() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void StaScanResults::clear_count() {
+  count_ = 0;
+  clear_has_count();
+}
+::google::protobuf::int32 StaScanResults::count() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.count)
+  return count_;
+}
+void StaScanResults::set_count(::google::protobuf::int32 value) {
+  set_has_count();
+  count_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResults.count)
+}
+
+// repeated .StaScanResult res = 5;
+int StaScanResults::res_size() const {
+  return res_.size();
+}
+void StaScanResults::clear_res() {
+  res_.Clear();
+}
+const ::StaScanResult& StaScanResults::res(int index) const {
+  // @@protoc_insertion_point(field_get:StaScanResults.res)
+  return res_.Get(index);
+}
+::StaScanResult* StaScanResults::mutable_res(int index) {
+  // @@protoc_insertion_point(field_mutable:StaScanResults.res)
+  return res_.Mutable(index);
+}
+::StaScanResult* StaScanResults::add_res() {
+  // @@protoc_insertion_point(field_add:StaScanResults.res)
+  return res_.Add();
+}
+::google::protobuf::RepeatedPtrField< ::StaScanResult >*
+StaScanResults::mutable_res() {
+  // @@protoc_insertion_point(field_mutable_list:StaScanResults.res)
+  return &res_;
+}
+const ::google::protobuf::RepeatedPtrField< ::StaScanResult >&
+StaScanResults::res() const {
+  // @@protoc_insertion_point(field_list:StaScanResults.res)
+  return res_;
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaWepSec::kKey0FieldNumber;
+const int StaWepSec::kKey1FieldNumber;
+const int StaWepSec::kKey2FieldNumber;
+const int StaWepSec::kKey3FieldNumber;
+const int StaWepSec::kDefaultKeyFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaWepSec::StaWepSec()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaWepSec)
+}
+StaWepSec::StaWepSec(const StaWepSec& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  key0_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_key0()) {
+    key0_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key0_);
+  }
+  key1_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_key1()) {
+    key1_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key1_);
+  }
+  key2_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_key2()) {
+    key2_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key2_);
+  }
+  key3_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_key3()) {
+    key3_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key3_);
+  }
+  defaultkey_ = from.defaultkey_;
+  // @@protoc_insertion_point(copy_constructor:StaWepSec)
+}
+
+void StaWepSec::SharedCtor() {
+  _cached_size_ = 0;
+  key0_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  key1_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  key2_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  key3_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  defaultkey_ = 0u;
+}
+
+StaWepSec::~StaWepSec() {
+  // @@protoc_insertion_point(destructor:StaWepSec)
+  SharedDtor();
+}
+
+void StaWepSec::SharedDtor() {
+  key0_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  key1_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  key2_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  key3_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void StaWepSec::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaWepSec::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaWepSec& StaWepSec::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaWepSec* StaWepSec::New(::google::protobuf::Arena* arena) const {
+  StaWepSec* n = new StaWepSec;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaWepSec::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaWepSec)
+  if (_has_bits_[0 / 32] & 15u) {
+    if (has_key0()) {
+      GOOGLE_DCHECK(!key0_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*key0_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_key1()) {
+      GOOGLE_DCHECK(!key1_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*key1_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_key2()) {
+      GOOGLE_DCHECK(!key2_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*key2_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_key3()) {
+      GOOGLE_DCHECK(!key3_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*key3_.UnsafeRawStringPointer())->clear();
+    }
+  }
+  defaultkey_ = 0u;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaWepSec::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaWepSec)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional bytes key0 = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_key0()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes key1 = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(18u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_key1()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes key2 = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(26u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_key2()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes key3 = 4;
+      case 4: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(34u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_key3()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 defaultKey = 5;
+      case 5: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(40u)) {
+          set_has_defaultkey();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &defaultkey_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaWepSec)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaWepSec)
+  return false;
+#undef DO_
+}
+
+void StaWepSec::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaWepSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes key0 = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      1, this->key0(), output);
+  }
+
+  // optional bytes key1 = 2;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      2, this->key1(), output);
+  }
+
+  // optional bytes key2 = 3;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      3, this->key2(), output);
+  }
+
+  // optional bytes key3 = 4;
+  if (cached_has_bits & 0x00000008u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      4, this->key3(), output);
+  }
+
+  // optional uint32 defaultKey = 5;
+  if (cached_has_bits & 0x00000010u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->defaultkey(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaWepSec)
+}
+
+::google::protobuf::uint8* StaWepSec::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaWepSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes key0 = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        1, this->key0(), target);
+  }
+
+  // optional bytes key1 = 2;
+  if (cached_has_bits & 0x00000002u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        2, this->key1(), target);
+  }
+
+  // optional bytes key2 = 3;
+  if (cached_has_bits & 0x00000004u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        3, this->key2(), target);
+  }
+
+  // optional bytes key3 = 4;
+  if (cached_has_bits & 0x00000008u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        4, this->key3(), target);
+  }
+
+  // optional uint32 defaultKey = 5;
+  if (cached_has_bits & 0x00000010u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->defaultkey(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaWepSec)
+  return target;
+}
+
+size_t StaWepSec::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaWepSec)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 31u) {
+    // optional bytes key0 = 1;
+    if (has_key0()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->key0());
+    }
+
+    // optional bytes key1 = 2;
+    if (has_key1()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->key1());
+    }
+
+    // optional bytes key2 = 3;
+    if (has_key2()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->key2());
+    }
+
+    // optional bytes key3 = 4;
+    if (has_key3()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->key3());
+    }
+
+    // optional uint32 defaultKey = 5;
+    if (has_defaultkey()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->defaultkey());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaWepSec::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaWepSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaWepSec* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaWepSec>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaWepSec)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaWepSec)
+    MergeFrom(*source);
+  }
+}
+
+void StaWepSec::MergeFrom(const StaWepSec& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaWepSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 31u) {
+    if (cached_has_bits & 0x00000001u) {
+      set_has_key0();
+      key0_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key0_);
+    }
+    if (cached_has_bits & 0x00000002u) {
+      set_has_key1();
+      key1_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key1_);
+    }
+    if (cached_has_bits & 0x00000004u) {
+      set_has_key2();
+      key2_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key2_);
+    }
+    if (cached_has_bits & 0x00000008u) {
+      set_has_key3();
+      key3_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key3_);
+    }
+    if (cached_has_bits & 0x00000010u) {
+      defaultkey_ = from.defaultkey_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaWepSec::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaWepSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaWepSec::CopyFrom(const StaWepSec& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaWepSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaWepSec::IsInitialized() const {
+  return true;
+}
+
+void StaWepSec::Swap(StaWepSec* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaWepSec::InternalSwap(StaWepSec* other) {
+  key0_.Swap(&other->key0_);
+  key1_.Swap(&other->key1_);
+  key2_.Swap(&other->key2_);
+  key3_.Swap(&other->key3_);
+  std::swap(defaultkey_, other->defaultkey_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaWepSec::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaWepSec
+
+// optional bytes key0 = 1;
+bool StaWepSec::has_key0() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaWepSec::set_has_key0() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaWepSec::clear_has_key0() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaWepSec::clear_key0() {
+  key0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key0();
+}
+const ::std::string& StaWepSec::key0() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key0)
+  return key0_.GetNoArena();
+}
+void StaWepSec::set_key0(const ::std::string& value) {
+  set_has_key0();
+  key0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key0)
+}
+#if LANG_CXX11
+void StaWepSec::set_key0(::std::string&& value) {
+  set_has_key0();
+  key0_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key0)
+}
+#endif
+void StaWepSec::set_key0(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key0();
+  key0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key0)
+}
+void StaWepSec::set_key0(const void* value, size_t size) {
+  set_has_key0();
+  key0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key0)
+}
+::std::string* StaWepSec::mutable_key0() {
+  set_has_key0();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key0)
+  return key0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaWepSec::release_key0() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key0)
+  clear_has_key0();
+  return key0_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaWepSec::set_allocated_key0(::std::string* key0) {
+  if (key0 != NULL) {
+    set_has_key0();
+  } else {
+    clear_has_key0();
+  }
+  key0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key0);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key0)
+}
+
+// optional bytes key1 = 2;
+bool StaWepSec::has_key1() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaWepSec::set_has_key1() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaWepSec::clear_has_key1() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaWepSec::clear_key1() {
+  key1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key1();
+}
+const ::std::string& StaWepSec::key1() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key1)
+  return key1_.GetNoArena();
+}
+void StaWepSec::set_key1(const ::std::string& value) {
+  set_has_key1();
+  key1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key1)
+}
+#if LANG_CXX11
+void StaWepSec::set_key1(::std::string&& value) {
+  set_has_key1();
+  key1_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key1)
+}
+#endif
+void StaWepSec::set_key1(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key1();
+  key1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key1)
+}
+void StaWepSec::set_key1(const void* value, size_t size) {
+  set_has_key1();
+  key1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key1)
+}
+::std::string* StaWepSec::mutable_key1() {
+  set_has_key1();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key1)
+  return key1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaWepSec::release_key1() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key1)
+  clear_has_key1();
+  return key1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaWepSec::set_allocated_key1(::std::string* key1) {
+  if (key1 != NULL) {
+    set_has_key1();
+  } else {
+    clear_has_key1();
+  }
+  key1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key1);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key1)
+}
+
+// optional bytes key2 = 3;
+bool StaWepSec::has_key2() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void StaWepSec::set_has_key2() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void StaWepSec::clear_has_key2() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void StaWepSec::clear_key2() {
+  key2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key2();
+}
+const ::std::string& StaWepSec::key2() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key2)
+  return key2_.GetNoArena();
+}
+void StaWepSec::set_key2(const ::std::string& value) {
+  set_has_key2();
+  key2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key2)
+}
+#if LANG_CXX11
+void StaWepSec::set_key2(::std::string&& value) {
+  set_has_key2();
+  key2_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key2)
+}
+#endif
+void StaWepSec::set_key2(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key2();
+  key2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key2)
+}
+void StaWepSec::set_key2(const void* value, size_t size) {
+  set_has_key2();
+  key2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key2)
+}
+::std::string* StaWepSec::mutable_key2() {
+  set_has_key2();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key2)
+  return key2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaWepSec::release_key2() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key2)
+  clear_has_key2();
+  return key2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaWepSec::set_allocated_key2(::std::string* key2) {
+  if (key2 != NULL) {
+    set_has_key2();
+  } else {
+    clear_has_key2();
+  }
+  key2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key2);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key2)
+}
+
+// optional bytes key3 = 4;
+bool StaWepSec::has_key3() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void StaWepSec::set_has_key3() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void StaWepSec::clear_has_key3() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void StaWepSec::clear_key3() {
+  key3_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key3();
+}
+const ::std::string& StaWepSec::key3() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key3)
+  return key3_.GetNoArena();
+}
+void StaWepSec::set_key3(const ::std::string& value) {
+  set_has_key3();
+  key3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key3)
+}
+#if LANG_CXX11
+void StaWepSec::set_key3(::std::string&& value) {
+  set_has_key3();
+  key3_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key3)
+}
+#endif
+void StaWepSec::set_key3(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key3();
+  key3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key3)
+}
+void StaWepSec::set_key3(const void* value, size_t size) {
+  set_has_key3();
+  key3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key3)
+}
+::std::string* StaWepSec::mutable_key3() {
+  set_has_key3();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key3)
+  return key3_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaWepSec::release_key3() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key3)
+  clear_has_key3();
+  return key3_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaWepSec::set_allocated_key3(::std::string* key3) {
+  if (key3 != NULL) {
+    set_has_key3();
+  } else {
+    clear_has_key3();
+  }
+  key3_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key3);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key3)
+}
+
+// optional uint32 defaultKey = 5;
+bool StaWepSec::has_defaultkey() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void StaWepSec::set_has_defaultkey() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void StaWepSec::clear_has_defaultkey() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void StaWepSec::clear_defaultkey() {
+  defaultkey_ = 0u;
+  clear_has_defaultkey();
+}
+::google::protobuf::uint32 StaWepSec::defaultkey() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.defaultKey)
+  return defaultkey_;
+}
+void StaWepSec::set_defaultkey(::google::protobuf::uint32 value) {
+  set_has_defaultkey();
+  defaultkey_ = value;
+  // @@protoc_insertion_point(field_set:StaWepSec.defaultKey)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaWpsSec::kTypeFieldNumber;
+const int StaWpsSec::kPinFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaWpsSec::StaWpsSec()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaWpsSec)
+}
+StaWpsSec::StaWpsSec(const StaWpsSec& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_pin()) {
+    pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
+  }
+  type_ = from.type_;
+  // @@protoc_insertion_point(copy_constructor:StaWpsSec)
+}
+
+void StaWpsSec::SharedCtor() {
+  _cached_size_ = 0;
+  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  type_ = 0u;
+}
+
+StaWpsSec::~StaWpsSec() {
+  // @@protoc_insertion_point(destructor:StaWpsSec)
+  SharedDtor();
+}
+
+void StaWpsSec::SharedDtor() {
+  pin_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void StaWpsSec::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaWpsSec::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaWpsSec& StaWpsSec::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaWpsSec* StaWpsSec::New(::google::protobuf::Arena* arena) const {
+  StaWpsSec* n = new StaWpsSec;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaWpsSec::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaWpsSec)
+  if (has_pin()) {
+    GOOGLE_DCHECK(!pin_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+    (*pin_.UnsafeRawStringPointer())->clear();
+  }
+  type_ = 0u;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaWpsSec::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaWpsSec)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional uint32 type = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          set_has_type();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &type_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes pin = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(18u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_pin()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaWpsSec)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaWpsSec)
+  return false;
+#undef DO_
+}
+
+void StaWpsSec::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaWpsSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional uint32 type = 1;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
+  }
+
+  // optional bytes pin = 2;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      2, this->pin(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaWpsSec)
+}
+
+::google::protobuf::uint8* StaWpsSec::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaWpsSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional uint32 type = 1;
+  if (cached_has_bits & 0x00000002u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->type(), target);
+  }
+
+  // optional bytes pin = 2;
+  if (cached_has_bits & 0x00000001u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        2, this->pin(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaWpsSec)
+  return target;
+}
+
+size_t StaWpsSec::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaWpsSec)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 3u) {
+    // optional bytes pin = 2;
+    if (has_pin()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->pin());
+    }
+
+    // optional uint32 type = 1;
+    if (has_type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->type());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaWpsSec::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaWpsSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaWpsSec* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaWpsSec>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaWpsSec)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaWpsSec)
+    MergeFrom(*source);
+  }
+}
+
+void StaWpsSec::MergeFrom(const StaWpsSec& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaWpsSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 3u) {
+    if (cached_has_bits & 0x00000001u) {
+      set_has_pin();
+      pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
+    }
+    if (cached_has_bits & 0x00000002u) {
+      type_ = from.type_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaWpsSec::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaWpsSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaWpsSec::CopyFrom(const StaWpsSec& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaWpsSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaWpsSec::IsInitialized() const {
+  return true;
+}
+
+void StaWpsSec::Swap(StaWpsSec* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaWpsSec::InternalSwap(StaWpsSec* other) {
+  pin_.Swap(&other->pin_);
+  std::swap(type_, other->type_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaWpsSec::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaWpsSec
+
+// optional uint32 type = 1;
+bool StaWpsSec::has_type() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaWpsSec::set_has_type() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaWpsSec::clear_has_type() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaWpsSec::clear_type() {
+  type_ = 0u;
+  clear_has_type();
+}
+::google::protobuf::uint32 StaWpsSec::type() const {
+  // @@protoc_insertion_point(field_get:StaWpsSec.type)
+  return type_;
+}
+void StaWpsSec::set_type(::google::protobuf::uint32 value) {
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:StaWpsSec.type)
+}
+
+// optional bytes pin = 2;
+bool StaWpsSec::has_pin() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaWpsSec::set_has_pin() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaWpsSec::clear_has_pin() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaWpsSec::clear_pin() {
+  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_pin();
+}
+const ::std::string& StaWpsSec::pin() const {
+  // @@protoc_insertion_point(field_get:StaWpsSec.pin)
+  return pin_.GetNoArena();
+}
+void StaWpsSec::set_pin(const ::std::string& value) {
+  set_has_pin();
+  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWpsSec.pin)
+}
+#if LANG_CXX11
+void StaWpsSec::set_pin(::std::string&& value) {
+  set_has_pin();
+  pin_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWpsSec.pin)
+}
+#endif
+void StaWpsSec::set_pin(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_pin();
+  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWpsSec.pin)
+}
+void StaWpsSec::set_pin(const void* value, size_t size) {
+  set_has_pin();
+  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWpsSec.pin)
+}
+::std::string* StaWpsSec::mutable_pin() {
+  set_has_pin();
+  // @@protoc_insertion_point(field_mutable:StaWpsSec.pin)
+  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaWpsSec::release_pin() {
+  // @@protoc_insertion_point(field_release:StaWpsSec.pin)
+  clear_has_pin();
+  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaWpsSec::set_allocated_pin(::std::string* pin) {
+  if (pin != NULL) {
+    set_has_pin();
+  } else {
+    clear_has_pin();
+  }
+  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
+  // @@protoc_insertion_point(field_set_allocated:StaWpsSec.pin)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaPskSec::kPasswordFieldNumber;
+const int StaPskSec::kPairCipherFieldNumber;
+const int StaPskSec::kGroupCipherFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaPskSec::StaPskSec()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaPskSec)
+}
+StaPskSec::StaPskSec(const StaPskSec& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_password()) {
+    password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
+  }
+  ::memcpy(&paircipher_, &from.paircipher_,
+    reinterpret_cast<char*>(&groupcipher_) -
+    reinterpret_cast<char*>(&paircipher_) + sizeof(groupcipher_));
+  // @@protoc_insertion_point(copy_constructor:StaPskSec)
+}
+
+void StaPskSec::SharedCtor() {
+  _cached_size_ = 0;
+  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ::memset(&paircipher_, 0, reinterpret_cast<char*>(&groupcipher_) -
+    reinterpret_cast<char*>(&paircipher_) + sizeof(groupcipher_));
+}
+
+StaPskSec::~StaPskSec() {
+  // @@protoc_insertion_point(destructor:StaPskSec)
+  SharedDtor();
+}
+
+void StaPskSec::SharedDtor() {
+  password_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void StaPskSec::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaPskSec::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaPskSec& StaPskSec::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaPskSec* StaPskSec::New(::google::protobuf::Arena* arena) const {
+  StaPskSec* n = new StaPskSec;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaPskSec::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaPskSec)
+  if (has_password()) {
+    GOOGLE_DCHECK(!password_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+    (*password_.UnsafeRawStringPointer())->clear();
+  }
+  if (_has_bits_[0 / 32] & 6u) {
+    ::memset(&paircipher_, 0, reinterpret_cast<char*>(&groupcipher_) -
+      reinterpret_cast<char*>(&paircipher_) + sizeof(groupcipher_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaPskSec::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaPskSec)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional bytes password = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_password()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 pairCipher = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(16u)) {
+          set_has_paircipher();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &paircipher_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 groupCipher = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(24u)) {
+          set_has_groupcipher();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &groupcipher_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaPskSec)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaPskSec)
+  return false;
+#undef DO_
+}
+
+void StaPskSec::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaPskSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes password = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      1, this->password(), output);
+  }
+
+  // optional uint32 pairCipher = 2;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->paircipher(), output);
+  }
+
+  // optional uint32 groupCipher = 3;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->groupcipher(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaPskSec)
+}
+
+::google::protobuf::uint8* StaPskSec::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaPskSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes password = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        1, this->password(), target);
+  }
+
+  // optional uint32 pairCipher = 2;
+  if (cached_has_bits & 0x00000002u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->paircipher(), target);
+  }
+
+  // optional uint32 groupCipher = 3;
+  if (cached_has_bits & 0x00000004u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->groupcipher(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaPskSec)
+  return target;
+}
+
+size_t StaPskSec::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaPskSec)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 7u) {
+    // optional bytes password = 1;
+    if (has_password()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->password());
+    }
+
+    // optional uint32 pairCipher = 2;
+    if (has_paircipher()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->paircipher());
+    }
+
+    // optional uint32 groupCipher = 3;
+    if (has_groupcipher()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->groupcipher());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaPskSec::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaPskSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaPskSec* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaPskSec>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaPskSec)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaPskSec)
+    MergeFrom(*source);
+  }
+}
+
+void StaPskSec::MergeFrom(const StaPskSec& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaPskSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 7u) {
+    if (cached_has_bits & 0x00000001u) {
+      set_has_password();
+      password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
+    }
+    if (cached_has_bits & 0x00000002u) {
+      paircipher_ = from.paircipher_;
+    }
+    if (cached_has_bits & 0x00000004u) {
+      groupcipher_ = from.groupcipher_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaPskSec::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaPskSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaPskSec::CopyFrom(const StaPskSec& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaPskSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaPskSec::IsInitialized() const {
+  return true;
+}
+
+void StaPskSec::Swap(StaPskSec* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaPskSec::InternalSwap(StaPskSec* other) {
+  password_.Swap(&other->password_);
+  std::swap(paircipher_, other->paircipher_);
+  std::swap(groupcipher_, other->groupcipher_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaPskSec::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaPskSec
+
+// optional bytes password = 1;
+bool StaPskSec::has_password() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaPskSec::set_has_password() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaPskSec::clear_has_password() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaPskSec::clear_password() {
+  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_password();
+}
+const ::std::string& StaPskSec::password() const {
+  // @@protoc_insertion_point(field_get:StaPskSec.password)
+  return password_.GetNoArena();
+}
+void StaPskSec::set_password(const ::std::string& value) {
+  set_has_password();
+  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaPskSec.password)
+}
+#if LANG_CXX11
+void StaPskSec::set_password(::std::string&& value) {
+  set_has_password();
+  password_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaPskSec.password)
+}
+#endif
+void StaPskSec::set_password(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_password();
+  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaPskSec.password)
+}
+void StaPskSec::set_password(const void* value, size_t size) {
+  set_has_password();
+  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaPskSec.password)
+}
+::std::string* StaPskSec::mutable_password() {
+  set_has_password();
+  // @@protoc_insertion_point(field_mutable:StaPskSec.password)
+  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaPskSec::release_password() {
+  // @@protoc_insertion_point(field_release:StaPskSec.password)
+  clear_has_password();
+  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaPskSec::set_allocated_password(::std::string* password) {
+  if (password != NULL) {
+    set_has_password();
+  } else {
+    clear_has_password();
+  }
+  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
+  // @@protoc_insertion_point(field_set_allocated:StaPskSec.password)
+}
+
+// optional uint32 pairCipher = 2;
+bool StaPskSec::has_paircipher() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaPskSec::set_has_paircipher() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaPskSec::clear_has_paircipher() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaPskSec::clear_paircipher() {
+  paircipher_ = 0u;
+  clear_has_paircipher();
+}
+::google::protobuf::uint32 StaPskSec::paircipher() const {
+  // @@protoc_insertion_point(field_get:StaPskSec.pairCipher)
+  return paircipher_;
+}
+void StaPskSec::set_paircipher(::google::protobuf::uint32 value) {
+  set_has_paircipher();
+  paircipher_ = value;
+  // @@protoc_insertion_point(field_set:StaPskSec.pairCipher)
+}
+
+// optional uint32 groupCipher = 3;
+bool StaPskSec::has_groupcipher() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void StaPskSec::set_has_groupcipher() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void StaPskSec::clear_has_groupcipher() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void StaPskSec::clear_groupcipher() {
+  groupcipher_ = 0u;
+  clear_has_groupcipher();
+}
+::google::protobuf::uint32 StaPskSec::groupcipher() const {
+  // @@protoc_insertion_point(field_get:StaPskSec.groupCipher)
+  return groupcipher_;
+}
+void StaPskSec::set_groupcipher(::google::protobuf::uint32 value) {
+  set_has_groupcipher();
+  groupcipher_ = value;
+  // @@protoc_insertion_point(field_set:StaPskSec.groupCipher)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaEapSec::StaEapSec()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaEapSec)
+}
+StaEapSec::StaEapSec(const StaEapSec& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:StaEapSec)
+}
+
+void StaEapSec::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+StaEapSec::~StaEapSec() {
+  // @@protoc_insertion_point(destructor:StaEapSec)
+  SharedDtor();
+}
+
+void StaEapSec::SharedDtor() {
+}
+
+void StaEapSec::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaEapSec::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaEapSec& StaEapSec::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaEapSec* StaEapSec::New(::google::protobuf::Arena* arena) const {
+  StaEapSec* n = new StaEapSec;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaEapSec::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaEapSec)
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaEapSec::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaEapSec)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+  handle_unusual:
+    if (tag == 0 ||
+        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+      goto success;
+    }
+    DO_(::google::protobuf::internal::WireFormat::SkipField(
+          input, tag, mutable_unknown_fields()));
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaEapSec)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaEapSec)
+  return false;
+#undef DO_
+}
+
+void StaEapSec::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaEapSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaEapSec)
+}
+
+::google::protobuf::uint8* StaEapSec::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaEapSec)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaEapSec)
+  return target;
+}
+
+size_t StaEapSec::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaEapSec)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaEapSec::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaEapSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaEapSec* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaEapSec>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaEapSec)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaEapSec)
+    MergeFrom(*source);
+  }
+}
+
+void StaEapSec::MergeFrom(const StaEapSec& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaEapSec)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+}
+
+void StaEapSec::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaEapSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaEapSec::CopyFrom(const StaEapSec& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaEapSec)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaEapSec::IsInitialized() const {
+  return true;
+}
+
+void StaEapSec::Swap(StaEapSec* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaEapSec::InternalSwap(StaEapSec* other) {
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaEapSec::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaEapSec
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaStaticIpv4::StaStaticIpv4()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaStaticIpv4)
+}
+StaStaticIpv4::StaStaticIpv4(const StaStaticIpv4& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:StaStaticIpv4)
+}
+
+void StaStaticIpv4::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+StaStaticIpv4::~StaStaticIpv4() {
+  // @@protoc_insertion_point(destructor:StaStaticIpv4)
+  SharedDtor();
+}
+
+void StaStaticIpv4::SharedDtor() {
+}
+
+void StaStaticIpv4::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaStaticIpv4::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaStaticIpv4& StaStaticIpv4::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaStaticIpv4* StaStaticIpv4::New(::google::protobuf::Arena* arena) const {
+  StaStaticIpv4* n = new StaStaticIpv4;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaStaticIpv4::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaStaticIpv4)
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaStaticIpv4::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaStaticIpv4)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+  handle_unusual:
+    if (tag == 0 ||
+        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+      goto success;
+    }
+    DO_(::google::protobuf::internal::WireFormat::SkipField(
+          input, tag, mutable_unknown_fields()));
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaStaticIpv4)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaStaticIpv4)
+  return false;
+#undef DO_
+}
+
+void StaStaticIpv4::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaStaticIpv4)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaStaticIpv4)
+}
+
+::google::protobuf::uint8* StaStaticIpv4::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaStaticIpv4)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaStaticIpv4)
+  return target;
+}
+
+size_t StaStaticIpv4::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaStaticIpv4)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaStaticIpv4::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaStaticIpv4)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaStaticIpv4* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaStaticIpv4>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaStaticIpv4)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaStaticIpv4)
+    MergeFrom(*source);
+  }
+}
+
+void StaStaticIpv4::MergeFrom(const StaStaticIpv4& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaStaticIpv4)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+}
+
+void StaStaticIpv4::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaStaticIpv4)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaStaticIpv4::CopyFrom(const StaStaticIpv4& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaStaticIpv4)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaStaticIpv4::IsInitialized() const {
+  return true;
+}
+
+void StaStaticIpv4::Swap(StaStaticIpv4* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaStaticIpv4::InternalSwap(StaStaticIpv4* other) {
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaStaticIpv4::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaStaticIpv4
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaStaticIpv6::StaStaticIpv6()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaStaticIpv6)
+}
+StaStaticIpv6::StaStaticIpv6(const StaStaticIpv6& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:StaStaticIpv6)
+}
+
+void StaStaticIpv6::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+StaStaticIpv6::~StaStaticIpv6() {
+  // @@protoc_insertion_point(destructor:StaStaticIpv6)
+  SharedDtor();
+}
+
+void StaStaticIpv6::SharedDtor() {
+}
+
+void StaStaticIpv6::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaStaticIpv6::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaStaticIpv6& StaStaticIpv6::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaStaticIpv6* StaStaticIpv6::New(::google::protobuf::Arena* arena) const {
+  StaStaticIpv6* n = new StaStaticIpv6;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaStaticIpv6::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaStaticIpv6)
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaStaticIpv6::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaStaticIpv6)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+  handle_unusual:
+    if (tag == 0 ||
+        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+      goto success;
+    }
+    DO_(::google::protobuf::internal::WireFormat::SkipField(
+          input, tag, mutable_unknown_fields()));
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaStaticIpv6)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaStaticIpv6)
+  return false;
+#undef DO_
+}
+
+void StaStaticIpv6::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaStaticIpv6)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaStaticIpv6)
+}
+
+::google::protobuf::uint8* StaStaticIpv6::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaStaticIpv6)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaStaticIpv6)
+  return target;
+}
+
+size_t StaStaticIpv6::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaStaticIpv6)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaStaticIpv6::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaStaticIpv6)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaStaticIpv6* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaStaticIpv6>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaStaticIpv6)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaStaticIpv6)
+    MergeFrom(*source);
+  }
+}
+
+void StaStaticIpv6::MergeFrom(const StaStaticIpv6& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaStaticIpv6)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+}
+
+void StaStaticIpv6::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaStaticIpv6)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaStaticIpv6::CopyFrom(const StaStaticIpv6& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaStaticIpv6)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaStaticIpv6::IsInitialized() const {
+  return true;
+}
+
+void StaStaticIpv6::Swap(StaStaticIpv6* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaStaticIpv6::InternalSwap(StaStaticIpv6* other) {
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaStaticIpv6::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaStaticIpv6
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaReqConnect::kSsidFieldNumber;
+const int StaReqConnect::kBssidFieldNumber;
+const int StaReqConnect::kChannelFieldNumber;
+const int StaReqConnect::kSecTypeFieldNumber;
+const int StaReqConnect::kWepSecFieldNumber;
+const int StaReqConnect::kWpsSecFieldNumber;
+const int StaReqConnect::kPskSecFieldNumber;
+const int StaReqConnect::kEapSecFieldNumber;
+const int StaReqConnect::kIpv4TypeFieldNumber;
+const int StaReqConnect::kStaticIpv4FieldNumber;
+const int StaReqConnect::kIpv6TypeFieldNumber;
+const int StaReqConnect::kStaticIpv6FieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaReqConnect::StaReqConnect()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaReqConnect)
+}
+StaReqConnect::StaReqConnect(const StaReqConnect& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_ssid()) {
+    ssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ssid_);
+  }
+  bssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_bssid()) {
+    bssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bssid_);
+  }
+  if (from.has_wepsec()) {
+    wepsec_ = new ::StaWepSec(*from.wepsec_);
+  } else {
+    wepsec_ = NULL;
+  }
+  if (from.has_wpssec()) {
+    wpssec_ = new ::StaWpsSec(*from.wpssec_);
+  } else {
+    wpssec_ = NULL;
+  }
+  if (from.has_psksec()) {
+    psksec_ = new ::StaPskSec(*from.psksec_);
+  } else {
+    psksec_ = NULL;
+  }
+  if (from.has_eapsec()) {
+    eapsec_ = new ::StaEapSec(*from.eapsec_);
+  } else {
+    eapsec_ = NULL;
+  }
+  if (from.has_staticipv4()) {
+    staticipv4_ = new ::StaStaticIpv4(*from.staticipv4_);
+  } else {
+    staticipv4_ = NULL;
+  }
+  if (from.has_staticipv6()) {
+    staticipv6_ = new ::StaStaticIpv6(*from.staticipv6_);
+  } else {
+    staticipv6_ = NULL;
+  }
+  ::memcpy(&channel_, &from.channel_,
+    reinterpret_cast<char*>(&ipv6type_) -
+    reinterpret_cast<char*>(&channel_) + sizeof(ipv6type_));
+  // @@protoc_insertion_point(copy_constructor:StaReqConnect)
+}
+
+void StaReqConnect::SharedCtor() {
+  _cached_size_ = 0;
+  ssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  bssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ::memset(&wepsec_, 0, reinterpret_cast<char*>(&ipv6type_) -
+    reinterpret_cast<char*>(&wepsec_) + sizeof(ipv6type_));
+}
+
+StaReqConnect::~StaReqConnect() {
+  // @@protoc_insertion_point(destructor:StaReqConnect)
+  SharedDtor();
+}
+
+void StaReqConnect::SharedDtor() {
+  ssid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  bssid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (this != internal_default_instance()) {
+    delete wepsec_;
+  }
+  if (this != internal_default_instance()) {
+    delete wpssec_;
+  }
+  if (this != internal_default_instance()) {
+    delete psksec_;
+  }
+  if (this != internal_default_instance()) {
+    delete eapsec_;
+  }
+  if (this != internal_default_instance()) {
+    delete staticipv4_;
+  }
+  if (this != internal_default_instance()) {
+    delete staticipv6_;
+  }
+}
+
+void StaReqConnect::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaReqConnect::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaReqConnect& StaReqConnect::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaReqConnect* StaReqConnect::New(::google::protobuf::Arena* arena) const {
+  StaReqConnect* n = new StaReqConnect;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaReqConnect::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaReqConnect)
+  if (_has_bits_[0 / 32] & 255u) {
+    if (has_ssid()) {
+      GOOGLE_DCHECK(!ssid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*ssid_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_bssid()) {
+      GOOGLE_DCHECK(!bssid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*bssid_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_wepsec()) {
+      GOOGLE_DCHECK(wepsec_ != NULL);
+      wepsec_->::StaWepSec::Clear();
+    }
+    if (has_wpssec()) {
+      GOOGLE_DCHECK(wpssec_ != NULL);
+      wpssec_->::StaWpsSec::Clear();
+    }
+    if (has_psksec()) {
+      GOOGLE_DCHECK(psksec_ != NULL);
+      psksec_->::StaPskSec::Clear();
+    }
+    if (has_eapsec()) {
+      GOOGLE_DCHECK(eapsec_ != NULL);
+      eapsec_->::StaEapSec::Clear();
+    }
+    if (has_staticipv4()) {
+      GOOGLE_DCHECK(staticipv4_ != NULL);
+      staticipv4_->::StaStaticIpv4::Clear();
+    }
+    if (has_staticipv6()) {
+      GOOGLE_DCHECK(staticipv6_ != NULL);
+      staticipv6_->::StaStaticIpv6::Clear();
+    }
+  }
+  if (_has_bits_[8 / 32] & 3840u) {
+    ::memset(&channel_, 0, reinterpret_cast<char*>(&ipv6type_) -
+      reinterpret_cast<char*>(&channel_) + sizeof(ipv6type_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaReqConnect::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaReqConnect)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional bytes ssid = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_ssid()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes bssid = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(18u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_bssid()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 channel = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(24u)) {
+          set_has_channel();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &channel_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 secType = 4;
+      case 4: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(32u)) {
+          set_has_sectype();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &sectype_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaWepSec wepSec = 5;
+      case 5: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(42u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_wepsec()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaWpsSec wpsSec = 6;
+      case 6: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(50u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_wpssec()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaPskSec pskSec = 7;
+      case 7: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(58u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_psksec()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaEapSec eapSec = 8;
+      case 8: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(66u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_eapsec()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 ipv4Type = 9;
+      case 9: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(72u)) {
+          set_has_ipv4type();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &ipv4type_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaStaticIpv4 staticIpv4 = 10;
+      case 10: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(82u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_staticipv4()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 ipv6Type = 11;
+      case 11: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(88u)) {
+          set_has_ipv6type();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &ipv6type_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaStaticIpv6 staticIpv6 = 12;
+      case 12: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(98u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_staticipv6()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaReqConnect)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaReqConnect)
+  return false;
+#undef DO_
+}
+
+void StaReqConnect::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaReqConnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes ssid = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      1, this->ssid(), output);
+  }
+
+  // optional bytes bssid = 2;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      2, this->bssid(), output);
+  }
+
+  // optional uint32 channel = 3;
+  if (cached_has_bits & 0x00000100u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->channel(), output);
+  }
+
+  // optional uint32 secType = 4;
+  if (cached_has_bits & 0x00000200u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->sectype(), output);
+  }
+
+  // optional .StaWepSec wepSec = 5;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      5, *this->wepsec_, output);
+  }
+
+  // optional .StaWpsSec wpsSec = 6;
+  if (cached_has_bits & 0x00000008u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      6, *this->wpssec_, output);
+  }
+
+  // optional .StaPskSec pskSec = 7;
+  if (cached_has_bits & 0x00000010u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      7, *this->psksec_, output);
+  }
+
+  // optional .StaEapSec eapSec = 8;
+  if (cached_has_bits & 0x00000020u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      8, *this->eapsec_, output);
+  }
+
+  // optional uint32 ipv4Type = 9;
+  if (cached_has_bits & 0x00000400u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->ipv4type(), output);
+  }
+
+  // optional .StaStaticIpv4 staticIpv4 = 10;
+  if (cached_has_bits & 0x00000040u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      10, *this->staticipv4_, output);
+  }
+
+  // optional uint32 ipv6Type = 11;
+  if (cached_has_bits & 0x00000800u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->ipv6type(), output);
+  }
+
+  // optional .StaStaticIpv6 staticIpv6 = 12;
+  if (cached_has_bits & 0x00000080u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      12, *this->staticipv6_, output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaReqConnect)
+}
+
+::google::protobuf::uint8* StaReqConnect::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaReqConnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes ssid = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        1, this->ssid(), target);
+  }
+
+  // optional bytes bssid = 2;
+  if (cached_has_bits & 0x00000002u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        2, this->bssid(), target);
+  }
+
+  // optional uint32 channel = 3;
+  if (cached_has_bits & 0x00000100u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->channel(), target);
+  }
+
+  // optional uint32 secType = 4;
+  if (cached_has_bits & 0x00000200u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->sectype(), target);
+  }
+
+  // optional .StaWepSec wepSec = 5;
+  if (cached_has_bits & 0x00000004u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        5, *this->wepsec_, deterministic, target);
+  }
+
+  // optional .StaWpsSec wpsSec = 6;
+  if (cached_has_bits & 0x00000008u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        6, *this->wpssec_, deterministic, target);
+  }
+
+  // optional .StaPskSec pskSec = 7;
+  if (cached_has_bits & 0x00000010u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        7, *this->psksec_, deterministic, target);
+  }
+
+  // optional .StaEapSec eapSec = 8;
+  if (cached_has_bits & 0x00000020u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        8, *this->eapsec_, deterministic, target);
+  }
+
+  // optional uint32 ipv4Type = 9;
+  if (cached_has_bits & 0x00000400u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->ipv4type(), target);
+  }
+
+  // optional .StaStaticIpv4 staticIpv4 = 10;
+  if (cached_has_bits & 0x00000040u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        10, *this->staticipv4_, deterministic, target);
+  }
+
+  // optional uint32 ipv6Type = 11;
+  if (cached_has_bits & 0x00000800u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->ipv6type(), target);
+  }
+
+  // optional .StaStaticIpv6 staticIpv6 = 12;
+  if (cached_has_bits & 0x00000080u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        12, *this->staticipv6_, deterministic, target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaReqConnect)
+  return target;
+}
+
+size_t StaReqConnect::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaReqConnect)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 255u) {
+    // optional bytes ssid = 1;
+    if (has_ssid()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->ssid());
+    }
+
+    // optional bytes bssid = 2;
+    if (has_bssid()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->bssid());
+    }
+
+    // optional .StaWepSec wepSec = 5;
+    if (has_wepsec()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->wepsec_);
+    }
+
+    // optional .StaWpsSec wpsSec = 6;
+    if (has_wpssec()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->wpssec_);
+    }
+
+    // optional .StaPskSec pskSec = 7;
+    if (has_psksec()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->psksec_);
+    }
+
+    // optional .StaEapSec eapSec = 8;
+    if (has_eapsec()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->eapsec_);
+    }
+
+    // optional .StaStaticIpv4 staticIpv4 = 10;
+    if (has_staticipv4()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->staticipv4_);
+    }
+
+    // optional .StaStaticIpv6 staticIpv6 = 12;
+    if (has_staticipv6()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->staticipv6_);
+    }
+
+  }
+  if (_has_bits_[8 / 32] & 3840u) {
+    // optional uint32 channel = 3;
+    if (has_channel()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->channel());
+    }
+
+    // optional uint32 secType = 4;
+    if (has_sectype()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->sectype());
+    }
+
+    // optional uint32 ipv4Type = 9;
+    if (has_ipv4type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->ipv4type());
+    }
+
+    // optional uint32 ipv6Type = 11;
+    if (has_ipv6type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->ipv6type());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaReqConnect::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaReqConnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaReqConnect* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaReqConnect>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaReqConnect)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaReqConnect)
+    MergeFrom(*source);
+  }
+}
+
+void StaReqConnect::MergeFrom(const StaReqConnect& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaReqConnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 255u) {
+    if (cached_has_bits & 0x00000001u) {
+      set_has_ssid();
+      ssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ssid_);
+    }
+    if (cached_has_bits & 0x00000002u) {
+      set_has_bssid();
+      bssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bssid_);
+    }
+    if (cached_has_bits & 0x00000004u) {
+      mutable_wepsec()->::StaWepSec::MergeFrom(from.wepsec());
+    }
+    if (cached_has_bits & 0x00000008u) {
+      mutable_wpssec()->::StaWpsSec::MergeFrom(from.wpssec());
+    }
+    if (cached_has_bits & 0x00000010u) {
+      mutable_psksec()->::StaPskSec::MergeFrom(from.psksec());
+    }
+    if (cached_has_bits & 0x00000020u) {
+      mutable_eapsec()->::StaEapSec::MergeFrom(from.eapsec());
+    }
+    if (cached_has_bits & 0x00000040u) {
+      mutable_staticipv4()->::StaStaticIpv4::MergeFrom(from.staticipv4());
+    }
+    if (cached_has_bits & 0x00000080u) {
+      mutable_staticipv6()->::StaStaticIpv6::MergeFrom(from.staticipv6());
+    }
+  }
+  if (cached_has_bits & 3840u) {
+    if (cached_has_bits & 0x00000100u) {
+      channel_ = from.channel_;
+    }
+    if (cached_has_bits & 0x00000200u) {
+      sectype_ = from.sectype_;
+    }
+    if (cached_has_bits & 0x00000400u) {
+      ipv4type_ = from.ipv4type_;
+    }
+    if (cached_has_bits & 0x00000800u) {
+      ipv6type_ = from.ipv6type_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaReqConnect::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaReqConnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaReqConnect::CopyFrom(const StaReqConnect& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaReqConnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaReqConnect::IsInitialized() const {
+  return true;
+}
+
+void StaReqConnect::Swap(StaReqConnect* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaReqConnect::InternalSwap(StaReqConnect* other) {
+  ssid_.Swap(&other->ssid_);
+  bssid_.Swap(&other->bssid_);
+  std::swap(wepsec_, other->wepsec_);
+  std::swap(wpssec_, other->wpssec_);
+  std::swap(psksec_, other->psksec_);
+  std::swap(eapsec_, other->eapsec_);
+  std::swap(staticipv4_, other->staticipv4_);
+  std::swap(staticipv6_, other->staticipv6_);
+  std::swap(channel_, other->channel_);
+  std::swap(sectype_, other->sectype_);
+  std::swap(ipv4type_, other->ipv4type_);
+  std::swap(ipv6type_, other->ipv6type_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaReqConnect::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaReqConnect
+
+// optional bytes ssid = 1;
+bool StaReqConnect::has_ssid() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaReqConnect::set_has_ssid() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaReqConnect::clear_has_ssid() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaReqConnect::clear_ssid() {
+  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ssid();
+}
+const ::std::string& StaReqConnect::ssid() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.ssid)
+  return ssid_.GetNoArena();
+}
+void StaReqConnect::set_ssid(const ::std::string& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaReqConnect.ssid)
+}
+#if LANG_CXX11
+void StaReqConnect::set_ssid(::std::string&& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaReqConnect.ssid)
+}
+#endif
+void StaReqConnect::set_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaReqConnect.ssid)
+}
+void StaReqConnect::set_ssid(const void* value, size_t size) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaReqConnect.ssid)
+}
+::std::string* StaReqConnect::mutable_ssid() {
+  set_has_ssid();
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.ssid)
+  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaReqConnect::release_ssid() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.ssid)
+  clear_has_ssid();
+  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaReqConnect::set_allocated_ssid(::std::string* ssid) {
+  if (ssid != NULL) {
+    set_has_ssid();
+  } else {
+    clear_has_ssid();
+  }
+  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.ssid)
+}
+
+// optional bytes bssid = 2;
+bool StaReqConnect::has_bssid() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaReqConnect::set_has_bssid() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaReqConnect::clear_has_bssid() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaReqConnect::clear_bssid() {
+  bssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_bssid();
+}
+const ::std::string& StaReqConnect::bssid() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.bssid)
+  return bssid_.GetNoArena();
+}
+void StaReqConnect::set_bssid(const ::std::string& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaReqConnect.bssid)
+}
+#if LANG_CXX11
+void StaReqConnect::set_bssid(::std::string&& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaReqConnect.bssid)
+}
+#endif
+void StaReqConnect::set_bssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaReqConnect.bssid)
+}
+void StaReqConnect::set_bssid(const void* value, size_t size) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaReqConnect.bssid)
+}
+::std::string* StaReqConnect::mutable_bssid() {
+  set_has_bssid();
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.bssid)
+  return bssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaReqConnect::release_bssid() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.bssid)
+  clear_has_bssid();
+  return bssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaReqConnect::set_allocated_bssid(::std::string* bssid) {
+  if (bssid != NULL) {
+    set_has_bssid();
+  } else {
+    clear_has_bssid();
+  }
+  bssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bssid);
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.bssid)
+}
+
+// optional uint32 channel = 3;
+bool StaReqConnect::has_channel() const {
+  return (_has_bits_[0] & 0x00000100u) != 0;
+}
+void StaReqConnect::set_has_channel() {
+  _has_bits_[0] |= 0x00000100u;
+}
+void StaReqConnect::clear_has_channel() {
+  _has_bits_[0] &= ~0x00000100u;
+}
+void StaReqConnect::clear_channel() {
+  channel_ = 0u;
+  clear_has_channel();
+}
+::google::protobuf::uint32 StaReqConnect::channel() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.channel)
+  return channel_;
+}
+void StaReqConnect::set_channel(::google::protobuf::uint32 value) {
+  set_has_channel();
+  channel_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.channel)
+}
+
+// optional uint32 secType = 4;
+bool StaReqConnect::has_sectype() const {
+  return (_has_bits_[0] & 0x00000200u) != 0;
+}
+void StaReqConnect::set_has_sectype() {
+  _has_bits_[0] |= 0x00000200u;
+}
+void StaReqConnect::clear_has_sectype() {
+  _has_bits_[0] &= ~0x00000200u;
+}
+void StaReqConnect::clear_sectype() {
+  sectype_ = 0u;
+  clear_has_sectype();
+}
+::google::protobuf::uint32 StaReqConnect::sectype() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.secType)
+  return sectype_;
+}
+void StaReqConnect::set_sectype(::google::protobuf::uint32 value) {
+  set_has_sectype();
+  sectype_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.secType)
+}
+
+// optional .StaWepSec wepSec = 5;
+bool StaReqConnect::has_wepsec() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void StaReqConnect::set_has_wepsec() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void StaReqConnect::clear_has_wepsec() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void StaReqConnect::clear_wepsec() {
+  if (wepsec_ != NULL) wepsec_->::StaWepSec::Clear();
+  clear_has_wepsec();
+}
+const ::StaWepSec& StaReqConnect::wepsec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.wepSec)
+  return wepsec_ != NULL ? *wepsec_
+                         : *::StaWepSec::internal_default_instance();
+}
+::StaWepSec* StaReqConnect::mutable_wepsec() {
+  set_has_wepsec();
+  if (wepsec_ == NULL) {
+    wepsec_ = new ::StaWepSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.wepSec)
+  return wepsec_;
+}
+::StaWepSec* StaReqConnect::release_wepsec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.wepSec)
+  clear_has_wepsec();
+  ::StaWepSec* temp = wepsec_;
+  wepsec_ = NULL;
+  return temp;
+}
+void StaReqConnect::set_allocated_wepsec(::StaWepSec* wepsec) {
+  delete wepsec_;
+  wepsec_ = wepsec;
+  if (wepsec) {
+    set_has_wepsec();
+  } else {
+    clear_has_wepsec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.wepSec)
+}
+
+// optional .StaWpsSec wpsSec = 6;
+bool StaReqConnect::has_wpssec() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void StaReqConnect::set_has_wpssec() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void StaReqConnect::clear_has_wpssec() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void StaReqConnect::clear_wpssec() {
+  if (wpssec_ != NULL) wpssec_->::StaWpsSec::Clear();
+  clear_has_wpssec();
+}
+const ::StaWpsSec& StaReqConnect::wpssec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.wpsSec)
+  return wpssec_ != NULL ? *wpssec_
+                         : *::StaWpsSec::internal_default_instance();
+}
+::StaWpsSec* StaReqConnect::mutable_wpssec() {
+  set_has_wpssec();
+  if (wpssec_ == NULL) {
+    wpssec_ = new ::StaWpsSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.wpsSec)
+  return wpssec_;
+}
+::StaWpsSec* StaReqConnect::release_wpssec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.wpsSec)
+  clear_has_wpssec();
+  ::StaWpsSec* temp = wpssec_;
+  wpssec_ = NULL;
+  return temp;
+}
+void StaReqConnect::set_allocated_wpssec(::StaWpsSec* wpssec) {
+  delete wpssec_;
+  wpssec_ = wpssec;
+  if (wpssec) {
+    set_has_wpssec();
+  } else {
+    clear_has_wpssec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.wpsSec)
+}
+
+// optional .StaPskSec pskSec = 7;
+bool StaReqConnect::has_psksec() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void StaReqConnect::set_has_psksec() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void StaReqConnect::clear_has_psksec() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void StaReqConnect::clear_psksec() {
+  if (psksec_ != NULL) psksec_->::StaPskSec::Clear();
+  clear_has_psksec();
+}
+const ::StaPskSec& StaReqConnect::psksec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.pskSec)
+  return psksec_ != NULL ? *psksec_
+                         : *::StaPskSec::internal_default_instance();
+}
+::StaPskSec* StaReqConnect::mutable_psksec() {
+  set_has_psksec();
+  if (psksec_ == NULL) {
+    psksec_ = new ::StaPskSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.pskSec)
+  return psksec_;
+}
+::StaPskSec* StaReqConnect::release_psksec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.pskSec)
+  clear_has_psksec();
+  ::StaPskSec* temp = psksec_;
+  psksec_ = NULL;
+  return temp;
+}
+void StaReqConnect::set_allocated_psksec(::StaPskSec* psksec) {
+  delete psksec_;
+  psksec_ = psksec;
+  if (psksec) {
+    set_has_psksec();
+  } else {
+    clear_has_psksec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.pskSec)
+}
+
+// optional .StaEapSec eapSec = 8;
+bool StaReqConnect::has_eapsec() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+void StaReqConnect::set_has_eapsec() {
+  _has_bits_[0] |= 0x00000020u;
+}
+void StaReqConnect::clear_has_eapsec() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+void StaReqConnect::clear_eapsec() {
+  if (eapsec_ != NULL) eapsec_->::StaEapSec::Clear();
+  clear_has_eapsec();
+}
+const ::StaEapSec& StaReqConnect::eapsec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.eapSec)
+  return eapsec_ != NULL ? *eapsec_
+                         : *::StaEapSec::internal_default_instance();
+}
+::StaEapSec* StaReqConnect::mutable_eapsec() {
+  set_has_eapsec();
+  if (eapsec_ == NULL) {
+    eapsec_ = new ::StaEapSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.eapSec)
+  return eapsec_;
+}
+::StaEapSec* StaReqConnect::release_eapsec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.eapSec)
+  clear_has_eapsec();
+  ::StaEapSec* temp = eapsec_;
+  eapsec_ = NULL;
+  return temp;
+}
+void StaReqConnect::set_allocated_eapsec(::StaEapSec* eapsec) {
+  delete eapsec_;
+  eapsec_ = eapsec;
+  if (eapsec) {
+    set_has_eapsec();
+  } else {
+    clear_has_eapsec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.eapSec)
+}
+
+// optional uint32 ipv4Type = 9;
+bool StaReqConnect::has_ipv4type() const {
+  return (_has_bits_[0] & 0x00000400u) != 0;
+}
+void StaReqConnect::set_has_ipv4type() {
+  _has_bits_[0] |= 0x00000400u;
+}
+void StaReqConnect::clear_has_ipv4type() {
+  _has_bits_[0] &= ~0x00000400u;
+}
+void StaReqConnect::clear_ipv4type() {
+  ipv4type_ = 0u;
+  clear_has_ipv4type();
+}
+::google::protobuf::uint32 StaReqConnect::ipv4type() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.ipv4Type)
+  return ipv4type_;
+}
+void StaReqConnect::set_ipv4type(::google::protobuf::uint32 value) {
+  set_has_ipv4type();
+  ipv4type_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.ipv4Type)
+}
+
+// optional .StaStaticIpv4 staticIpv4 = 10;
+bool StaReqConnect::has_staticipv4() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+void StaReqConnect::set_has_staticipv4() {
+  _has_bits_[0] |= 0x00000040u;
+}
+void StaReqConnect::clear_has_staticipv4() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+void StaReqConnect::clear_staticipv4() {
+  if (staticipv4_ != NULL) staticipv4_->::StaStaticIpv4::Clear();
+  clear_has_staticipv4();
+}
+const ::StaStaticIpv4& StaReqConnect::staticipv4() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.staticIpv4)
+  return staticipv4_ != NULL ? *staticipv4_
+                         : *::StaStaticIpv4::internal_default_instance();
+}
+::StaStaticIpv4* StaReqConnect::mutable_staticipv4() {
+  set_has_staticipv4();
+  if (staticipv4_ == NULL) {
+    staticipv4_ = new ::StaStaticIpv4;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.staticIpv4)
+  return staticipv4_;
+}
+::StaStaticIpv4* StaReqConnect::release_staticipv4() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.staticIpv4)
+  clear_has_staticipv4();
+  ::StaStaticIpv4* temp = staticipv4_;
+  staticipv4_ = NULL;
+  return temp;
+}
+void StaReqConnect::set_allocated_staticipv4(::StaStaticIpv4* staticipv4) {
+  delete staticipv4_;
+  staticipv4_ = staticipv4;
+  if (staticipv4) {
+    set_has_staticipv4();
+  } else {
+    clear_has_staticipv4();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.staticIpv4)
+}
+
+// optional uint32 ipv6Type = 11;
+bool StaReqConnect::has_ipv6type() const {
+  return (_has_bits_[0] & 0x00000800u) != 0;
+}
+void StaReqConnect::set_has_ipv6type() {
+  _has_bits_[0] |= 0x00000800u;
+}
+void StaReqConnect::clear_has_ipv6type() {
+  _has_bits_[0] &= ~0x00000800u;
+}
+void StaReqConnect::clear_ipv6type() {
+  ipv6type_ = 0u;
+  clear_has_ipv6type();
+}
+::google::protobuf::uint32 StaReqConnect::ipv6type() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.ipv6Type)
+  return ipv6type_;
+}
+void StaReqConnect::set_ipv6type(::google::protobuf::uint32 value) {
+  set_has_ipv6type();
+  ipv6type_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.ipv6Type)
+}
+
+// optional .StaStaticIpv6 staticIpv6 = 12;
+bool StaReqConnect::has_staticipv6() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+void StaReqConnect::set_has_staticipv6() {
+  _has_bits_[0] |= 0x00000080u;
+}
+void StaReqConnect::clear_has_staticipv6() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+void StaReqConnect::clear_staticipv6() {
+  if (staticipv6_ != NULL) staticipv6_->::StaStaticIpv6::Clear();
+  clear_has_staticipv6();
+}
+const ::StaStaticIpv6& StaReqConnect::staticipv6() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.staticIpv6)
+  return staticipv6_ != NULL ? *staticipv6_
+                         : *::StaStaticIpv6::internal_default_instance();
+}
+::StaStaticIpv6* StaReqConnect::mutable_staticipv6() {
+  set_has_staticipv6();
+  if (staticipv6_ == NULL) {
+    staticipv6_ = new ::StaStaticIpv6;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.staticIpv6)
+  return staticipv6_;
+}
+::StaStaticIpv6* StaReqConnect::release_staticipv6() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.staticIpv6)
+  clear_has_staticipv6();
+  ::StaStaticIpv6* temp = staticipv6_;
+  staticipv6_ = NULL;
+  return temp;
+}
+void StaReqConnect::set_allocated_staticipv6(::StaStaticIpv6* staticipv6) {
+  delete staticipv6_;
+  staticipv6_ = staticipv6;
+  if (staticipv6) {
+    set_has_staticipv6();
+  } else {
+    clear_has_staticipv6();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.staticIpv6)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaRspConnect::kRspFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaRspConnect::StaRspConnect()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaRspConnect)
+}
+StaRspConnect::StaRspConnect(const StaRspConnect& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  rsp_ = from.rsp_;
+  // @@protoc_insertion_point(copy_constructor:StaRspConnect)
+}
+
+void StaRspConnect::SharedCtor() {
+  _cached_size_ = 0;
+  rsp_ = 0;
+}
+
+StaRspConnect::~StaRspConnect() {
+  // @@protoc_insertion_point(destructor:StaRspConnect)
+  SharedDtor();
+}
+
+void StaRspConnect::SharedDtor() {
+}
+
+void StaRspConnect::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaRspConnect::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaRspConnect& StaRspConnect::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaRspConnect* StaRspConnect::New(::google::protobuf::Arena* arena) const {
+  StaRspConnect* n = new StaRspConnect;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaRspConnect::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaRspConnect)
+  rsp_ = 0;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaRspConnect::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaRspConnect)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional .WlanIpcCmdRsp rsp = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::WlanIpcCmdRsp_IsValid(value)) {
+            set_rsp(static_cast< ::WlanIpcCmdRsp >(value));
+          } else {
+            mutable_unknown_fields()->AddVarint(1, value);
+          }
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaRspConnect)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaRspConnect)
+  return false;
+#undef DO_
+}
+
+void StaRspConnect::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaRspConnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      1, this->rsp(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaRspConnect)
+}
+
+::google::protobuf::uint8* StaRspConnect::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaRspConnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
+      1, this->rsp(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaRspConnect)
+  return target;
+}
+
+size_t StaRspConnect::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaRspConnect)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (has_rsp()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rsp());
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaRspConnect::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaRspConnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaRspConnect* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaRspConnect>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaRspConnect)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaRspConnect)
+    MergeFrom(*source);
+  }
+}
+
+void StaRspConnect::MergeFrom(const StaRspConnect& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaRspConnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from.has_rsp()) {
+    set_rsp(from.rsp());
+  }
+}
+
+void StaRspConnect::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaRspConnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaRspConnect::CopyFrom(const StaRspConnect& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaRspConnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaRspConnect::IsInitialized() const {
+  return true;
+}
+
+void StaRspConnect::Swap(StaRspConnect* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaRspConnect::InternalSwap(StaRspConnect* other) {
+  std::swap(rsp_, other->rsp_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaRspConnect::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaRspConnect
+
+// optional .WlanIpcCmdRsp rsp = 1;
+bool StaRspConnect::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaRspConnect::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaRspConnect::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaRspConnect::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+::WlanIpcCmdRsp StaRspConnect::rsp() const {
+  // @@protoc_insertion_point(field_get:StaRspConnect.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+void StaRspConnect::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:StaRspConnect.rsp)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaReqDisconnect::StaReqDisconnect()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaReqDisconnect)
+}
+StaReqDisconnect::StaReqDisconnect(const StaReqDisconnect& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:StaReqDisconnect)
+}
+
+void StaReqDisconnect::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+StaReqDisconnect::~StaReqDisconnect() {
+  // @@protoc_insertion_point(destructor:StaReqDisconnect)
+  SharedDtor();
+}
+
+void StaReqDisconnect::SharedDtor() {
+}
+
+void StaReqDisconnect::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaReqDisconnect::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaReqDisconnect& StaReqDisconnect::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaReqDisconnect* StaReqDisconnect::New(::google::protobuf::Arena* arena) const {
+  StaReqDisconnect* n = new StaReqDisconnect;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaReqDisconnect::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaReqDisconnect)
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaReqDisconnect::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaReqDisconnect)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+  handle_unusual:
+    if (tag == 0 ||
+        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+      goto success;
+    }
+    DO_(::google::protobuf::internal::WireFormat::SkipField(
+          input, tag, mutable_unknown_fields()));
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaReqDisconnect)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaReqDisconnect)
+  return false;
+#undef DO_
+}
+
+void StaReqDisconnect::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaReqDisconnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaReqDisconnect)
+}
+
+::google::protobuf::uint8* StaReqDisconnect::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaReqDisconnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaReqDisconnect)
+  return target;
+}
+
+size_t StaReqDisconnect::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaReqDisconnect)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaReqDisconnect::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaReqDisconnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaReqDisconnect* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaReqDisconnect>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaReqDisconnect)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaReqDisconnect)
+    MergeFrom(*source);
+  }
+}
+
+void StaReqDisconnect::MergeFrom(const StaReqDisconnect& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaReqDisconnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+}
+
+void StaReqDisconnect::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaReqDisconnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaReqDisconnect::CopyFrom(const StaReqDisconnect& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaReqDisconnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaReqDisconnect::IsInitialized() const {
+  return true;
+}
+
+void StaReqDisconnect::Swap(StaReqDisconnect* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaReqDisconnect::InternalSwap(StaReqDisconnect* other) {
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaReqDisconnect::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaReqDisconnect
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaRspDisconnect::kRspFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaRspDisconnect::StaRspDisconnect()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaRspDisconnect)
+}
+StaRspDisconnect::StaRspDisconnect(const StaRspDisconnect& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  rsp_ = from.rsp_;
+  // @@protoc_insertion_point(copy_constructor:StaRspDisconnect)
+}
+
+void StaRspDisconnect::SharedCtor() {
+  _cached_size_ = 0;
+  rsp_ = 0;
+}
+
+StaRspDisconnect::~StaRspDisconnect() {
+  // @@protoc_insertion_point(destructor:StaRspDisconnect)
+  SharedDtor();
+}
+
+void StaRspDisconnect::SharedDtor() {
+}
+
+void StaRspDisconnect::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaRspDisconnect::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaRspDisconnect& StaRspDisconnect::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaRspDisconnect* StaRspDisconnect::New(::google::protobuf::Arena* arena) const {
+  StaRspDisconnect* n = new StaRspDisconnect;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaRspDisconnect::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaRspDisconnect)
+  rsp_ = 0;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaRspDisconnect::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaRspDisconnect)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional .WlanIpcCmdRsp rsp = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::WlanIpcCmdRsp_IsValid(value)) {
+            set_rsp(static_cast< ::WlanIpcCmdRsp >(value));
+          } else {
+            mutable_unknown_fields()->AddVarint(1, value);
+          }
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaRspDisconnect)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaRspDisconnect)
+  return false;
+#undef DO_
+}
+
+void StaRspDisconnect::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaRspDisconnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      1, this->rsp(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaRspDisconnect)
+}
+
+::google::protobuf::uint8* StaRspDisconnect::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaRspDisconnect)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
+      1, this->rsp(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaRspDisconnect)
+  return target;
+}
+
+size_t StaRspDisconnect::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaRspDisconnect)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (has_rsp()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rsp());
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaRspDisconnect::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaRspDisconnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaRspDisconnect* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaRspDisconnect>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaRspDisconnect)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaRspDisconnect)
+    MergeFrom(*source);
+  }
+}
+
+void StaRspDisconnect::MergeFrom(const StaRspDisconnect& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaRspDisconnect)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from.has_rsp()) {
+    set_rsp(from.rsp());
+  }
+}
+
+void StaRspDisconnect::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaRspDisconnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaRspDisconnect::CopyFrom(const StaRspDisconnect& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaRspDisconnect)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaRspDisconnect::IsInitialized() const {
+  return true;
+}
+
+void StaRspDisconnect::Swap(StaRspDisconnect* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaRspDisconnect::InternalSwap(StaRspDisconnect* other) {
+  std::swap(rsp_, other->rsp_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaRspDisconnect::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaRspDisconnect
+
+// optional .WlanIpcCmdRsp rsp = 1;
+bool StaRspDisconnect::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaRspDisconnect::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaRspDisconnect::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaRspDisconnect::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+::WlanIpcCmdRsp StaRspDisconnect::rsp() const {
+  // @@protoc_insertion_point(field_get:StaRspDisconnect.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+void StaRspDisconnect::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:StaRspDisconnect.rsp)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int StaStatusUpdate::kMacAddrFieldNumber;
+const int StaStatusUpdate::kSmStateFieldNumber;
+const int StaStatusUpdate::kConStateFieldNumber;
+const int StaStatusUpdate::kSsidFieldNumber;
+const int StaStatusUpdate::kSecurityFieldNumber;
+const int StaStatusUpdate::kPairCipherFieldNumber;
+const int StaStatusUpdate::kGroupCipherFieldNumber;
+const int StaStatusUpdate::kChannelFieldNumber;
+const int StaStatusUpdate::kBwFieldNumber;
+const int StaStatusUpdate::kTechFieldNumber;
+const int StaStatusUpdate::kDataRateFieldNumber;
+const int StaStatusUpdate::kRssiFieldNumber;
+const int StaStatusUpdate::kNoiseFieldNumber;
+const int StaStatusUpdate::kSnrFieldNumber;
+const int StaStatusUpdate::kIpFieldNumber;
+const int StaStatusUpdate::kNetmaskFieldNumber;
+const int StaStatusUpdate::kGatewayFieldNumber;
+const int StaStatusUpdate::kDnsPrefFieldNumber;
+const int StaStatusUpdate::kDnsAltFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+StaStatusUpdate::StaStatusUpdate()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:StaStatusUpdate)
+}
+StaStatusUpdate::StaStatusUpdate(const StaStatusUpdate& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  macaddr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_macaddr()) {
+    macaddr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.macaddr_);
+  }
+  ssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_ssid()) {
+    ssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ssid_);
+  }
+  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_ip()) {
+    ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
+  }
+  netmask_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_netmask()) {
+    netmask_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.netmask_);
+  }
+  gateway_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_gateway()) {
+    gateway_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gateway_);
+  }
+  dnspref_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_dnspref()) {
+    dnspref_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dnspref_);
+  }
+  dnsalt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  if (from.has_dnsalt()) {
+    dnsalt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dnsalt_);
+  }
+  ::memcpy(&smstate_, &from.smstate_,
+    reinterpret_cast<char*>(&snr_) -
+    reinterpret_cast<char*>(&smstate_) + sizeof(snr_));
+  // @@protoc_insertion_point(copy_constructor:StaStatusUpdate)
+}
+
+void StaStatusUpdate::SharedCtor() {
+  _cached_size_ = 0;
+  macaddr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ssid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  netmask_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  gateway_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  dnspref_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  dnsalt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ::memset(&smstate_, 0, reinterpret_cast<char*>(&snr_) -
+    reinterpret_cast<char*>(&smstate_) + sizeof(snr_));
+}
+
+StaStatusUpdate::~StaStatusUpdate() {
+  // @@protoc_insertion_point(destructor:StaStatusUpdate)
+  SharedDtor();
+}
+
+void StaStatusUpdate::SharedDtor() {
+  macaddr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ssid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  netmask_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  gateway_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  dnspref_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  dnsalt_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+
+void StaStatusUpdate::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* StaStatusUpdate::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const StaStatusUpdate& StaStatusUpdate::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+StaStatusUpdate* StaStatusUpdate::New(::google::protobuf::Arena* arena) const {
+  StaStatusUpdate* n = new StaStatusUpdate;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void StaStatusUpdate::Clear() {
+// @@protoc_insertion_point(message_clear_start:StaStatusUpdate)
+  if (_has_bits_[0 / 32] & 127u) {
+    if (has_macaddr()) {
+      GOOGLE_DCHECK(!macaddr_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*macaddr_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_ssid()) {
+      GOOGLE_DCHECK(!ssid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*ssid_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_ip()) {
+      GOOGLE_DCHECK(!ip_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*ip_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_netmask()) {
+      GOOGLE_DCHECK(!netmask_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*netmask_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_gateway()) {
+      GOOGLE_DCHECK(!gateway_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*gateway_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_dnspref()) {
+      GOOGLE_DCHECK(!dnspref_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*dnspref_.UnsafeRawStringPointer())->clear();
+    }
+    if (has_dnsalt()) {
+      GOOGLE_DCHECK(!dnsalt_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
+      (*dnsalt_.UnsafeRawStringPointer())->clear();
+    }
+  }
+  smstate_ = 0u;
+  if (_has_bits_[8 / 32] & 65280u) {
+    ::memset(&constate_, 0, reinterpret_cast<char*>(&datarate_) -
+      reinterpret_cast<char*>(&constate_) + sizeof(datarate_));
+  }
+  if (_has_bits_[16 / 32] & 458752u) {
+    ::memset(&rssi_, 0, reinterpret_cast<char*>(&snr_) -
+      reinterpret_cast<char*>(&rssi_) + sizeof(snr_));
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool StaStatusUpdate::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:StaStatusUpdate)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional bytes macAddr = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_macaddr()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 smState = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(16u)) {
+          set_has_smstate();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &smstate_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 conState = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(24u)) {
+          set_has_constate();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &constate_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes ssid = 4;
+      case 4: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(34u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_ssid()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 security = 5;
+      case 5: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(40u)) {
+          set_has_security();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &security_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 pairCipher = 6;
+      case 6: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(48u)) {
+          set_has_paircipher();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &paircipher_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 groupCipher = 7;
+      case 7: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(56u)) {
+          set_has_groupcipher();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &groupcipher_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 channel = 8;
+      case 8: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(64u)) {
+          set_has_channel();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &channel_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 bw = 9;
+      case 9: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(72u)) {
+          set_has_bw();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &bw_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 tech = 10;
+      case 10: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(80u)) {
+          set_has_tech();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &tech_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional uint32 dataRate = 11;
+      case 11: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(88u)) {
+          set_has_datarate();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
+                 input, &datarate_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional int32 rssi = 12;
+      case 12: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(96u)) {
+          set_has_rssi();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &rssi_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional int32 noise = 13;
+      case 13: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(104u)) {
+          set_has_noise();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &noise_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional int32 snr = 14;
+      case 14: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(112u)) {
+          set_has_snr();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &snr_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes ip = 15;
+      case 15: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(122u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_ip()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes netmask = 16;
+      case 16: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(130u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_netmask()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes gateway = 17;
+      case 17: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(138u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_gateway()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes dnsPref = 18;
+      case 18: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(146u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_dnspref()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional bytes dnsAlt = 19;
+      case 19: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(154u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->mutable_dnsalt()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:StaStatusUpdate)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:StaStatusUpdate)
+  return false;
+#undef DO_
+}
+
+void StaStatusUpdate::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:StaStatusUpdate)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes macAddr = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      1, this->macaddr(), output);
+  }
+
+  // optional uint32 smState = 2;
+  if (cached_has_bits & 0x00000080u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->smstate(), output);
+  }
+
+  // optional uint32 conState = 3;
+  if (cached_has_bits & 0x00000100u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->constate(), output);
+  }
+
+  // optional bytes ssid = 4;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      4, this->ssid(), output);
+  }
+
+  // optional uint32 security = 5;
+  if (cached_has_bits & 0x00000200u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->security(), output);
+  }
+
+  // optional uint32 pairCipher = 6;
+  if (cached_has_bits & 0x00000400u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->paircipher(), output);
+  }
+
+  // optional uint32 groupCipher = 7;
+  if (cached_has_bits & 0x00000800u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->groupcipher(), output);
+  }
+
+  // optional uint32 channel = 8;
+  if (cached_has_bits & 0x00001000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->channel(), output);
+  }
+
+  // optional uint32 bw = 9;
+  if (cached_has_bits & 0x00002000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->bw(), output);
+  }
+
+  // optional uint32 tech = 10;
+  if (cached_has_bits & 0x00004000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->tech(), output);
+  }
+
+  // optional uint32 dataRate = 11;
+  if (cached_has_bits & 0x00008000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->datarate(), output);
+  }
+
+  // optional int32 rssi = 12;
+  if (cached_has_bits & 0x00010000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->rssi(), output);
+  }
+
+  // optional int32 noise = 13;
+  if (cached_has_bits & 0x00020000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->noise(), output);
+  }
+
+  // optional int32 snr = 14;
+  if (cached_has_bits & 0x00040000u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->snr(), output);
+  }
+
+  // optional bytes ip = 15;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      15, this->ip(), output);
+  }
+
+  // optional bytes netmask = 16;
+  if (cached_has_bits & 0x00000008u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      16, this->netmask(), output);
+  }
+
+  // optional bytes gateway = 17;
+  if (cached_has_bits & 0x00000010u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      17, this->gateway(), output);
+  }
+
+  // optional bytes dnsPref = 18;
+  if (cached_has_bits & 0x00000020u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      18, this->dnspref(), output);
+  }
+
+  // optional bytes dnsAlt = 19;
+  if (cached_has_bits & 0x00000040u) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
+      19, this->dnsalt(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:StaStatusUpdate)
+}
+
+::google::protobuf::uint8* StaStatusUpdate::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:StaStatusUpdate)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional bytes macAddr = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        1, this->macaddr(), target);
+  }
+
+  // optional uint32 smState = 2;
+  if (cached_has_bits & 0x00000080u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->smstate(), target);
+  }
+
+  // optional uint32 conState = 3;
+  if (cached_has_bits & 0x00000100u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->constate(), target);
+  }
+
+  // optional bytes ssid = 4;
+  if (cached_has_bits & 0x00000002u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        4, this->ssid(), target);
+  }
+
+  // optional uint32 security = 5;
+  if (cached_has_bits & 0x00000200u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->security(), target);
+  }
+
+  // optional uint32 pairCipher = 6;
+  if (cached_has_bits & 0x00000400u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->paircipher(), target);
+  }
+
+  // optional uint32 groupCipher = 7;
+  if (cached_has_bits & 0x00000800u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->groupcipher(), target);
+  }
+
+  // optional uint32 channel = 8;
+  if (cached_has_bits & 0x00001000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->channel(), target);
+  }
+
+  // optional uint32 bw = 9;
+  if (cached_has_bits & 0x00002000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->bw(), target);
+  }
+
+  // optional uint32 tech = 10;
+  if (cached_has_bits & 0x00004000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->tech(), target);
+  }
+
+  // optional uint32 dataRate = 11;
+  if (cached_has_bits & 0x00008000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->datarate(), target);
+  }
+
+  // optional int32 rssi = 12;
+  if (cached_has_bits & 0x00010000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->rssi(), target);
+  }
+
+  // optional int32 noise = 13;
+  if (cached_has_bits & 0x00020000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->noise(), target);
+  }
+
+  // optional int32 snr = 14;
+  if (cached_has_bits & 0x00040000u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->snr(), target);
+  }
+
+  // optional bytes ip = 15;
+  if (cached_has_bits & 0x00000004u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        15, this->ip(), target);
+  }
+
+  // optional bytes netmask = 16;
+  if (cached_has_bits & 0x00000008u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        16, this->netmask(), target);
+  }
+
+  // optional bytes gateway = 17;
+  if (cached_has_bits & 0x00000010u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        17, this->gateway(), target);
+  }
+
+  // optional bytes dnsPref = 18;
+  if (cached_has_bits & 0x00000020u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        18, this->dnspref(), target);
+  }
+
+  // optional bytes dnsAlt = 19;
+  if (cached_has_bits & 0x00000040u) {
+    target =
+      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
+        19, this->dnsalt(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:StaStatusUpdate)
+  return target;
+}
+
+size_t StaStatusUpdate::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:StaStatusUpdate)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 255u) {
+    // optional bytes macAddr = 1;
+    if (has_macaddr()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->macaddr());
+    }
+
+    // optional bytes ssid = 4;
+    if (has_ssid()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->ssid());
+    }
+
+    // optional bytes ip = 15;
+    if (has_ip()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->ip());
+    }
+
+    // optional bytes netmask = 16;
+    if (has_netmask()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->netmask());
+    }
+
+    // optional bytes gateway = 17;
+    if (has_gateway()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->gateway());
+    }
+
+    // optional bytes dnsPref = 18;
+    if (has_dnspref()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->dnspref());
+    }
+
+    // optional bytes dnsAlt = 19;
+    if (has_dnsalt()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::BytesSize(
+          this->dnsalt());
+    }
+
+    // optional uint32 smState = 2;
+    if (has_smstate()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->smstate());
+    }
+
+  }
+  if (_has_bits_[8 / 32] & 65280u) {
+    // optional uint32 conState = 3;
+    if (has_constate()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->constate());
+    }
+
+    // optional uint32 security = 5;
+    if (has_security()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->security());
+    }
+
+    // optional uint32 pairCipher = 6;
+    if (has_paircipher()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->paircipher());
+    }
+
+    // optional uint32 groupCipher = 7;
+    if (has_groupcipher()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->groupcipher());
+    }
+
+    // optional uint32 channel = 8;
+    if (has_channel()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->channel());
+    }
+
+    // optional uint32 bw = 9;
+    if (has_bw()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->bw());
+    }
+
+    // optional uint32 tech = 10;
+    if (has_tech()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->tech());
+    }
+
+    // optional uint32 dataRate = 11;
+    if (has_datarate()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::UInt32Size(
+          this->datarate());
+    }
+
+  }
+  if (_has_bits_[16 / 32] & 458752u) {
+    // optional int32 rssi = 12;
+    if (has_rssi()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->rssi());
+    }
+
+    // optional int32 noise = 13;
+    if (has_noise()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->noise());
+    }
+
+    // optional int32 snr = 14;
+    if (has_snr()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->snr());
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void StaStatusUpdate::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:StaStatusUpdate)
+  GOOGLE_DCHECK_NE(&from, this);
+  const StaStatusUpdate* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const StaStatusUpdate>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StaStatusUpdate)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:StaStatusUpdate)
+    MergeFrom(*source);
+  }
+}
+
+void StaStatusUpdate::MergeFrom(const StaStatusUpdate& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:StaStatusUpdate)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 255u) {
+    if (cached_has_bits & 0x00000001u) {
+      set_has_macaddr();
+      macaddr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.macaddr_);
+    }
+    if (cached_has_bits & 0x00000002u) {
+      set_has_ssid();
+      ssid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ssid_);
+    }
+    if (cached_has_bits & 0x00000004u) {
+      set_has_ip();
+      ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
+    }
+    if (cached_has_bits & 0x00000008u) {
+      set_has_netmask();
+      netmask_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.netmask_);
+    }
+    if (cached_has_bits & 0x00000010u) {
+      set_has_gateway();
+      gateway_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gateway_);
+    }
+    if (cached_has_bits & 0x00000020u) {
+      set_has_dnspref();
+      dnspref_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dnspref_);
+    }
+    if (cached_has_bits & 0x00000040u) {
+      set_has_dnsalt();
+      dnsalt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dnsalt_);
+    }
+    if (cached_has_bits & 0x00000080u) {
+      smstate_ = from.smstate_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+  if (cached_has_bits & 65280u) {
+    if (cached_has_bits & 0x00000100u) {
+      constate_ = from.constate_;
+    }
+    if (cached_has_bits & 0x00000200u) {
+      security_ = from.security_;
+    }
+    if (cached_has_bits & 0x00000400u) {
+      paircipher_ = from.paircipher_;
+    }
+    if (cached_has_bits & 0x00000800u) {
+      groupcipher_ = from.groupcipher_;
+    }
+    if (cached_has_bits & 0x00001000u) {
+      channel_ = from.channel_;
+    }
+    if (cached_has_bits & 0x00002000u) {
+      bw_ = from.bw_;
+    }
+    if (cached_has_bits & 0x00004000u) {
+      tech_ = from.tech_;
+    }
+    if (cached_has_bits & 0x00008000u) {
+      datarate_ = from.datarate_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+  if (cached_has_bits & 458752u) {
+    if (cached_has_bits & 0x00010000u) {
+      rssi_ = from.rssi_;
+    }
+    if (cached_has_bits & 0x00020000u) {
+      noise_ = from.noise_;
+    }
+    if (cached_has_bits & 0x00040000u) {
+      snr_ = from.snr_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void StaStatusUpdate::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:StaStatusUpdate)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void StaStatusUpdate::CopyFrom(const StaStatusUpdate& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:StaStatusUpdate)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool StaStatusUpdate::IsInitialized() const {
+  return true;
+}
+
+void StaStatusUpdate::Swap(StaStatusUpdate* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void StaStatusUpdate::InternalSwap(StaStatusUpdate* other) {
+  macaddr_.Swap(&other->macaddr_);
+  ssid_.Swap(&other->ssid_);
+  ip_.Swap(&other->ip_);
+  netmask_.Swap(&other->netmask_);
+  gateway_.Swap(&other->gateway_);
+  dnspref_.Swap(&other->dnspref_);
+  dnsalt_.Swap(&other->dnsalt_);
+  std::swap(smstate_, other->smstate_);
+  std::swap(constate_, other->constate_);
+  std::swap(security_, other->security_);
+  std::swap(paircipher_, other->paircipher_);
+  std::swap(groupcipher_, other->groupcipher_);
+  std::swap(channel_, other->channel_);
+  std::swap(bw_, other->bw_);
+  std::swap(tech_, other->tech_);
+  std::swap(datarate_, other->datarate_);
+  std::swap(rssi_, other->rssi_);
+  std::swap(noise_, other->noise_);
+  std::swap(snr_, other->snr_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata StaStatusUpdate::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaStatusUpdate
+
+// optional bytes macAddr = 1;
+bool StaStatusUpdate::has_macaddr() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void StaStatusUpdate::set_has_macaddr() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void StaStatusUpdate::clear_has_macaddr() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void StaStatusUpdate::clear_macaddr() {
+  macaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_macaddr();
+}
+const ::std::string& StaStatusUpdate::macaddr() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.macAddr)
+  return macaddr_.GetNoArena();
+}
+void StaStatusUpdate::set_macaddr(const ::std::string& value) {
+  set_has_macaddr();
+  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.macAddr)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_macaddr(::std::string&& value) {
+  set_has_macaddr();
+  macaddr_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.macAddr)
+}
+#endif
+void StaStatusUpdate::set_macaddr(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_macaddr();
+  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.macAddr)
+}
+void StaStatusUpdate::set_macaddr(const void* value, size_t size) {
+  set_has_macaddr();
+  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.macAddr)
+}
+::std::string* StaStatusUpdate::mutable_macaddr() {
+  set_has_macaddr();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.macAddr)
+  return macaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_macaddr() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.macAddr)
+  clear_has_macaddr();
+  return macaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_macaddr(::std::string* macaddr) {
+  if (macaddr != NULL) {
+    set_has_macaddr();
+  } else {
+    clear_has_macaddr();
+  }
+  macaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macaddr);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.macAddr)
+}
+
+// optional uint32 smState = 2;
+bool StaStatusUpdate::has_smstate() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+void StaStatusUpdate::set_has_smstate() {
+  _has_bits_[0] |= 0x00000080u;
+}
+void StaStatusUpdate::clear_has_smstate() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+void StaStatusUpdate::clear_smstate() {
+  smstate_ = 0u;
+  clear_has_smstate();
+}
+::google::protobuf::uint32 StaStatusUpdate::smstate() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.smState)
+  return smstate_;
+}
+void StaStatusUpdate::set_smstate(::google::protobuf::uint32 value) {
+  set_has_smstate();
+  smstate_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.smState)
+}
+
+// optional uint32 conState = 3;
+bool StaStatusUpdate::has_constate() const {
+  return (_has_bits_[0] & 0x00000100u) != 0;
+}
+void StaStatusUpdate::set_has_constate() {
+  _has_bits_[0] |= 0x00000100u;
+}
+void StaStatusUpdate::clear_has_constate() {
+  _has_bits_[0] &= ~0x00000100u;
+}
+void StaStatusUpdate::clear_constate() {
+  constate_ = 0u;
+  clear_has_constate();
+}
+::google::protobuf::uint32 StaStatusUpdate::constate() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.conState)
+  return constate_;
+}
+void StaStatusUpdate::set_constate(::google::protobuf::uint32 value) {
+  set_has_constate();
+  constate_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.conState)
+}
+
+// optional bytes ssid = 4;
+bool StaStatusUpdate::has_ssid() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void StaStatusUpdate::set_has_ssid() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void StaStatusUpdate::clear_has_ssid() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void StaStatusUpdate::clear_ssid() {
+  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ssid();
+}
+const ::std::string& StaStatusUpdate::ssid() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.ssid)
+  return ssid_.GetNoArena();
+}
+void StaStatusUpdate::set_ssid(const ::std::string& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.ssid)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_ssid(::std::string&& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.ssid)
+}
+#endif
+void StaStatusUpdate::set_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.ssid)
+}
+void StaStatusUpdate::set_ssid(const void* value, size_t size) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.ssid)
+}
+::std::string* StaStatusUpdate::mutable_ssid() {
+  set_has_ssid();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.ssid)
+  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_ssid() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.ssid)
+  clear_has_ssid();
+  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_ssid(::std::string* ssid) {
+  if (ssid != NULL) {
+    set_has_ssid();
+  } else {
+    clear_has_ssid();
+  }
+  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.ssid)
+}
+
+// optional uint32 security = 5;
+bool StaStatusUpdate::has_security() const {
+  return (_has_bits_[0] & 0x00000200u) != 0;
+}
+void StaStatusUpdate::set_has_security() {
+  _has_bits_[0] |= 0x00000200u;
+}
+void StaStatusUpdate::clear_has_security() {
+  _has_bits_[0] &= ~0x00000200u;
+}
+void StaStatusUpdate::clear_security() {
+  security_ = 0u;
+  clear_has_security();
+}
+::google::protobuf::uint32 StaStatusUpdate::security() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.security)
+  return security_;
+}
+void StaStatusUpdate::set_security(::google::protobuf::uint32 value) {
+  set_has_security();
+  security_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.security)
+}
+
+// optional uint32 pairCipher = 6;
+bool StaStatusUpdate::has_paircipher() const {
+  return (_has_bits_[0] & 0x00000400u) != 0;
+}
+void StaStatusUpdate::set_has_paircipher() {
+  _has_bits_[0] |= 0x00000400u;
+}
+void StaStatusUpdate::clear_has_paircipher() {
+  _has_bits_[0] &= ~0x00000400u;
+}
+void StaStatusUpdate::clear_paircipher() {
+  paircipher_ = 0u;
+  clear_has_paircipher();
+}
+::google::protobuf::uint32 StaStatusUpdate::paircipher() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.pairCipher)
+  return paircipher_;
+}
+void StaStatusUpdate::set_paircipher(::google::protobuf::uint32 value) {
+  set_has_paircipher();
+  paircipher_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.pairCipher)
+}
+
+// optional uint32 groupCipher = 7;
+bool StaStatusUpdate::has_groupcipher() const {
+  return (_has_bits_[0] & 0x00000800u) != 0;
+}
+void StaStatusUpdate::set_has_groupcipher() {
+  _has_bits_[0] |= 0x00000800u;
+}
+void StaStatusUpdate::clear_has_groupcipher() {
+  _has_bits_[0] &= ~0x00000800u;
+}
+void StaStatusUpdate::clear_groupcipher() {
+  groupcipher_ = 0u;
+  clear_has_groupcipher();
+}
+::google::protobuf::uint32 StaStatusUpdate::groupcipher() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.groupCipher)
+  return groupcipher_;
+}
+void StaStatusUpdate::set_groupcipher(::google::protobuf::uint32 value) {
+  set_has_groupcipher();
+  groupcipher_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.groupCipher)
+}
+
+// optional uint32 channel = 8;
+bool StaStatusUpdate::has_channel() const {
+  return (_has_bits_[0] & 0x00001000u) != 0;
+}
+void StaStatusUpdate::set_has_channel() {
+  _has_bits_[0] |= 0x00001000u;
+}
+void StaStatusUpdate::clear_has_channel() {
+  _has_bits_[0] &= ~0x00001000u;
+}
+void StaStatusUpdate::clear_channel() {
+  channel_ = 0u;
+  clear_has_channel();
+}
+::google::protobuf::uint32 StaStatusUpdate::channel() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.channel)
+  return channel_;
+}
+void StaStatusUpdate::set_channel(::google::protobuf::uint32 value) {
+  set_has_channel();
+  channel_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.channel)
+}
+
+// optional uint32 bw = 9;
+bool StaStatusUpdate::has_bw() const {
+  return (_has_bits_[0] & 0x00002000u) != 0;
+}
+void StaStatusUpdate::set_has_bw() {
+  _has_bits_[0] |= 0x00002000u;
+}
+void StaStatusUpdate::clear_has_bw() {
+  _has_bits_[0] &= ~0x00002000u;
+}
+void StaStatusUpdate::clear_bw() {
+  bw_ = 0u;
+  clear_has_bw();
+}
+::google::protobuf::uint32 StaStatusUpdate::bw() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.bw)
+  return bw_;
+}
+void StaStatusUpdate::set_bw(::google::protobuf::uint32 value) {
+  set_has_bw();
+  bw_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.bw)
+}
+
+// optional uint32 tech = 10;
+bool StaStatusUpdate::has_tech() const {
+  return (_has_bits_[0] & 0x00004000u) != 0;
+}
+void StaStatusUpdate::set_has_tech() {
+  _has_bits_[0] |= 0x00004000u;
+}
+void StaStatusUpdate::clear_has_tech() {
+  _has_bits_[0] &= ~0x00004000u;
+}
+void StaStatusUpdate::clear_tech() {
+  tech_ = 0u;
+  clear_has_tech();
+}
+::google::protobuf::uint32 StaStatusUpdate::tech() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.tech)
+  return tech_;
+}
+void StaStatusUpdate::set_tech(::google::protobuf::uint32 value) {
+  set_has_tech();
+  tech_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.tech)
+}
+
+// optional uint32 dataRate = 11;
+bool StaStatusUpdate::has_datarate() const {
+  return (_has_bits_[0] & 0x00008000u) != 0;
+}
+void StaStatusUpdate::set_has_datarate() {
+  _has_bits_[0] |= 0x00008000u;
+}
+void StaStatusUpdate::clear_has_datarate() {
+  _has_bits_[0] &= ~0x00008000u;
+}
+void StaStatusUpdate::clear_datarate() {
+  datarate_ = 0u;
+  clear_has_datarate();
+}
+::google::protobuf::uint32 StaStatusUpdate::datarate() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.dataRate)
+  return datarate_;
+}
+void StaStatusUpdate::set_datarate(::google::protobuf::uint32 value) {
+  set_has_datarate();
+  datarate_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.dataRate)
+}
+
+// optional int32 rssi = 12;
+bool StaStatusUpdate::has_rssi() const {
+  return (_has_bits_[0] & 0x00010000u) != 0;
+}
+void StaStatusUpdate::set_has_rssi() {
+  _has_bits_[0] |= 0x00010000u;
+}
+void StaStatusUpdate::clear_has_rssi() {
+  _has_bits_[0] &= ~0x00010000u;
+}
+void StaStatusUpdate::clear_rssi() {
+  rssi_ = 0;
+  clear_has_rssi();
+}
+::google::protobuf::int32 StaStatusUpdate::rssi() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.rssi)
+  return rssi_;
+}
+void StaStatusUpdate::set_rssi(::google::protobuf::int32 value) {
+  set_has_rssi();
+  rssi_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.rssi)
+}
+
+// optional int32 noise = 13;
+bool StaStatusUpdate::has_noise() const {
+  return (_has_bits_[0] & 0x00020000u) != 0;
+}
+void StaStatusUpdate::set_has_noise() {
+  _has_bits_[0] |= 0x00020000u;
+}
+void StaStatusUpdate::clear_has_noise() {
+  _has_bits_[0] &= ~0x00020000u;
+}
+void StaStatusUpdate::clear_noise() {
+  noise_ = 0;
+  clear_has_noise();
+}
+::google::protobuf::int32 StaStatusUpdate::noise() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.noise)
+  return noise_;
+}
+void StaStatusUpdate::set_noise(::google::protobuf::int32 value) {
+  set_has_noise();
+  noise_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.noise)
+}
+
+// optional int32 snr = 14;
+bool StaStatusUpdate::has_snr() const {
+  return (_has_bits_[0] & 0x00040000u) != 0;
+}
+void StaStatusUpdate::set_has_snr() {
+  _has_bits_[0] |= 0x00040000u;
+}
+void StaStatusUpdate::clear_has_snr() {
+  _has_bits_[0] &= ~0x00040000u;
+}
+void StaStatusUpdate::clear_snr() {
+  snr_ = 0;
+  clear_has_snr();
+}
+::google::protobuf::int32 StaStatusUpdate::snr() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.snr)
+  return snr_;
+}
+void StaStatusUpdate::set_snr(::google::protobuf::int32 value) {
+  set_has_snr();
+  snr_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.snr)
+}
+
+// optional bytes ip = 15;
+bool StaStatusUpdate::has_ip() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void StaStatusUpdate::set_has_ip() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void StaStatusUpdate::clear_has_ip() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void StaStatusUpdate::clear_ip() {
+  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ip();
+}
+const ::std::string& StaStatusUpdate::ip() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.ip)
+  return ip_.GetNoArena();
+}
+void StaStatusUpdate::set_ip(const ::std::string& value) {
+  set_has_ip();
+  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.ip)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_ip(::std::string&& value) {
+  set_has_ip();
+  ip_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.ip)
+}
+#endif
+void StaStatusUpdate::set_ip(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ip();
+  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.ip)
+}
+void StaStatusUpdate::set_ip(const void* value, size_t size) {
+  set_has_ip();
+  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.ip)
+}
+::std::string* StaStatusUpdate::mutable_ip() {
+  set_has_ip();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.ip)
+  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_ip() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.ip)
+  clear_has_ip();
+  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_ip(::std::string* ip) {
+  if (ip != NULL) {
+    set_has_ip();
+  } else {
+    clear_has_ip();
+  }
+  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.ip)
+}
+
+// optional bytes netmask = 16;
+bool StaStatusUpdate::has_netmask() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void StaStatusUpdate::set_has_netmask() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void StaStatusUpdate::clear_has_netmask() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void StaStatusUpdate::clear_netmask() {
+  netmask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_netmask();
+}
+const ::std::string& StaStatusUpdate::netmask() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.netmask)
+  return netmask_.GetNoArena();
+}
+void StaStatusUpdate::set_netmask(const ::std::string& value) {
+  set_has_netmask();
+  netmask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.netmask)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_netmask(::std::string&& value) {
+  set_has_netmask();
+  netmask_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.netmask)
+}
+#endif
+void StaStatusUpdate::set_netmask(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_netmask();
+  netmask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.netmask)
+}
+void StaStatusUpdate::set_netmask(const void* value, size_t size) {
+  set_has_netmask();
+  netmask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.netmask)
+}
+::std::string* StaStatusUpdate::mutable_netmask() {
+  set_has_netmask();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.netmask)
+  return netmask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_netmask() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.netmask)
+  clear_has_netmask();
+  return netmask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_netmask(::std::string* netmask) {
+  if (netmask != NULL) {
+    set_has_netmask();
+  } else {
+    clear_has_netmask();
+  }
+  netmask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), netmask);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.netmask)
+}
+
+// optional bytes gateway = 17;
+bool StaStatusUpdate::has_gateway() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void StaStatusUpdate::set_has_gateway() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void StaStatusUpdate::clear_has_gateway() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void StaStatusUpdate::clear_gateway() {
+  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_gateway();
+}
+const ::std::string& StaStatusUpdate::gateway() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.gateway)
+  return gateway_.GetNoArena();
+}
+void StaStatusUpdate::set_gateway(const ::std::string& value) {
+  set_has_gateway();
+  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.gateway)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_gateway(::std::string&& value) {
+  set_has_gateway();
+  gateway_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.gateway)
+}
+#endif
+void StaStatusUpdate::set_gateway(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_gateway();
+  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.gateway)
+}
+void StaStatusUpdate::set_gateway(const void* value, size_t size) {
+  set_has_gateway();
+  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.gateway)
+}
+::std::string* StaStatusUpdate::mutable_gateway() {
+  set_has_gateway();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.gateway)
+  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_gateway() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.gateway)
+  clear_has_gateway();
+  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_gateway(::std::string* gateway) {
+  if (gateway != NULL) {
+    set_has_gateway();
+  } else {
+    clear_has_gateway();
+  }
+  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.gateway)
+}
+
+// optional bytes dnsPref = 18;
+bool StaStatusUpdate::has_dnspref() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+void StaStatusUpdate::set_has_dnspref() {
+  _has_bits_[0] |= 0x00000020u;
+}
+void StaStatusUpdate::clear_has_dnspref() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+void StaStatusUpdate::clear_dnspref() {
+  dnspref_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_dnspref();
+}
+const ::std::string& StaStatusUpdate::dnspref() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.dnsPref)
+  return dnspref_.GetNoArena();
+}
+void StaStatusUpdate::set_dnspref(const ::std::string& value) {
+  set_has_dnspref();
+  dnspref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.dnsPref)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_dnspref(::std::string&& value) {
+  set_has_dnspref();
+  dnspref_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.dnsPref)
+}
+#endif
+void StaStatusUpdate::set_dnspref(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_dnspref();
+  dnspref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.dnsPref)
+}
+void StaStatusUpdate::set_dnspref(const void* value, size_t size) {
+  set_has_dnspref();
+  dnspref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.dnsPref)
+}
+::std::string* StaStatusUpdate::mutable_dnspref() {
+  set_has_dnspref();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.dnsPref)
+  return dnspref_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_dnspref() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.dnsPref)
+  clear_has_dnspref();
+  return dnspref_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_dnspref(::std::string* dnspref) {
+  if (dnspref != NULL) {
+    set_has_dnspref();
+  } else {
+    clear_has_dnspref();
+  }
+  dnspref_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dnspref);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.dnsPref)
+}
+
+// optional bytes dnsAlt = 19;
+bool StaStatusUpdate::has_dnsalt() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+void StaStatusUpdate::set_has_dnsalt() {
+  _has_bits_[0] |= 0x00000040u;
+}
+void StaStatusUpdate::clear_has_dnsalt() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+void StaStatusUpdate::clear_dnsalt() {
+  dnsalt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_dnsalt();
+}
+const ::std::string& StaStatusUpdate::dnsalt() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.dnsAlt)
+  return dnsalt_.GetNoArena();
+}
+void StaStatusUpdate::set_dnsalt(const ::std::string& value) {
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.dnsAlt)
+}
+#if LANG_CXX11
+void StaStatusUpdate::set_dnsalt(::std::string&& value) {
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.dnsAlt)
+}
+#endif
+void StaStatusUpdate::set_dnsalt(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.dnsAlt)
+}
+void StaStatusUpdate::set_dnsalt(const void* value, size_t size) {
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.dnsAlt)
+}
+::std::string* StaStatusUpdate::mutable_dnsalt() {
+  set_has_dnsalt();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.dnsAlt)
+  return dnsalt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+::std::string* StaStatusUpdate::release_dnsalt() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.dnsAlt)
+  clear_has_dnsalt();
+  return dnsalt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+void StaStatusUpdate::set_allocated_dnsalt(::std::string* dnsalt) {
+  if (dnsalt != NULL) {
+    set_has_dnsalt();
+  } else {
+    clear_has_dnsalt();
+  }
+  dnsalt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dnsalt);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.dnsAlt)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+BtReqRequestFw::BtReqRequestFw()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:BtReqRequestFw)
+}
+BtReqRequestFw::BtReqRequestFw(const BtReqRequestFw& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:BtReqRequestFw)
+}
+
+void BtReqRequestFw::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+BtReqRequestFw::~BtReqRequestFw() {
+  // @@protoc_insertion_point(destructor:BtReqRequestFw)
+  SharedDtor();
+}
+
+void BtReqRequestFw::SharedDtor() {
+}
+
+void BtReqRequestFw::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* BtReqRequestFw::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const BtReqRequestFw& BtReqRequestFw::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+BtReqRequestFw* BtReqRequestFw::New(::google::protobuf::Arena* arena) const {
+  BtReqRequestFw* n = new BtReqRequestFw;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void BtReqRequestFw::Clear() {
+// @@protoc_insertion_point(message_clear_start:BtReqRequestFw)
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool BtReqRequestFw::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:BtReqRequestFw)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+  handle_unusual:
+    if (tag == 0 ||
+        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+      goto success;
+    }
+    DO_(::google::protobuf::internal::WireFormat::SkipField(
+          input, tag, mutable_unknown_fields()));
+  }
+success:
+  // @@protoc_insertion_point(parse_success:BtReqRequestFw)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:BtReqRequestFw)
+  return false;
+#undef DO_
+}
+
+void BtReqRequestFw::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:BtReqRequestFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:BtReqRequestFw)
+}
+
+::google::protobuf::uint8* BtReqRequestFw::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:BtReqRequestFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:BtReqRequestFw)
+  return target;
+}
+
+size_t BtReqRequestFw::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:BtReqRequestFw)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void BtReqRequestFw::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:BtReqRequestFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  const BtReqRequestFw* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const BtReqRequestFw>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BtReqRequestFw)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:BtReqRequestFw)
+    MergeFrom(*source);
+  }
+}
+
+void BtReqRequestFw::MergeFrom(const BtReqRequestFw& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:BtReqRequestFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+}
+
+void BtReqRequestFw::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:BtReqRequestFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void BtReqRequestFw::CopyFrom(const BtReqRequestFw& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:BtReqRequestFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool BtReqRequestFw::IsInitialized() const {
+  return true;
+}
+
+void BtReqRequestFw::Swap(BtReqRequestFw* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void BtReqRequestFw::InternalSwap(BtReqRequestFw* other) {
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata BtReqRequestFw::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// BtReqRequestFw
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int BtRspRequestFw::kRspFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+BtRspRequestFw::BtRspRequestFw()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:BtRspRequestFw)
+}
+BtRspRequestFw::BtRspRequestFw(const BtRspRequestFw& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  rsp_ = from.rsp_;
+  // @@protoc_insertion_point(copy_constructor:BtRspRequestFw)
+}
+
+void BtRspRequestFw::SharedCtor() {
+  _cached_size_ = 0;
+  rsp_ = 0;
+}
+
+BtRspRequestFw::~BtRspRequestFw() {
+  // @@protoc_insertion_point(destructor:BtRspRequestFw)
+  SharedDtor();
+}
+
+void BtRspRequestFw::SharedDtor() {
+}
+
+void BtRspRequestFw::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* BtRspRequestFw::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const BtRspRequestFw& BtRspRequestFw::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+BtRspRequestFw* BtRspRequestFw::New(::google::protobuf::Arena* arena) const {
+  BtRspRequestFw* n = new BtRspRequestFw;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void BtRspRequestFw::Clear() {
+// @@protoc_insertion_point(message_clear_start:BtRspRequestFw)
+  rsp_ = 0;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool BtRspRequestFw::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:BtRspRequestFw)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional .WlanIpcCmdRsp rsp = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::WlanIpcCmdRsp_IsValid(value)) {
+            set_rsp(static_cast< ::WlanIpcCmdRsp >(value));
+          } else {
+            mutable_unknown_fields()->AddVarint(1, value);
+          }
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:BtRspRequestFw)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:BtRspRequestFw)
+  return false;
+#undef DO_
+}
+
+void BtRspRequestFw::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:BtRspRequestFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      1, this->rsp(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:BtRspRequestFw)
+}
+
+::google::protobuf::uint8* BtRspRequestFw::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:BtRspRequestFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
+      1, this->rsp(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:BtRspRequestFw)
+  return target;
+}
+
+size_t BtRspRequestFw::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:BtRspRequestFw)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (has_rsp()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rsp());
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void BtRspRequestFw::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:BtRspRequestFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  const BtRspRequestFw* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const BtRspRequestFw>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BtRspRequestFw)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:BtRspRequestFw)
+    MergeFrom(*source);
+  }
+}
+
+void BtRspRequestFw::MergeFrom(const BtRspRequestFw& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:BtRspRequestFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from.has_rsp()) {
+    set_rsp(from.rsp());
+  }
+}
+
+void BtRspRequestFw::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:BtRspRequestFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void BtRspRequestFw::CopyFrom(const BtRspRequestFw& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:BtRspRequestFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool BtRspRequestFw::IsInitialized() const {
+  return true;
+}
+
+void BtRspRequestFw::Swap(BtRspRequestFw* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void BtRspRequestFw::InternalSwap(BtRspRequestFw* other) {
+  std::swap(rsp_, other->rsp_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata BtRspRequestFw::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// BtRspRequestFw
+
+// optional .WlanIpcCmdRsp rsp = 1;
+bool BtRspRequestFw::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void BtRspRequestFw::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void BtRspRequestFw::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void BtRspRequestFw::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+::WlanIpcCmdRsp BtRspRequestFw::rsp() const {
+  // @@protoc_insertion_point(field_get:BtRspRequestFw.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+void BtRspRequestFw::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:BtRspRequestFw.rsp)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+BtReqDeclineFw::BtReqDeclineFw()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:BtReqDeclineFw)
+}
+BtReqDeclineFw::BtReqDeclineFw(const BtReqDeclineFw& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  // @@protoc_insertion_point(copy_constructor:BtReqDeclineFw)
+}
+
+void BtReqDeclineFw::SharedCtor() {
+  _cached_size_ = 0;
+}
+
+BtReqDeclineFw::~BtReqDeclineFw() {
+  // @@protoc_insertion_point(destructor:BtReqDeclineFw)
+  SharedDtor();
+}
+
+void BtReqDeclineFw::SharedDtor() {
+}
+
+void BtReqDeclineFw::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* BtReqDeclineFw::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const BtReqDeclineFw& BtReqDeclineFw::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+BtReqDeclineFw* BtReqDeclineFw::New(::google::protobuf::Arena* arena) const {
+  BtReqDeclineFw* n = new BtReqDeclineFw;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void BtReqDeclineFw::Clear() {
+// @@protoc_insertion_point(message_clear_start:BtReqDeclineFw)
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool BtReqDeclineFw::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:BtReqDeclineFw)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+  handle_unusual:
+    if (tag == 0 ||
+        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+      goto success;
+    }
+    DO_(::google::protobuf::internal::WireFormat::SkipField(
+          input, tag, mutable_unknown_fields()));
+  }
+success:
+  // @@protoc_insertion_point(parse_success:BtReqDeclineFw)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:BtReqDeclineFw)
+  return false;
+#undef DO_
+}
+
+void BtReqDeclineFw::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:BtReqDeclineFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:BtReqDeclineFw)
+}
+
+::google::protobuf::uint8* BtReqDeclineFw::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:BtReqDeclineFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:BtReqDeclineFw)
+  return target;
+}
+
+size_t BtReqDeclineFw::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:BtReqDeclineFw)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void BtReqDeclineFw::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:BtReqDeclineFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  const BtReqDeclineFw* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const BtReqDeclineFw>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BtReqDeclineFw)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:BtReqDeclineFw)
+    MergeFrom(*source);
+  }
+}
+
+void BtReqDeclineFw::MergeFrom(const BtReqDeclineFw& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:BtReqDeclineFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+}
+
+void BtReqDeclineFw::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:BtReqDeclineFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void BtReqDeclineFw::CopyFrom(const BtReqDeclineFw& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:BtReqDeclineFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool BtReqDeclineFw::IsInitialized() const {
+  return true;
+}
+
+void BtReqDeclineFw::Swap(BtReqDeclineFw* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void BtReqDeclineFw::InternalSwap(BtReqDeclineFw* other) {
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata BtReqDeclineFw::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// BtReqDeclineFw
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int BtRspDeclineFw::kRspFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+BtRspDeclineFw::BtRspDeclineFw()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:BtRspDeclineFw)
+}
+BtRspDeclineFw::BtRspDeclineFw(const BtRspDeclineFw& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  rsp_ = from.rsp_;
+  // @@protoc_insertion_point(copy_constructor:BtRspDeclineFw)
+}
+
+void BtRspDeclineFw::SharedCtor() {
+  _cached_size_ = 0;
+  rsp_ = 0;
+}
+
+BtRspDeclineFw::~BtRspDeclineFw() {
+  // @@protoc_insertion_point(destructor:BtRspDeclineFw)
+  SharedDtor();
+}
+
+void BtRspDeclineFw::SharedDtor() {
+}
+
+void BtRspDeclineFw::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* BtRspDeclineFw::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const BtRspDeclineFw& BtRspDeclineFw::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+BtRspDeclineFw* BtRspDeclineFw::New(::google::protobuf::Arena* arena) const {
+  BtRspDeclineFw* n = new BtRspDeclineFw;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void BtRspDeclineFw::Clear() {
+// @@protoc_insertion_point(message_clear_start:BtRspDeclineFw)
+  rsp_ = 0;
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool BtRspDeclineFw::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:BtRspDeclineFw)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional .WlanIpcCmdRsp rsp = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::WlanIpcCmdRsp_IsValid(value)) {
+            set_rsp(static_cast< ::WlanIpcCmdRsp >(value));
+          } else {
+            mutable_unknown_fields()->AddVarint(1, value);
+          }
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:BtRspDeclineFw)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:BtRspDeclineFw)
+  return false;
+#undef DO_
+}
+
+void BtRspDeclineFw::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:BtRspDeclineFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      1, this->rsp(), output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:BtRspDeclineFw)
+}
+
+::google::protobuf::uint8* BtRspDeclineFw::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:BtRspDeclineFw)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
+      1, this->rsp(), target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:BtRspDeclineFw)
+  return target;
+}
+
+size_t BtRspDeclineFw::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:BtRspDeclineFw)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  // optional .WlanIpcCmdRsp rsp = 1;
+  if (has_rsp()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rsp());
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void BtRspDeclineFw::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:BtRspDeclineFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  const BtRspDeclineFw* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const BtRspDeclineFw>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BtRspDeclineFw)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:BtRspDeclineFw)
+    MergeFrom(*source);
+  }
+}
+
+void BtRspDeclineFw::MergeFrom(const BtRspDeclineFw& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:BtRspDeclineFw)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  if (from.has_rsp()) {
+    set_rsp(from.rsp());
+  }
+}
+
+void BtRspDeclineFw::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:BtRspDeclineFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void BtRspDeclineFw::CopyFrom(const BtRspDeclineFw& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:BtRspDeclineFw)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool BtRspDeclineFw::IsInitialized() const {
+  return true;
+}
+
+void BtRspDeclineFw::Swap(BtRspDeclineFw* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void BtRspDeclineFw::InternalSwap(BtRspDeclineFw* other) {
+  std::swap(rsp_, other->rsp_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata BtRspDeclineFw::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// BtRspDeclineFw
+
+// optional .WlanIpcCmdRsp rsp = 1;
+bool BtRspDeclineFw::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void BtRspDeclineFw::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void BtRspDeclineFw::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void BtRspDeclineFw::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+::WlanIpcCmdRsp BtRspDeclineFw::rsp() const {
+  // @@protoc_insertion_point(field_get:BtRspDeclineFw.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+void BtRspDeclineFw::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:BtRspDeclineFw.rsp)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int WlanIpcCmdData::kReqScanFieldNumber;
+const int WlanIpcCmdData::kRspScanFieldNumber;
+const int WlanIpcCmdData::kReqConnectFieldNumber;
+const int WlanIpcCmdData::kRspConnectFieldNumber;
+const int WlanIpcCmdData::kReqDisconnectFieldNumber;
+const int WlanIpcCmdData::kRspDisconnectFieldNumber;
+const int WlanIpcCmdData::kReqRequestFwFieldNumber;
+const int WlanIpcCmdData::kRspRequestFwFieldNumber;
+const int WlanIpcCmdData::kReqDeclineFwFieldNumber;
+const int WlanIpcCmdData::kRspDeclineFwFieldNumber;
+const int WlanIpcCmdData::kScanResFieldNumber;
+const int WlanIpcCmdData::kStaStatusFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+WlanIpcCmdData::WlanIpcCmdData()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:WlanIpcCmdData)
+}
+WlanIpcCmdData::WlanIpcCmdData(const WlanIpcCmdData& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from.has_reqscan()) {
+    reqscan_ = new ::StaReqScan(*from.reqscan_);
+  } else {
+    reqscan_ = NULL;
+  }
+  if (from.has_rspscan()) {
+    rspscan_ = new ::StaRspScan(*from.rspscan_);
+  } else {
+    rspscan_ = NULL;
+  }
+  if (from.has_reqconnect()) {
+    reqconnect_ = new ::StaReqConnect(*from.reqconnect_);
+  } else {
+    reqconnect_ = NULL;
+  }
+  if (from.has_rspconnect()) {
+    rspconnect_ = new ::StaRspConnect(*from.rspconnect_);
+  } else {
+    rspconnect_ = NULL;
+  }
+  if (from.has_reqdisconnect()) {
+    reqdisconnect_ = new ::StaReqDisconnect(*from.reqdisconnect_);
+  } else {
+    reqdisconnect_ = NULL;
+  }
+  if (from.has_rspdisconnect()) {
+    rspdisconnect_ = new ::StaRspDisconnect(*from.rspdisconnect_);
+  } else {
+    rspdisconnect_ = NULL;
+  }
+  if (from.has_reqrequestfw()) {
+    reqrequestfw_ = new ::BtReqRequestFw(*from.reqrequestfw_);
+  } else {
+    reqrequestfw_ = NULL;
+  }
+  if (from.has_rsprequestfw()) {
+    rsprequestfw_ = new ::BtRspRequestFw(*from.rsprequestfw_);
+  } else {
+    rsprequestfw_ = NULL;
+  }
+  if (from.has_reqdeclinefw()) {
+    reqdeclinefw_ = new ::BtReqDeclineFw(*from.reqdeclinefw_);
+  } else {
+    reqdeclinefw_ = NULL;
+  }
+  if (from.has_rspdeclinefw()) {
+    rspdeclinefw_ = new ::BtRspDeclineFw(*from.rspdeclinefw_);
+  } else {
+    rspdeclinefw_ = NULL;
+  }
+  if (from.has_scanres()) {
+    scanres_ = new ::StaScanResults(*from.scanres_);
+  } else {
+    scanres_ = NULL;
+  }
+  if (from.has_stastatus()) {
+    stastatus_ = new ::StaStatusUpdate(*from.stastatus_);
+  } else {
+    stastatus_ = NULL;
+  }
+  // @@protoc_insertion_point(copy_constructor:WlanIpcCmdData)
+}
+
+void WlanIpcCmdData::SharedCtor() {
+  _cached_size_ = 0;
+  ::memset(&reqscan_, 0, reinterpret_cast<char*>(&stastatus_) -
+    reinterpret_cast<char*>(&reqscan_) + sizeof(stastatus_));
+}
+
+WlanIpcCmdData::~WlanIpcCmdData() {
+  // @@protoc_insertion_point(destructor:WlanIpcCmdData)
+  SharedDtor();
+}
+
+void WlanIpcCmdData::SharedDtor() {
+  if (this != internal_default_instance()) {
+    delete reqscan_;
+  }
+  if (this != internal_default_instance()) {
+    delete rspscan_;
+  }
+  if (this != internal_default_instance()) {
+    delete reqconnect_;
+  }
+  if (this != internal_default_instance()) {
+    delete rspconnect_;
+  }
+  if (this != internal_default_instance()) {
+    delete reqdisconnect_;
+  }
+  if (this != internal_default_instance()) {
+    delete rspdisconnect_;
+  }
+  if (this != internal_default_instance()) {
+    delete reqrequestfw_;
+  }
+  if (this != internal_default_instance()) {
+    delete rsprequestfw_;
+  }
+  if (this != internal_default_instance()) {
+    delete reqdeclinefw_;
+  }
+  if (this != internal_default_instance()) {
+    delete rspdeclinefw_;
+  }
+  if (this != internal_default_instance()) {
+    delete scanres_;
+  }
+  if (this != internal_default_instance()) {
+    delete stastatus_;
+  }
+}
+
+void WlanIpcCmdData::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* WlanIpcCmdData::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const WlanIpcCmdData& WlanIpcCmdData::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+WlanIpcCmdData* WlanIpcCmdData::New(::google::protobuf::Arena* arena) const {
+  WlanIpcCmdData* n = new WlanIpcCmdData;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void WlanIpcCmdData::Clear() {
+// @@protoc_insertion_point(message_clear_start:WlanIpcCmdData)
+  if (_has_bits_[0 / 32] & 255u) {
+    if (has_reqscan()) {
+      GOOGLE_DCHECK(reqscan_ != NULL);
+      reqscan_->::StaReqScan::Clear();
+    }
+    if (has_rspscan()) {
+      GOOGLE_DCHECK(rspscan_ != NULL);
+      rspscan_->::StaRspScan::Clear();
+    }
+    if (has_reqconnect()) {
+      GOOGLE_DCHECK(reqconnect_ != NULL);
+      reqconnect_->::StaReqConnect::Clear();
+    }
+    if (has_rspconnect()) {
+      GOOGLE_DCHECK(rspconnect_ != NULL);
+      rspconnect_->::StaRspConnect::Clear();
+    }
+    if (has_reqdisconnect()) {
+      GOOGLE_DCHECK(reqdisconnect_ != NULL);
+      reqdisconnect_->::StaReqDisconnect::Clear();
+    }
+    if (has_rspdisconnect()) {
+      GOOGLE_DCHECK(rspdisconnect_ != NULL);
+      rspdisconnect_->::StaRspDisconnect::Clear();
+    }
+    if (has_reqrequestfw()) {
+      GOOGLE_DCHECK(reqrequestfw_ != NULL);
+      reqrequestfw_->::BtReqRequestFw::Clear();
+    }
+    if (has_rsprequestfw()) {
+      GOOGLE_DCHECK(rsprequestfw_ != NULL);
+      rsprequestfw_->::BtRspRequestFw::Clear();
+    }
+  }
+  if (_has_bits_[8 / 32] & 3840u) {
+    if (has_reqdeclinefw()) {
+      GOOGLE_DCHECK(reqdeclinefw_ != NULL);
+      reqdeclinefw_->::BtReqDeclineFw::Clear();
+    }
+    if (has_rspdeclinefw()) {
+      GOOGLE_DCHECK(rspdeclinefw_ != NULL);
+      rspdeclinefw_->::BtRspDeclineFw::Clear();
+    }
+    if (has_scanres()) {
+      GOOGLE_DCHECK(scanres_ != NULL);
+      scanres_->::StaScanResults::Clear();
+    }
+    if (has_stastatus()) {
+      GOOGLE_DCHECK(stastatus_ != NULL);
+      stastatus_->::StaStatusUpdate::Clear();
+    }
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool WlanIpcCmdData::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:WlanIpcCmdData)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // optional .StaReqScan reqScan = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(10u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_reqscan()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaRspScan rspScan = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(18u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_rspscan()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaReqConnect reqConnect = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(26u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_reqconnect()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaRspConnect rspConnect = 4;
+      case 4: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(34u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_rspconnect()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaReqDisconnect reqDisconnect = 5;
+      case 5: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(42u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_reqdisconnect()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaRspDisconnect rspDisconnect = 6;
+      case 6: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(50u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_rspdisconnect()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .BtReqRequestFw reqRequestFw = 301;
+      case 301: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(2410u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_reqrequestfw()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .BtRspRequestFw rspRequestFw = 302;
+      case 302: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(2418u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_rsprequestfw()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .BtReqDeclineFw reqDeclineFw = 303;
+      case 303: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(2426u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_reqdeclinefw()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .BtRspDeclineFw rspDeclineFw = 304;
+      case 304: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(2434u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_rspdeclinefw()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaScanResults scanRes = 401;
+      case 401: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(3210u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_scanres()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .StaStatusUpdate staStatus = 402;
+      case 402: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(3218u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_stastatus()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:WlanIpcCmdData)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:WlanIpcCmdData)
+  return false;
+#undef DO_
+}
+
+void WlanIpcCmdData::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:WlanIpcCmdData)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .StaReqScan reqScan = 1;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      1, *this->reqscan_, output);
+  }
+
+  // optional .StaRspScan rspScan = 2;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      2, *this->rspscan_, output);
+  }
+
+  // optional .StaReqConnect reqConnect = 3;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      3, *this->reqconnect_, output);
+  }
+
+  // optional .StaRspConnect rspConnect = 4;
+  if (cached_has_bits & 0x00000008u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      4, *this->rspconnect_, output);
+  }
+
+  // optional .StaReqDisconnect reqDisconnect = 5;
+  if (cached_has_bits & 0x00000010u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      5, *this->reqdisconnect_, output);
+  }
+
+  // optional .StaRspDisconnect rspDisconnect = 6;
+  if (cached_has_bits & 0x00000020u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      6, *this->rspdisconnect_, output);
+  }
+
+  // optional .BtReqRequestFw reqRequestFw = 301;
+  if (cached_has_bits & 0x00000040u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      301, *this->reqrequestfw_, output);
+  }
+
+  // optional .BtRspRequestFw rspRequestFw = 302;
+  if (cached_has_bits & 0x00000080u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      302, *this->rsprequestfw_, output);
+  }
+
+  // optional .BtReqDeclineFw reqDeclineFw = 303;
+  if (cached_has_bits & 0x00000100u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      303, *this->reqdeclinefw_, output);
+  }
+
+  // optional .BtRspDeclineFw rspDeclineFw = 304;
+  if (cached_has_bits & 0x00000200u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      304, *this->rspdeclinefw_, output);
+  }
+
+  // optional .StaScanResults scanRes = 401;
+  if (cached_has_bits & 0x00000400u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      401, *this->scanres_, output);
+  }
+
+  // optional .StaStatusUpdate staStatus = 402;
+  if (cached_has_bits & 0x00000800u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      402, *this->stastatus_, output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:WlanIpcCmdData)
+}
+
+::google::protobuf::uint8* WlanIpcCmdData::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:WlanIpcCmdData)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // optional .StaReqScan reqScan = 1;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        1, *this->reqscan_, deterministic, target);
+  }
+
+  // optional .StaRspScan rspScan = 2;
+  if (cached_has_bits & 0x00000002u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        2, *this->rspscan_, deterministic, target);
+  }
+
+  // optional .StaReqConnect reqConnect = 3;
+  if (cached_has_bits & 0x00000004u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        3, *this->reqconnect_, deterministic, target);
+  }
+
+  // optional .StaRspConnect rspConnect = 4;
+  if (cached_has_bits & 0x00000008u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        4, *this->rspconnect_, deterministic, target);
+  }
+
+  // optional .StaReqDisconnect reqDisconnect = 5;
+  if (cached_has_bits & 0x00000010u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        5, *this->reqdisconnect_, deterministic, target);
+  }
+
+  // optional .StaRspDisconnect rspDisconnect = 6;
+  if (cached_has_bits & 0x00000020u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        6, *this->rspdisconnect_, deterministic, target);
+  }
+
+  // optional .BtReqRequestFw reqRequestFw = 301;
+  if (cached_has_bits & 0x00000040u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        301, *this->reqrequestfw_, deterministic, target);
+  }
+
+  // optional .BtRspRequestFw rspRequestFw = 302;
+  if (cached_has_bits & 0x00000080u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        302, *this->rsprequestfw_, deterministic, target);
+  }
+
+  // optional .BtReqDeclineFw reqDeclineFw = 303;
+  if (cached_has_bits & 0x00000100u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        303, *this->reqdeclinefw_, deterministic, target);
+  }
+
+  // optional .BtRspDeclineFw rspDeclineFw = 304;
+  if (cached_has_bits & 0x00000200u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        304, *this->rspdeclinefw_, deterministic, target);
+  }
+
+  // optional .StaScanResults scanRes = 401;
+  if (cached_has_bits & 0x00000400u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        401, *this->scanres_, deterministic, target);
+  }
+
+  // optional .StaStatusUpdate staStatus = 402;
+  if (cached_has_bits & 0x00000800u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        402, *this->stastatus_, deterministic, target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:WlanIpcCmdData)
+  return target;
+}
+
+size_t WlanIpcCmdData::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:WlanIpcCmdData)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (_has_bits_[0 / 32] & 255u) {
+    // optional .StaReqScan reqScan = 1;
+    if (has_reqscan()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->reqscan_);
+    }
+
+    // optional .StaRspScan rspScan = 2;
+    if (has_rspscan()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->rspscan_);
+    }
+
+    // optional .StaReqConnect reqConnect = 3;
+    if (has_reqconnect()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->reqconnect_);
+    }
+
+    // optional .StaRspConnect rspConnect = 4;
+    if (has_rspconnect()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->rspconnect_);
+    }
+
+    // optional .StaReqDisconnect reqDisconnect = 5;
+    if (has_reqdisconnect()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->reqdisconnect_);
+    }
+
+    // optional .StaRspDisconnect rspDisconnect = 6;
+    if (has_rspdisconnect()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->rspdisconnect_);
+    }
+
+    // optional .BtReqRequestFw reqRequestFw = 301;
+    if (has_reqrequestfw()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->reqrequestfw_);
+    }
+
+    // optional .BtRspRequestFw rspRequestFw = 302;
+    if (has_rsprequestfw()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->rsprequestfw_);
+    }
+
+  }
+  if (_has_bits_[8 / 32] & 3840u) {
+    // optional .BtReqDeclineFw reqDeclineFw = 303;
+    if (has_reqdeclinefw()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->reqdeclinefw_);
+    }
+
+    // optional .BtRspDeclineFw rspDeclineFw = 304;
+    if (has_rspdeclinefw()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->rspdeclinefw_);
+    }
+
+    // optional .StaScanResults scanRes = 401;
+    if (has_scanres()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->scanres_);
+    }
+
+    // optional .StaStatusUpdate staStatus = 402;
+    if (has_stastatus()) {
+      total_size += 2 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          *this->stastatus_);
+    }
+
+  }
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void WlanIpcCmdData::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:WlanIpcCmdData)
+  GOOGLE_DCHECK_NE(&from, this);
+  const WlanIpcCmdData* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const WlanIpcCmdData>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:WlanIpcCmdData)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:WlanIpcCmdData)
+    MergeFrom(*source);
+  }
+}
+
+void WlanIpcCmdData::MergeFrom(const WlanIpcCmdData& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:WlanIpcCmdData)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 255u) {
+    if (cached_has_bits & 0x00000001u) {
+      mutable_reqscan()->::StaReqScan::MergeFrom(from.reqscan());
+    }
+    if (cached_has_bits & 0x00000002u) {
+      mutable_rspscan()->::StaRspScan::MergeFrom(from.rspscan());
+    }
+    if (cached_has_bits & 0x00000004u) {
+      mutable_reqconnect()->::StaReqConnect::MergeFrom(from.reqconnect());
+    }
+    if (cached_has_bits & 0x00000008u) {
+      mutable_rspconnect()->::StaRspConnect::MergeFrom(from.rspconnect());
+    }
+    if (cached_has_bits & 0x00000010u) {
+      mutable_reqdisconnect()->::StaReqDisconnect::MergeFrom(from.reqdisconnect());
+    }
+    if (cached_has_bits & 0x00000020u) {
+      mutable_rspdisconnect()->::StaRspDisconnect::MergeFrom(from.rspdisconnect());
+    }
+    if (cached_has_bits & 0x00000040u) {
+      mutable_reqrequestfw()->::BtReqRequestFw::MergeFrom(from.reqrequestfw());
+    }
+    if (cached_has_bits & 0x00000080u) {
+      mutable_rsprequestfw()->::BtRspRequestFw::MergeFrom(from.rsprequestfw());
+    }
+  }
+  if (cached_has_bits & 3840u) {
+    if (cached_has_bits & 0x00000100u) {
+      mutable_reqdeclinefw()->::BtReqDeclineFw::MergeFrom(from.reqdeclinefw());
+    }
+    if (cached_has_bits & 0x00000200u) {
+      mutable_rspdeclinefw()->::BtRspDeclineFw::MergeFrom(from.rspdeclinefw());
+    }
+    if (cached_has_bits & 0x00000400u) {
+      mutable_scanres()->::StaScanResults::MergeFrom(from.scanres());
+    }
+    if (cached_has_bits & 0x00000800u) {
+      mutable_stastatus()->::StaStatusUpdate::MergeFrom(from.stastatus());
+    }
+  }
+}
+
+void WlanIpcCmdData::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:WlanIpcCmdData)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void WlanIpcCmdData::CopyFrom(const WlanIpcCmdData& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:WlanIpcCmdData)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool WlanIpcCmdData::IsInitialized() const {
+  return true;
+}
+
+void WlanIpcCmdData::Swap(WlanIpcCmdData* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void WlanIpcCmdData::InternalSwap(WlanIpcCmdData* other) {
+  std::swap(reqscan_, other->reqscan_);
+  std::swap(rspscan_, other->rspscan_);
+  std::swap(reqconnect_, other->reqconnect_);
+  std::swap(rspconnect_, other->rspconnect_);
+  std::swap(reqdisconnect_, other->reqdisconnect_);
+  std::swap(rspdisconnect_, other->rspdisconnect_);
+  std::swap(reqrequestfw_, other->reqrequestfw_);
+  std::swap(rsprequestfw_, other->rsprequestfw_);
+  std::swap(reqdeclinefw_, other->reqdeclinefw_);
+  std::swap(rspdeclinefw_, other->rspdeclinefw_);
+  std::swap(scanres_, other->scanres_);
+  std::swap(stastatus_, other->stastatus_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata WlanIpcCmdData::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// WlanIpcCmdData
+
+// optional .StaReqScan reqScan = 1;
+bool WlanIpcCmdData::has_reqscan() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void WlanIpcCmdData::set_has_reqscan() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void WlanIpcCmdData::clear_has_reqscan() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void WlanIpcCmdData::clear_reqscan() {
+  if (reqscan_ != NULL) reqscan_->::StaReqScan::Clear();
+  clear_has_reqscan();
+}
+const ::StaReqScan& WlanIpcCmdData::reqscan() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqScan)
+  return reqscan_ != NULL ? *reqscan_
+                         : *::StaReqScan::internal_default_instance();
+}
+::StaReqScan* WlanIpcCmdData::mutable_reqscan() {
+  set_has_reqscan();
+  if (reqscan_ == NULL) {
+    reqscan_ = new ::StaReqScan;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqScan)
+  return reqscan_;
+}
+::StaReqScan* WlanIpcCmdData::release_reqscan() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqScan)
+  clear_has_reqscan();
+  ::StaReqScan* temp = reqscan_;
+  reqscan_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_reqscan(::StaReqScan* reqscan) {
+  delete reqscan_;
+  reqscan_ = reqscan;
+  if (reqscan) {
+    set_has_reqscan();
+  } else {
+    clear_has_reqscan();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqScan)
+}
+
+// optional .StaRspScan rspScan = 2;
+bool WlanIpcCmdData::has_rspscan() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void WlanIpcCmdData::set_has_rspscan() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void WlanIpcCmdData::clear_has_rspscan() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void WlanIpcCmdData::clear_rspscan() {
+  if (rspscan_ != NULL) rspscan_->::StaRspScan::Clear();
+  clear_has_rspscan();
+}
+const ::StaRspScan& WlanIpcCmdData::rspscan() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspScan)
+  return rspscan_ != NULL ? *rspscan_
+                         : *::StaRspScan::internal_default_instance();
+}
+::StaRspScan* WlanIpcCmdData::mutable_rspscan() {
+  set_has_rspscan();
+  if (rspscan_ == NULL) {
+    rspscan_ = new ::StaRspScan;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspScan)
+  return rspscan_;
+}
+::StaRspScan* WlanIpcCmdData::release_rspscan() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspScan)
+  clear_has_rspscan();
+  ::StaRspScan* temp = rspscan_;
+  rspscan_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_rspscan(::StaRspScan* rspscan) {
+  delete rspscan_;
+  rspscan_ = rspscan;
+  if (rspscan) {
+    set_has_rspscan();
+  } else {
+    clear_has_rspscan();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspScan)
+}
+
+// optional .StaReqConnect reqConnect = 3;
+bool WlanIpcCmdData::has_reqconnect() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void WlanIpcCmdData::set_has_reqconnect() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void WlanIpcCmdData::clear_has_reqconnect() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void WlanIpcCmdData::clear_reqconnect() {
+  if (reqconnect_ != NULL) reqconnect_->::StaReqConnect::Clear();
+  clear_has_reqconnect();
+}
+const ::StaReqConnect& WlanIpcCmdData::reqconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqConnect)
+  return reqconnect_ != NULL ? *reqconnect_
+                         : *::StaReqConnect::internal_default_instance();
+}
+::StaReqConnect* WlanIpcCmdData::mutable_reqconnect() {
+  set_has_reqconnect();
+  if (reqconnect_ == NULL) {
+    reqconnect_ = new ::StaReqConnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqConnect)
+  return reqconnect_;
+}
+::StaReqConnect* WlanIpcCmdData::release_reqconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqConnect)
+  clear_has_reqconnect();
+  ::StaReqConnect* temp = reqconnect_;
+  reqconnect_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_reqconnect(::StaReqConnect* reqconnect) {
+  delete reqconnect_;
+  reqconnect_ = reqconnect;
+  if (reqconnect) {
+    set_has_reqconnect();
+  } else {
+    clear_has_reqconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqConnect)
+}
+
+// optional .StaRspConnect rspConnect = 4;
+bool WlanIpcCmdData::has_rspconnect() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+void WlanIpcCmdData::set_has_rspconnect() {
+  _has_bits_[0] |= 0x00000008u;
+}
+void WlanIpcCmdData::clear_has_rspconnect() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+void WlanIpcCmdData::clear_rspconnect() {
+  if (rspconnect_ != NULL) rspconnect_->::StaRspConnect::Clear();
+  clear_has_rspconnect();
+}
+const ::StaRspConnect& WlanIpcCmdData::rspconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspConnect)
+  return rspconnect_ != NULL ? *rspconnect_
+                         : *::StaRspConnect::internal_default_instance();
+}
+::StaRspConnect* WlanIpcCmdData::mutable_rspconnect() {
+  set_has_rspconnect();
+  if (rspconnect_ == NULL) {
+    rspconnect_ = new ::StaRspConnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspConnect)
+  return rspconnect_;
+}
+::StaRspConnect* WlanIpcCmdData::release_rspconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspConnect)
+  clear_has_rspconnect();
+  ::StaRspConnect* temp = rspconnect_;
+  rspconnect_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_rspconnect(::StaRspConnect* rspconnect) {
+  delete rspconnect_;
+  rspconnect_ = rspconnect;
+  if (rspconnect) {
+    set_has_rspconnect();
+  } else {
+    clear_has_rspconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspConnect)
+}
+
+// optional .StaReqDisconnect reqDisconnect = 5;
+bool WlanIpcCmdData::has_reqdisconnect() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+void WlanIpcCmdData::set_has_reqdisconnect() {
+  _has_bits_[0] |= 0x00000010u;
+}
+void WlanIpcCmdData::clear_has_reqdisconnect() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+void WlanIpcCmdData::clear_reqdisconnect() {
+  if (reqdisconnect_ != NULL) reqdisconnect_->::StaReqDisconnect::Clear();
+  clear_has_reqdisconnect();
+}
+const ::StaReqDisconnect& WlanIpcCmdData::reqdisconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqDisconnect)
+  return reqdisconnect_ != NULL ? *reqdisconnect_
+                         : *::StaReqDisconnect::internal_default_instance();
+}
+::StaReqDisconnect* WlanIpcCmdData::mutable_reqdisconnect() {
+  set_has_reqdisconnect();
+  if (reqdisconnect_ == NULL) {
+    reqdisconnect_ = new ::StaReqDisconnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqDisconnect)
+  return reqdisconnect_;
+}
+::StaReqDisconnect* WlanIpcCmdData::release_reqdisconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqDisconnect)
+  clear_has_reqdisconnect();
+  ::StaReqDisconnect* temp = reqdisconnect_;
+  reqdisconnect_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_reqdisconnect(::StaReqDisconnect* reqdisconnect) {
+  delete reqdisconnect_;
+  reqdisconnect_ = reqdisconnect;
+  if (reqdisconnect) {
+    set_has_reqdisconnect();
+  } else {
+    clear_has_reqdisconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqDisconnect)
+}
+
+// optional .StaRspDisconnect rspDisconnect = 6;
+bool WlanIpcCmdData::has_rspdisconnect() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+void WlanIpcCmdData::set_has_rspdisconnect() {
+  _has_bits_[0] |= 0x00000020u;
+}
+void WlanIpcCmdData::clear_has_rspdisconnect() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+void WlanIpcCmdData::clear_rspdisconnect() {
+  if (rspdisconnect_ != NULL) rspdisconnect_->::StaRspDisconnect::Clear();
+  clear_has_rspdisconnect();
+}
+const ::StaRspDisconnect& WlanIpcCmdData::rspdisconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspDisconnect)
+  return rspdisconnect_ != NULL ? *rspdisconnect_
+                         : *::StaRspDisconnect::internal_default_instance();
+}
+::StaRspDisconnect* WlanIpcCmdData::mutable_rspdisconnect() {
+  set_has_rspdisconnect();
+  if (rspdisconnect_ == NULL) {
+    rspdisconnect_ = new ::StaRspDisconnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspDisconnect)
+  return rspdisconnect_;
+}
+::StaRspDisconnect* WlanIpcCmdData::release_rspdisconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspDisconnect)
+  clear_has_rspdisconnect();
+  ::StaRspDisconnect* temp = rspdisconnect_;
+  rspdisconnect_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_rspdisconnect(::StaRspDisconnect* rspdisconnect) {
+  delete rspdisconnect_;
+  rspdisconnect_ = rspdisconnect;
+  if (rspdisconnect) {
+    set_has_rspdisconnect();
+  } else {
+    clear_has_rspdisconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspDisconnect)
+}
+
+// optional .BtReqRequestFw reqRequestFw = 301;
+bool WlanIpcCmdData::has_reqrequestfw() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+void WlanIpcCmdData::set_has_reqrequestfw() {
+  _has_bits_[0] |= 0x00000040u;
+}
+void WlanIpcCmdData::clear_has_reqrequestfw() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+void WlanIpcCmdData::clear_reqrequestfw() {
+  if (reqrequestfw_ != NULL) reqrequestfw_->::BtReqRequestFw::Clear();
+  clear_has_reqrequestfw();
+}
+const ::BtReqRequestFw& WlanIpcCmdData::reqrequestfw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqRequestFw)
+  return reqrequestfw_ != NULL ? *reqrequestfw_
+                         : *::BtReqRequestFw::internal_default_instance();
+}
+::BtReqRequestFw* WlanIpcCmdData::mutable_reqrequestfw() {
+  set_has_reqrequestfw();
+  if (reqrequestfw_ == NULL) {
+    reqrequestfw_ = new ::BtReqRequestFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqRequestFw)
+  return reqrequestfw_;
+}
+::BtReqRequestFw* WlanIpcCmdData::release_reqrequestfw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqRequestFw)
+  clear_has_reqrequestfw();
+  ::BtReqRequestFw* temp = reqrequestfw_;
+  reqrequestfw_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_reqrequestfw(::BtReqRequestFw* reqrequestfw) {
+  delete reqrequestfw_;
+  reqrequestfw_ = reqrequestfw;
+  if (reqrequestfw) {
+    set_has_reqrequestfw();
+  } else {
+    clear_has_reqrequestfw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqRequestFw)
+}
+
+// optional .BtRspRequestFw rspRequestFw = 302;
+bool WlanIpcCmdData::has_rsprequestfw() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+void WlanIpcCmdData::set_has_rsprequestfw() {
+  _has_bits_[0] |= 0x00000080u;
+}
+void WlanIpcCmdData::clear_has_rsprequestfw() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+void WlanIpcCmdData::clear_rsprequestfw() {
+  if (rsprequestfw_ != NULL) rsprequestfw_->::BtRspRequestFw::Clear();
+  clear_has_rsprequestfw();
+}
+const ::BtRspRequestFw& WlanIpcCmdData::rsprequestfw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspRequestFw)
+  return rsprequestfw_ != NULL ? *rsprequestfw_
+                         : *::BtRspRequestFw::internal_default_instance();
+}
+::BtRspRequestFw* WlanIpcCmdData::mutable_rsprequestfw() {
+  set_has_rsprequestfw();
+  if (rsprequestfw_ == NULL) {
+    rsprequestfw_ = new ::BtRspRequestFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspRequestFw)
+  return rsprequestfw_;
+}
+::BtRspRequestFw* WlanIpcCmdData::release_rsprequestfw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspRequestFw)
+  clear_has_rsprequestfw();
+  ::BtRspRequestFw* temp = rsprequestfw_;
+  rsprequestfw_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_rsprequestfw(::BtRspRequestFw* rsprequestfw) {
+  delete rsprequestfw_;
+  rsprequestfw_ = rsprequestfw;
+  if (rsprequestfw) {
+    set_has_rsprequestfw();
+  } else {
+    clear_has_rsprequestfw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspRequestFw)
+}
+
+// optional .BtReqDeclineFw reqDeclineFw = 303;
+bool WlanIpcCmdData::has_reqdeclinefw() const {
+  return (_has_bits_[0] & 0x00000100u) != 0;
+}
+void WlanIpcCmdData::set_has_reqdeclinefw() {
+  _has_bits_[0] |= 0x00000100u;
+}
+void WlanIpcCmdData::clear_has_reqdeclinefw() {
+  _has_bits_[0] &= ~0x00000100u;
+}
+void WlanIpcCmdData::clear_reqdeclinefw() {
+  if (reqdeclinefw_ != NULL) reqdeclinefw_->::BtReqDeclineFw::Clear();
+  clear_has_reqdeclinefw();
+}
+const ::BtReqDeclineFw& WlanIpcCmdData::reqdeclinefw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqDeclineFw)
+  return reqdeclinefw_ != NULL ? *reqdeclinefw_
+                         : *::BtReqDeclineFw::internal_default_instance();
+}
+::BtReqDeclineFw* WlanIpcCmdData::mutable_reqdeclinefw() {
+  set_has_reqdeclinefw();
+  if (reqdeclinefw_ == NULL) {
+    reqdeclinefw_ = new ::BtReqDeclineFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqDeclineFw)
+  return reqdeclinefw_;
+}
+::BtReqDeclineFw* WlanIpcCmdData::release_reqdeclinefw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqDeclineFw)
+  clear_has_reqdeclinefw();
+  ::BtReqDeclineFw* temp = reqdeclinefw_;
+  reqdeclinefw_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_reqdeclinefw(::BtReqDeclineFw* reqdeclinefw) {
+  delete reqdeclinefw_;
+  reqdeclinefw_ = reqdeclinefw;
+  if (reqdeclinefw) {
+    set_has_reqdeclinefw();
+  } else {
+    clear_has_reqdeclinefw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqDeclineFw)
+}
+
+// optional .BtRspDeclineFw rspDeclineFw = 304;
+bool WlanIpcCmdData::has_rspdeclinefw() const {
+  return (_has_bits_[0] & 0x00000200u) != 0;
+}
+void WlanIpcCmdData::set_has_rspdeclinefw() {
+  _has_bits_[0] |= 0x00000200u;
+}
+void WlanIpcCmdData::clear_has_rspdeclinefw() {
+  _has_bits_[0] &= ~0x00000200u;
+}
+void WlanIpcCmdData::clear_rspdeclinefw() {
+  if (rspdeclinefw_ != NULL) rspdeclinefw_->::BtRspDeclineFw::Clear();
+  clear_has_rspdeclinefw();
+}
+const ::BtRspDeclineFw& WlanIpcCmdData::rspdeclinefw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspDeclineFw)
+  return rspdeclinefw_ != NULL ? *rspdeclinefw_
+                         : *::BtRspDeclineFw::internal_default_instance();
+}
+::BtRspDeclineFw* WlanIpcCmdData::mutable_rspdeclinefw() {
+  set_has_rspdeclinefw();
+  if (rspdeclinefw_ == NULL) {
+    rspdeclinefw_ = new ::BtRspDeclineFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspDeclineFw)
+  return rspdeclinefw_;
+}
+::BtRspDeclineFw* WlanIpcCmdData::release_rspdeclinefw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspDeclineFw)
+  clear_has_rspdeclinefw();
+  ::BtRspDeclineFw* temp = rspdeclinefw_;
+  rspdeclinefw_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_rspdeclinefw(::BtRspDeclineFw* rspdeclinefw) {
+  delete rspdeclinefw_;
+  rspdeclinefw_ = rspdeclinefw;
+  if (rspdeclinefw) {
+    set_has_rspdeclinefw();
+  } else {
+    clear_has_rspdeclinefw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspDeclineFw)
+}
+
+// optional .StaScanResults scanRes = 401;
+bool WlanIpcCmdData::has_scanres() const {
+  return (_has_bits_[0] & 0x00000400u) != 0;
+}
+void WlanIpcCmdData::set_has_scanres() {
+  _has_bits_[0] |= 0x00000400u;
+}
+void WlanIpcCmdData::clear_has_scanres() {
+  _has_bits_[0] &= ~0x00000400u;
+}
+void WlanIpcCmdData::clear_scanres() {
+  if (scanres_ != NULL) scanres_->::StaScanResults::Clear();
+  clear_has_scanres();
+}
+const ::StaScanResults& WlanIpcCmdData::scanres() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.scanRes)
+  return scanres_ != NULL ? *scanres_
+                         : *::StaScanResults::internal_default_instance();
+}
+::StaScanResults* WlanIpcCmdData::mutable_scanres() {
+  set_has_scanres();
+  if (scanres_ == NULL) {
+    scanres_ = new ::StaScanResults;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.scanRes)
+  return scanres_;
+}
+::StaScanResults* WlanIpcCmdData::release_scanres() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.scanRes)
+  clear_has_scanres();
+  ::StaScanResults* temp = scanres_;
+  scanres_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_scanres(::StaScanResults* scanres) {
+  delete scanres_;
+  scanres_ = scanres;
+  if (scanres) {
+    set_has_scanres();
+  } else {
+    clear_has_scanres();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.scanRes)
+}
+
+// optional .StaStatusUpdate staStatus = 402;
+bool WlanIpcCmdData::has_stastatus() const {
+  return (_has_bits_[0] & 0x00000800u) != 0;
+}
+void WlanIpcCmdData::set_has_stastatus() {
+  _has_bits_[0] |= 0x00000800u;
+}
+void WlanIpcCmdData::clear_has_stastatus() {
+  _has_bits_[0] &= ~0x00000800u;
+}
+void WlanIpcCmdData::clear_stastatus() {
+  if (stastatus_ != NULL) stastatus_->::StaStatusUpdate::Clear();
+  clear_has_stastatus();
+}
+const ::StaStatusUpdate& WlanIpcCmdData::stastatus() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.staStatus)
+  return stastatus_ != NULL ? *stastatus_
+                         : *::StaStatusUpdate::internal_default_instance();
+}
+::StaStatusUpdate* WlanIpcCmdData::mutable_stastatus() {
+  set_has_stastatus();
+  if (stastatus_ == NULL) {
+    stastatus_ = new ::StaStatusUpdate;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.staStatus)
+  return stastatus_;
+}
+::StaStatusUpdate* WlanIpcCmdData::release_stastatus() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.staStatus)
+  clear_has_stastatus();
+  ::StaStatusUpdate* temp = stastatus_;
+  stastatus_ = NULL;
+  return temp;
+}
+void WlanIpcCmdData::set_allocated_stastatus(::StaStatusUpdate* stastatus) {
+  delete stastatus_;
+  stastatus_ = stastatus;
+  if (stastatus) {
+    set_has_stastatus();
+  } else {
+    clear_has_stastatus();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.staStatus)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// ===================================================================
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1900
+const int WlanIpcMsg::kVerFieldNumber;
+const int WlanIpcMsg::kTypeFieldNumber;
+const int WlanIpcMsg::kDataFieldNumber;
+#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
+
+WlanIpcMsg::WlanIpcMsg()
+  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
+  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
+    protobuf_wlan_5fipc_2eproto::InitDefaults();
+  }
+  SharedCtor();
+  // @@protoc_insertion_point(constructor:WlanIpcMsg)
+}
+WlanIpcMsg::WlanIpcMsg(const WlanIpcMsg& from)
+  : ::google::protobuf::Message(),
+      _internal_metadata_(NULL),
+      _has_bits_(from._has_bits_),
+      _cached_size_(0) {
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  if (from.has_data()) {
+    data_ = new ::WlanIpcCmdData(*from.data_);
+  } else {
+    data_ = NULL;
+  }
+  ::memcpy(&ver_, &from.ver_,
+    reinterpret_cast<char*>(&type_) -
+    reinterpret_cast<char*>(&ver_) + sizeof(type_));
+  // @@protoc_insertion_point(copy_constructor:WlanIpcMsg)
+}
+
+void WlanIpcMsg::SharedCtor() {
+  _cached_size_ = 0;
+  ::memset(&data_, 0, reinterpret_cast<char*>(&ver_) -
+    reinterpret_cast<char*>(&data_) + sizeof(ver_));
+  type_ = 1;
+}
+
+WlanIpcMsg::~WlanIpcMsg() {
+  // @@protoc_insertion_point(destructor:WlanIpcMsg)
+  SharedDtor();
+}
+
+void WlanIpcMsg::SharedDtor() {
+  if (this != internal_default_instance()) {
+    delete data_;
+  }
+}
+
+void WlanIpcMsg::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const ::google::protobuf::Descriptor* WlanIpcMsg::descriptor() {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
+}
+
+const WlanIpcMsg& WlanIpcMsg::default_instance() {
+  protobuf_wlan_5fipc_2eproto::InitDefaults();
+  return *internal_default_instance();
+}
+
+WlanIpcMsg* WlanIpcMsg::New(::google::protobuf::Arena* arena) const {
+  WlanIpcMsg* n = new WlanIpcMsg;
+  if (arena != NULL) {
+    arena->Own(n);
+  }
+  return n;
+}
+
+void WlanIpcMsg::Clear() {
+// @@protoc_insertion_point(message_clear_start:WlanIpcMsg)
+  if (has_data()) {
+    GOOGLE_DCHECK(data_ != NULL);
+    data_->::WlanIpcCmdData::Clear();
+  }
+  if (_has_bits_[0 / 32] & 6u) {
+    ver_ = 0;
+    type_ = 1;
+  }
+  _has_bits_.Clear();
+  _internal_metadata_.Clear();
+}
+
+bool WlanIpcMsg::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
+  ::google::protobuf::uint32 tag;
+  // @@protoc_insertion_point(parse_start:WlanIpcMsg)
+  for (;;) {
+    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
+    tag = p.first;
+    if (!p.second) goto handle_unusual;
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // required int32 ver = 1;
+      case 1: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(8u)) {
+          set_has_ver();
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &ver_)));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // required .WlanIpcCmdType type = 2;
+      case 2: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(16u)) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::WlanIpcCmdType_IsValid(value)) {
+            set_type(static_cast< ::WlanIpcCmdType >(value));
+          } else {
+            mutable_unknown_fields()->AddVarint(2, value);
+          }
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      // optional .WlanIpcCmdData data = 3;
+      case 3: {
+        if (static_cast< ::google::protobuf::uint8>(tag) ==
+            static_cast< ::google::protobuf::uint8>(26u)) {
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_data()));
+        } else {
+          goto handle_unusual;
+        }
+        break;
+      }
+
+      default: {
+      handle_unusual:
+        if (tag == 0 ||
+            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          goto success;
+        }
+        DO_(::google::protobuf::internal::WireFormat::SkipField(
+              input, tag, mutable_unknown_fields()));
+        break;
+      }
+    }
+  }
+success:
+  // @@protoc_insertion_point(parse_success:WlanIpcMsg)
+  return true;
+failure:
+  // @@protoc_insertion_point(parse_failure:WlanIpcMsg)
+  return false;
+#undef DO_
+}
+
+void WlanIpcMsg::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // @@protoc_insertion_point(serialize_start:WlanIpcMsg)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // required int32 ver = 1;
+  if (cached_has_bits & 0x00000002u) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ver(), output);
+  }
+
+  // required .WlanIpcCmdType type = 2;
+  if (cached_has_bits & 0x00000004u) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      2, this->type(), output);
+  }
+
+  // optional .WlanIpcCmdData data = 3;
+  if (cached_has_bits & 0x00000001u) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
+      3, *this->data_, output);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
+        unknown_fields(), output);
+  }
+  // @@protoc_insertion_point(serialize_end:WlanIpcMsg)
+}
+
+::google::protobuf::uint8* WlanIpcMsg::InternalSerializeWithCachedSizesToArray(
+    bool deterministic, ::google::protobuf::uint8* target) const {
+  // @@protoc_insertion_point(serialize_to_array_start:WlanIpcMsg)
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = _has_bits_[0];
+  // required int32 ver = 1;
+  if (cached_has_bits & 0x00000002u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ver(), target);
+  }
+
+  // required .WlanIpcCmdType type = 2;
+  if (cached_has_bits & 0x00000004u) {
+    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
+      2, this->type(), target);
+  }
+
+  // optional .WlanIpcCmdData data = 3;
+  if (cached_has_bits & 0x00000001u) {
+    target = ::google::protobuf::internal::WireFormatLite::
+      InternalWriteMessageNoVirtualToArray(
+        3, *this->data_, deterministic, target);
+  }
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
+        unknown_fields(), target);
+  }
+  // @@protoc_insertion_point(serialize_to_array_end:WlanIpcMsg)
+  return target;
+}
+
+size_t WlanIpcMsg::RequiredFieldsByteSizeFallback() const {
+// @@protoc_insertion_point(required_fields_byte_size_fallback_start:WlanIpcMsg)
+  size_t total_size = 0;
+
+  if (has_ver()) {
+    // required int32 ver = 1;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::Int32Size(
+        this->ver());
+  }
+
+  if (has_type()) {
+    // required .WlanIpcCmdType type = 2;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
+  }
+
+  return total_size;
+}
+size_t WlanIpcMsg::ByteSizeLong() const {
+// @@protoc_insertion_point(message_byte_size_start:WlanIpcMsg)
+  size_t total_size = 0;
+
+  if (_internal_metadata_.have_unknown_fields()) {
+    total_size +=
+      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
+        unknown_fields());
+  }
+  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
+    // required int32 ver = 1;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::Int32Size(
+        this->ver());
+
+    // required .WlanIpcCmdType type = 2;
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
+
+  } else {
+    total_size += RequiredFieldsByteSizeFallback();
+  }
+  // optional .WlanIpcCmdData data = 3;
+  if (has_data()) {
+    total_size += 1 +
+      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+        *this->data_);
+  }
+
+  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = cached_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void WlanIpcMsg::MergeFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_merge_from_start:WlanIpcMsg)
+  GOOGLE_DCHECK_NE(&from, this);
+  const WlanIpcMsg* source =
+      ::google::protobuf::internal::DynamicCastToGenerated<const WlanIpcMsg>(
+          &from);
+  if (source == NULL) {
+  // @@protoc_insertion_point(generalized_merge_from_cast_fail:WlanIpcMsg)
+    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
+  } else {
+  // @@protoc_insertion_point(generalized_merge_from_cast_success:WlanIpcMsg)
+    MergeFrom(*source);
+  }
+}
+
+void WlanIpcMsg::MergeFrom(const WlanIpcMsg& from) {
+// @@protoc_insertion_point(class_specific_merge_from_start:WlanIpcMsg)
+  GOOGLE_DCHECK_NE(&from, this);
+  _internal_metadata_.MergeFrom(from._internal_metadata_);
+  ::google::protobuf::uint32 cached_has_bits = 0;
+  (void) cached_has_bits;
+
+  cached_has_bits = from._has_bits_[0];
+  if (cached_has_bits & 7u) {
+    if (cached_has_bits & 0x00000001u) {
+      mutable_data()->::WlanIpcCmdData::MergeFrom(from.data());
+    }
+    if (cached_has_bits & 0x00000002u) {
+      ver_ = from.ver_;
+    }
+    if (cached_has_bits & 0x00000004u) {
+      type_ = from.type_;
+    }
+    _has_bits_[0] |= cached_has_bits;
+  }
+}
+
+void WlanIpcMsg::CopyFrom(const ::google::protobuf::Message& from) {
+// @@protoc_insertion_point(generalized_copy_from_start:WlanIpcMsg)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+void WlanIpcMsg::CopyFrom(const WlanIpcMsg& from) {
+// @@protoc_insertion_point(class_specific_copy_from_start:WlanIpcMsg)
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool WlanIpcMsg::IsInitialized() const {
+  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
+  return true;
+}
+
+void WlanIpcMsg::Swap(WlanIpcMsg* other) {
+  if (other == this) return;
+  InternalSwap(other);
+}
+void WlanIpcMsg::InternalSwap(WlanIpcMsg* other) {
+  std::swap(data_, other->data_);
+  std::swap(ver_, other->ver_);
+  std::swap(type_, other->type_);
+  std::swap(_has_bits_[0], other->_has_bits_[0]);
+  _internal_metadata_.Swap(&other->_internal_metadata_);
+  std::swap(_cached_size_, other->_cached_size_);
+}
+
+::google::protobuf::Metadata WlanIpcMsg::GetMetadata() const {
+  protobuf_wlan_5fipc_2eproto::protobuf_AssignDescriptorsOnce();
+  return protobuf_wlan_5fipc_2eproto::file_level_metadata[kIndexInFileMessages];
+}
+
+#if PROTOBUF_INLINE_NOT_IN_HEADERS
+// WlanIpcMsg
+
+// required int32 ver = 1;
+bool WlanIpcMsg::has_ver() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+void WlanIpcMsg::set_has_ver() {
+  _has_bits_[0] |= 0x00000002u;
+}
+void WlanIpcMsg::clear_has_ver() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+void WlanIpcMsg::clear_ver() {
+  ver_ = 0;
+  clear_has_ver();
+}
+::google::protobuf::int32 WlanIpcMsg::ver() const {
+  // @@protoc_insertion_point(field_get:WlanIpcMsg.ver)
+  return ver_;
+}
+void WlanIpcMsg::set_ver(::google::protobuf::int32 value) {
+  set_has_ver();
+  ver_ = value;
+  // @@protoc_insertion_point(field_set:WlanIpcMsg.ver)
+}
+
+// required .WlanIpcCmdType type = 2;
+bool WlanIpcMsg::has_type() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+void WlanIpcMsg::set_has_type() {
+  _has_bits_[0] |= 0x00000004u;
+}
+void WlanIpcMsg::clear_has_type() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+void WlanIpcMsg::clear_type() {
+  type_ = 1;
+  clear_has_type();
+}
+::WlanIpcCmdType WlanIpcMsg::type() const {
+  // @@protoc_insertion_point(field_get:WlanIpcMsg.type)
+  return static_cast< ::WlanIpcCmdType >(type_);
+}
+void WlanIpcMsg::set_type(::WlanIpcCmdType value) {
+  assert(::WlanIpcCmdType_IsValid(value));
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:WlanIpcMsg.type)
+}
+
+// optional .WlanIpcCmdData data = 3;
+bool WlanIpcMsg::has_data() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+void WlanIpcMsg::set_has_data() {
+  _has_bits_[0] |= 0x00000001u;
+}
+void WlanIpcMsg::clear_has_data() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+void WlanIpcMsg::clear_data() {
+  if (data_ != NULL) data_->::WlanIpcCmdData::Clear();
+  clear_has_data();
+}
+const ::WlanIpcCmdData& WlanIpcMsg::data() const {
+  // @@protoc_insertion_point(field_get:WlanIpcMsg.data)
+  return data_ != NULL ? *data_
+                         : *::WlanIpcCmdData::internal_default_instance();
+}
+::WlanIpcCmdData* WlanIpcMsg::mutable_data() {
+  set_has_data();
+  if (data_ == NULL) {
+    data_ = new ::WlanIpcCmdData;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcMsg.data)
+  return data_;
+}
+::WlanIpcCmdData* WlanIpcMsg::release_data() {
+  // @@protoc_insertion_point(field_release:WlanIpcMsg.data)
+  clear_has_data();
+  ::WlanIpcCmdData* temp = data_;
+  data_ = NULL;
+  return temp;
+}
+void WlanIpcMsg::set_allocated_data(::WlanIpcCmdData* data) {
+  delete data_;
+  data_ = data;
+  if (data) {
+    set_has_data();
+  } else {
+    clear_has_data();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcMsg.data)
+}
+
+#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
+
+// @@protoc_insertion_point(namespace_scope)
+
+// @@protoc_insertion_point(global_scope)
diff -Ndur '--exclude=.git' ./shared/wlan_ipc/proto/wlan_ipc.pb.h /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/shared/wlan_ipc/proto/wlan_ipc.pb.h
--- ./shared/wlan_ipc/proto/wlan_ipc.pb.h	1969-12-31 19:00:00.000000000 -0500
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/shared/wlan_ipc/proto/wlan_ipc.pb.h	2018-04-12 13:57:49.692000000 -0400
@@ -0,0 +1,6025 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: wlan_ipc.proto
+
+#ifndef PROTOBUF_wlan_5fipc_2eproto__INCLUDED
+#define PROTOBUF_wlan_5fipc_2eproto__INCLUDED
+
+#include <string>
+
+#include <google/protobuf/stubs/common.h>
+
+#if GOOGLE_PROTOBUF_VERSION < 3003000
+#error This file was generated by a newer version of protoc which is
+#error incompatible with your Protocol Buffer headers.  Please update
+#error your headers.
+#endif
+#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
+#error This file was generated by an older version of protoc which is
+#error incompatible with your Protocol Buffer headers.  Please
+#error regenerate this file with a newer version of protoc.
+#endif
+
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/arenastring.h>
+#include <google/protobuf/generated_message_table_driven.h>
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/metadata.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
+#include <google/protobuf/extension_set.h>  // IWYU pragma: export
+#include <google/protobuf/generated_enum_reflection.h>
+#include <google/protobuf/unknown_field_set.h>
+// @@protoc_insertion_point(includes)
+class BtReqDeclineFw;
+class BtReqDeclineFwDefaultTypeInternal;
+extern BtReqDeclineFwDefaultTypeInternal _BtReqDeclineFw_default_instance_;
+class BtReqRequestFw;
+class BtReqRequestFwDefaultTypeInternal;
+extern BtReqRequestFwDefaultTypeInternal _BtReqRequestFw_default_instance_;
+class BtRspDeclineFw;
+class BtRspDeclineFwDefaultTypeInternal;
+extern BtRspDeclineFwDefaultTypeInternal _BtRspDeclineFw_default_instance_;
+class BtRspRequestFw;
+class BtRspRequestFwDefaultTypeInternal;
+extern BtRspRequestFwDefaultTypeInternal _BtRspRequestFw_default_instance_;
+class StaEapSec;
+class StaEapSecDefaultTypeInternal;
+extern StaEapSecDefaultTypeInternal _StaEapSec_default_instance_;
+class StaPskSec;
+class StaPskSecDefaultTypeInternal;
+extern StaPskSecDefaultTypeInternal _StaPskSec_default_instance_;
+class StaReqConnect;
+class StaReqConnectDefaultTypeInternal;
+extern StaReqConnectDefaultTypeInternal _StaReqConnect_default_instance_;
+class StaReqDisconnect;
+class StaReqDisconnectDefaultTypeInternal;
+extern StaReqDisconnectDefaultTypeInternal _StaReqDisconnect_default_instance_;
+class StaReqScan;
+class StaReqScanDefaultTypeInternal;
+extern StaReqScanDefaultTypeInternal _StaReqScan_default_instance_;
+class StaRspConnect;
+class StaRspConnectDefaultTypeInternal;
+extern StaRspConnectDefaultTypeInternal _StaRspConnect_default_instance_;
+class StaRspDisconnect;
+class StaRspDisconnectDefaultTypeInternal;
+extern StaRspDisconnectDefaultTypeInternal _StaRspDisconnect_default_instance_;
+class StaRspScan;
+class StaRspScanDefaultTypeInternal;
+extern StaRspScanDefaultTypeInternal _StaRspScan_default_instance_;
+class StaScanResult;
+class StaScanResultDefaultTypeInternal;
+extern StaScanResultDefaultTypeInternal _StaScanResult_default_instance_;
+class StaScanResults;
+class StaScanResultsDefaultTypeInternal;
+extern StaScanResultsDefaultTypeInternal _StaScanResults_default_instance_;
+class StaStaticIpv4;
+class StaStaticIpv4DefaultTypeInternal;
+extern StaStaticIpv4DefaultTypeInternal _StaStaticIpv4_default_instance_;
+class StaStaticIpv6;
+class StaStaticIpv6DefaultTypeInternal;
+extern StaStaticIpv6DefaultTypeInternal _StaStaticIpv6_default_instance_;
+class StaStatusUpdate;
+class StaStatusUpdateDefaultTypeInternal;
+extern StaStatusUpdateDefaultTypeInternal _StaStatusUpdate_default_instance_;
+class StaWepSec;
+class StaWepSecDefaultTypeInternal;
+extern StaWepSecDefaultTypeInternal _StaWepSec_default_instance_;
+class StaWpsSec;
+class StaWpsSecDefaultTypeInternal;
+extern StaWpsSecDefaultTypeInternal _StaWpsSec_default_instance_;
+class WlanIpcCmdData;
+class WlanIpcCmdDataDefaultTypeInternal;
+extern WlanIpcCmdDataDefaultTypeInternal _WlanIpcCmdData_default_instance_;
+class WlanIpcMsg;
+class WlanIpcMsgDefaultTypeInternal;
+extern WlanIpcMsgDefaultTypeInternal _WlanIpcMsg_default_instance_;
+
+namespace protobuf_wlan_5fipc_2eproto {
+// Internal implementation detail -- do not call these.
+struct TableStruct {
+  static const ::google::protobuf::internal::ParseTableField entries[];
+  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
+  static const ::google::protobuf::internal::ParseTable schema[];
+  static const ::google::protobuf::uint32 offsets[];
+  static void InitDefaultsImpl();
+  static void Shutdown();
+};
+void AddDescriptors();
+void InitDefaults();
+}  // namespace protobuf_wlan_5fipc_2eproto
+
+enum WlanIpcCmdType {
+  STA_REQ_SCAN = 1,
+  STA_RSP_SCAN = 2,
+  STA_REQ_CONNECT = 3,
+  STA_RSP_CONNECT = 4,
+  STA_REQ_DISCONNECT = 5,
+  STA_RSP_DISCONNECT = 6,
+  BT_REQ_REQUEST_FW = 301,
+  BT_RSP_REQUEST_FW = 302,
+  BT_REQ_DECLINE_FW = 303,
+  BT_RSP_DECLINE_FW = 304,
+  BT_REQ_RESET_FW = 305,
+  BT_RSP_RESET_FW = 306,
+  STA_SCAN_RESULTS = 401,
+  STA_STATUS_UPDATE = 402,
+  STA_PKT_STATS_UPDATE = 403
+};
+bool WlanIpcCmdType_IsValid(int value);
+const WlanIpcCmdType WlanIpcCmdType_MIN = STA_REQ_SCAN;
+const WlanIpcCmdType WlanIpcCmdType_MAX = STA_PKT_STATS_UPDATE;
+const int WlanIpcCmdType_ARRAYSIZE = WlanIpcCmdType_MAX + 1;
+
+const ::google::protobuf::EnumDescriptor* WlanIpcCmdType_descriptor();
+inline const ::std::string& WlanIpcCmdType_Name(WlanIpcCmdType value) {
+  return ::google::protobuf::internal::NameOfEnum(
+    WlanIpcCmdType_descriptor(), value);
+}
+inline bool WlanIpcCmdType_Parse(
+    const ::std::string& name, WlanIpcCmdType* value) {
+  return ::google::protobuf::internal::ParseNamedEnum<WlanIpcCmdType>(
+    WlanIpcCmdType_descriptor(), name, value);
+}
+enum WlanIpcCmdRsp {
+  RSP_SUCCESS = 0,
+  RSP_ERROR = 1
+};
+bool WlanIpcCmdRsp_IsValid(int value);
+const WlanIpcCmdRsp WlanIpcCmdRsp_MIN = RSP_SUCCESS;
+const WlanIpcCmdRsp WlanIpcCmdRsp_MAX = RSP_ERROR;
+const int WlanIpcCmdRsp_ARRAYSIZE = WlanIpcCmdRsp_MAX + 1;
+
+const ::google::protobuf::EnumDescriptor* WlanIpcCmdRsp_descriptor();
+inline const ::std::string& WlanIpcCmdRsp_Name(WlanIpcCmdRsp value) {
+  return ::google::protobuf::internal::NameOfEnum(
+    WlanIpcCmdRsp_descriptor(), value);
+}
+inline bool WlanIpcCmdRsp_Parse(
+    const ::std::string& name, WlanIpcCmdRsp* value) {
+  return ::google::protobuf::internal::ParseNamedEnum<WlanIpcCmdRsp>(
+    WlanIpcCmdRsp_descriptor(), name, value);
+}
+enum StaScanType {
+  SCAN_TYPE_ACTIVE = 0,
+  SCAN_TYPE_PASSIVE = 1
+};
+bool StaScanType_IsValid(int value);
+const StaScanType StaScanType_MIN = SCAN_TYPE_ACTIVE;
+const StaScanType StaScanType_MAX = SCAN_TYPE_PASSIVE;
+const int StaScanType_ARRAYSIZE = StaScanType_MAX + 1;
+
+const ::google::protobuf::EnumDescriptor* StaScanType_descriptor();
+inline const ::std::string& StaScanType_Name(StaScanType value) {
+  return ::google::protobuf::internal::NameOfEnum(
+    StaScanType_descriptor(), value);
+}
+inline bool StaScanType_Parse(
+    const ::std::string& name, StaScanType* value) {
+  return ::google::protobuf::internal::ParseNamedEnum<StaScanType>(
+    StaScanType_descriptor(), name, value);
+}
+// ===================================================================
+
+class StaReqScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaReqScan) */ {
+ public:
+  StaReqScan();
+  virtual ~StaReqScan();
+
+  StaReqScan(const StaReqScan& from);
+
+  inline StaReqScan& operator=(const StaReqScan& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaReqScan& default_instance();
+
+  static inline const StaReqScan* internal_default_instance() {
+    return reinterpret_cast<const StaReqScan*>(
+               &_StaReqScan_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    0;
+
+  void Swap(StaReqScan* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaReqScan* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaReqScan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaReqScan& from);
+  void MergeFrom(const StaReqScan& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaReqScan* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // repeated bytes ssid = 1;
+  int ssid_size() const;
+  void clear_ssid();
+  static const int kSsidFieldNumber = 1;
+  const ::std::string& ssid(int index) const;
+  ::std::string* mutable_ssid(int index);
+  void set_ssid(int index, const ::std::string& value);
+  #if LANG_CXX11
+  void set_ssid(int index, ::std::string&& value);
+  #endif
+  void set_ssid(int index, const char* value);
+  void set_ssid(int index, const void* value, size_t size);
+  ::std::string* add_ssid();
+  void add_ssid(const ::std::string& value);
+  #if LANG_CXX11
+  void add_ssid(::std::string&& value);
+  #endif
+  void add_ssid(const char* value);
+  void add_ssid(const void* value, size_t size);
+  const ::google::protobuf::RepeatedPtrField< ::std::string>& ssid() const;
+  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ssid();
+
+  // repeated uint32 channel = 2;
+  int channel_size() const;
+  void clear_channel();
+  static const int kChannelFieldNumber = 2;
+  ::google::protobuf::uint32 channel(int index) const;
+  void set_channel(int index, ::google::protobuf::uint32 value);
+  void add_channel(::google::protobuf::uint32 value);
+  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
+      channel() const;
+  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
+      mutable_channel();
+
+  // optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+  bool has_type() const;
+  void clear_type();
+  static const int kTypeFieldNumber = 3;
+  ::StaScanType type() const;
+  void set_type(::StaScanType value);
+
+  // @@protoc_insertion_point(class_scope:StaReqScan)
+ private:
+  void set_has_type();
+  void clear_has_type();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::RepeatedPtrField< ::std::string> ssid_;
+  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_;
+  int type_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaRspScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaRspScan) */ {
+ public:
+  StaRspScan();
+  virtual ~StaRspScan();
+
+  StaRspScan(const StaRspScan& from);
+
+  inline StaRspScan& operator=(const StaRspScan& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaRspScan& default_instance();
+
+  static inline const StaRspScan* internal_default_instance() {
+    return reinterpret_cast<const StaRspScan*>(
+               &_StaRspScan_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    1;
+
+  void Swap(StaRspScan* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaRspScan* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaRspScan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaRspScan& from);
+  void MergeFrom(const StaRspScan& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaRspScan* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional int32 scan_id = 2;
+  bool has_scan_id() const;
+  void clear_scan_id();
+  static const int kScanIdFieldNumber = 2;
+  ::google::protobuf::int32 scan_id() const;
+  void set_scan_id(::google::protobuf::int32 value);
+
+  // @@protoc_insertion_point(class_scope:StaRspScan)
+ private:
+  void set_has_scan_id();
+  void clear_has_scan_id();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::int32 scan_id_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaScanResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaScanResult) */ {
+ public:
+  StaScanResult();
+  virtual ~StaScanResult();
+
+  StaScanResult(const StaScanResult& from);
+
+  inline StaScanResult& operator=(const StaScanResult& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaScanResult& default_instance();
+
+  static inline const StaScanResult* internal_default_instance() {
+    return reinterpret_cast<const StaScanResult*>(
+               &_StaScanResult_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    2;
+
+  void Swap(StaScanResult* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaScanResult* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaScanResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaScanResult& from);
+  void MergeFrom(const StaScanResult& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaScanResult* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional bytes ssid = 1;
+  bool has_ssid() const;
+  void clear_ssid();
+  static const int kSsidFieldNumber = 1;
+  const ::std::string& ssid() const;
+  void set_ssid(const ::std::string& value);
+  #if LANG_CXX11
+  void set_ssid(::std::string&& value);
+  #endif
+  void set_ssid(const char* value);
+  void set_ssid(const void* value, size_t size);
+  ::std::string* mutable_ssid();
+  ::std::string* release_ssid();
+  void set_allocated_ssid(::std::string* ssid);
+
+  // optional bytes bssid = 2;
+  bool has_bssid() const;
+  void clear_bssid();
+  static const int kBssidFieldNumber = 2;
+  const ::std::string& bssid() const;
+  void set_bssid(const ::std::string& value);
+  #if LANG_CXX11
+  void set_bssid(::std::string&& value);
+  #endif
+  void set_bssid(const char* value);
+  void set_bssid(const void* value, size_t size);
+  ::std::string* mutable_bssid();
+  ::std::string* release_bssid();
+  void set_allocated_bssid(::std::string* bssid);
+
+  // optional uint32 ch = 3;
+  bool has_ch() const;
+  void clear_ch();
+  static const int kChFieldNumber = 3;
+  ::google::protobuf::uint32 ch() const;
+  void set_ch(::google::protobuf::uint32 value);
+
+  // optional uint32 bw = 4;
+  bool has_bw() const;
+  void clear_bw();
+  static const int kBwFieldNumber = 4;
+  ::google::protobuf::uint32 bw() const;
+  void set_bw(::google::protobuf::uint32 value);
+
+  // optional int32 rssi = 5;
+  bool has_rssi() const;
+  void clear_rssi();
+  static const int kRssiFieldNumber = 5;
+  ::google::protobuf::int32 rssi() const;
+  void set_rssi(::google::protobuf::int32 value);
+
+  // optional uint32 sec = 6;
+  bool has_sec() const;
+  void clear_sec();
+  static const int kSecFieldNumber = 6;
+  ::google::protobuf::uint32 sec() const;
+  void set_sec(::google::protobuf::uint32 value);
+
+  // optional bool wps = 7;
+  bool has_wps() const;
+  void clear_wps();
+  static const int kWpsFieldNumber = 7;
+  bool wps() const;
+  void set_wps(bool value);
+
+  // optional bool ess = 8;
+  bool has_ess() const;
+  void clear_ess();
+  static const int kEssFieldNumber = 8;
+  bool ess() const;
+  void set_ess(bool value);
+
+  // @@protoc_insertion_point(class_scope:StaScanResult)
+ private:
+  void set_has_ssid();
+  void clear_has_ssid();
+  void set_has_bssid();
+  void clear_has_bssid();
+  void set_has_ch();
+  void clear_has_ch();
+  void set_has_bw();
+  void clear_has_bw();
+  void set_has_rssi();
+  void clear_has_rssi();
+  void set_has_sec();
+  void clear_has_sec();
+  void set_has_wps();
+  void clear_has_wps();
+  void set_has_ess();
+  void clear_has_ess();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr ssid_;
+  ::google::protobuf::internal::ArenaStringPtr bssid_;
+  ::google::protobuf::uint32 ch_;
+  ::google::protobuf::uint32 bw_;
+  ::google::protobuf::int32 rssi_;
+  ::google::protobuf::uint32 sec_;
+  bool wps_;
+  bool ess_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaScanResults : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaScanResults) */ {
+ public:
+  StaScanResults();
+  virtual ~StaScanResults();
+
+  StaScanResults(const StaScanResults& from);
+
+  inline StaScanResults& operator=(const StaScanResults& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaScanResults& default_instance();
+
+  static inline const StaScanResults* internal_default_instance() {
+    return reinterpret_cast<const StaScanResults*>(
+               &_StaScanResults_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    3;
+
+  void Swap(StaScanResults* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaScanResults* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaScanResults* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaScanResults& from);
+  void MergeFrom(const StaScanResults& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaScanResults* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // repeated .StaScanResult res = 5;
+  int res_size() const;
+  void clear_res();
+  static const int kResFieldNumber = 5;
+  const ::StaScanResult& res(int index) const;
+  ::StaScanResult* mutable_res(int index);
+  ::StaScanResult* add_res();
+  ::google::protobuf::RepeatedPtrField< ::StaScanResult >*
+      mutable_res();
+  const ::google::protobuf::RepeatedPtrField< ::StaScanResult >&
+      res() const;
+
+  // optional .StaReqScan params = 3;
+  bool has_params() const;
+  void clear_params();
+  static const int kParamsFieldNumber = 3;
+  const ::StaReqScan& params() const;
+  ::StaReqScan* mutable_params();
+  ::StaReqScan* release_params();
+  void set_allocated_params(::StaReqScan* params);
+
+  // optional int32 scan_id = 1;
+  bool has_scan_id() const;
+  void clear_scan_id();
+  static const int kScanIdFieldNumber = 1;
+  ::google::protobuf::int32 scan_id() const;
+  void set_scan_id(::google::protobuf::int32 value);
+
+  // optional bool success = 2;
+  bool has_success() const;
+  void clear_success();
+  static const int kSuccessFieldNumber = 2;
+  bool success() const;
+  void set_success(bool value);
+
+  // optional int32 count = 4;
+  bool has_count() const;
+  void clear_count();
+  static const int kCountFieldNumber = 4;
+  ::google::protobuf::int32 count() const;
+  void set_count(::google::protobuf::int32 value);
+
+  // @@protoc_insertion_point(class_scope:StaScanResults)
+ private:
+  void set_has_scan_id();
+  void clear_has_scan_id();
+  void set_has_success();
+  void clear_has_success();
+  void set_has_params();
+  void clear_has_params();
+  void set_has_count();
+  void clear_has_count();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::RepeatedPtrField< ::StaScanResult > res_;
+  ::StaReqScan* params_;
+  ::google::protobuf::int32 scan_id_;
+  bool success_;
+  ::google::protobuf::int32 count_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaWepSec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaWepSec) */ {
+ public:
+  StaWepSec();
+  virtual ~StaWepSec();
+
+  StaWepSec(const StaWepSec& from);
+
+  inline StaWepSec& operator=(const StaWepSec& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaWepSec& default_instance();
+
+  static inline const StaWepSec* internal_default_instance() {
+    return reinterpret_cast<const StaWepSec*>(
+               &_StaWepSec_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    4;
+
+  void Swap(StaWepSec* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaWepSec* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaWepSec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaWepSec& from);
+  void MergeFrom(const StaWepSec& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaWepSec* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional bytes key0 = 1;
+  bool has_key0() const;
+  void clear_key0();
+  static const int kKey0FieldNumber = 1;
+  const ::std::string& key0() const;
+  void set_key0(const ::std::string& value);
+  #if LANG_CXX11
+  void set_key0(::std::string&& value);
+  #endif
+  void set_key0(const char* value);
+  void set_key0(const void* value, size_t size);
+  ::std::string* mutable_key0();
+  ::std::string* release_key0();
+  void set_allocated_key0(::std::string* key0);
+
+  // optional bytes key1 = 2;
+  bool has_key1() const;
+  void clear_key1();
+  static const int kKey1FieldNumber = 2;
+  const ::std::string& key1() const;
+  void set_key1(const ::std::string& value);
+  #if LANG_CXX11
+  void set_key1(::std::string&& value);
+  #endif
+  void set_key1(const char* value);
+  void set_key1(const void* value, size_t size);
+  ::std::string* mutable_key1();
+  ::std::string* release_key1();
+  void set_allocated_key1(::std::string* key1);
+
+  // optional bytes key2 = 3;
+  bool has_key2() const;
+  void clear_key2();
+  static const int kKey2FieldNumber = 3;
+  const ::std::string& key2() const;
+  void set_key2(const ::std::string& value);
+  #if LANG_CXX11
+  void set_key2(::std::string&& value);
+  #endif
+  void set_key2(const char* value);
+  void set_key2(const void* value, size_t size);
+  ::std::string* mutable_key2();
+  ::std::string* release_key2();
+  void set_allocated_key2(::std::string* key2);
+
+  // optional bytes key3 = 4;
+  bool has_key3() const;
+  void clear_key3();
+  static const int kKey3FieldNumber = 4;
+  const ::std::string& key3() const;
+  void set_key3(const ::std::string& value);
+  #if LANG_CXX11
+  void set_key3(::std::string&& value);
+  #endif
+  void set_key3(const char* value);
+  void set_key3(const void* value, size_t size);
+  ::std::string* mutable_key3();
+  ::std::string* release_key3();
+  void set_allocated_key3(::std::string* key3);
+
+  // optional uint32 defaultKey = 5;
+  bool has_defaultkey() const;
+  void clear_defaultkey();
+  static const int kDefaultKeyFieldNumber = 5;
+  ::google::protobuf::uint32 defaultkey() const;
+  void set_defaultkey(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:StaWepSec)
+ private:
+  void set_has_key0();
+  void clear_has_key0();
+  void set_has_key1();
+  void clear_has_key1();
+  void set_has_key2();
+  void clear_has_key2();
+  void set_has_key3();
+  void clear_has_key3();
+  void set_has_defaultkey();
+  void clear_has_defaultkey();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr key0_;
+  ::google::protobuf::internal::ArenaStringPtr key1_;
+  ::google::protobuf::internal::ArenaStringPtr key2_;
+  ::google::protobuf::internal::ArenaStringPtr key3_;
+  ::google::protobuf::uint32 defaultkey_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaWpsSec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaWpsSec) */ {
+ public:
+  StaWpsSec();
+  virtual ~StaWpsSec();
+
+  StaWpsSec(const StaWpsSec& from);
+
+  inline StaWpsSec& operator=(const StaWpsSec& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaWpsSec& default_instance();
+
+  static inline const StaWpsSec* internal_default_instance() {
+    return reinterpret_cast<const StaWpsSec*>(
+               &_StaWpsSec_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    5;
+
+  void Swap(StaWpsSec* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaWpsSec* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaWpsSec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaWpsSec& from);
+  void MergeFrom(const StaWpsSec& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaWpsSec* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional bytes pin = 2;
+  bool has_pin() const;
+  void clear_pin();
+  static const int kPinFieldNumber = 2;
+  const ::std::string& pin() const;
+  void set_pin(const ::std::string& value);
+  #if LANG_CXX11
+  void set_pin(::std::string&& value);
+  #endif
+  void set_pin(const char* value);
+  void set_pin(const void* value, size_t size);
+  ::std::string* mutable_pin();
+  ::std::string* release_pin();
+  void set_allocated_pin(::std::string* pin);
+
+  // optional uint32 type = 1;
+  bool has_type() const;
+  void clear_type();
+  static const int kTypeFieldNumber = 1;
+  ::google::protobuf::uint32 type() const;
+  void set_type(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:StaWpsSec)
+ private:
+  void set_has_type();
+  void clear_has_type();
+  void set_has_pin();
+  void clear_has_pin();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr pin_;
+  ::google::protobuf::uint32 type_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaPskSec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaPskSec) */ {
+ public:
+  StaPskSec();
+  virtual ~StaPskSec();
+
+  StaPskSec(const StaPskSec& from);
+
+  inline StaPskSec& operator=(const StaPskSec& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaPskSec& default_instance();
+
+  static inline const StaPskSec* internal_default_instance() {
+    return reinterpret_cast<const StaPskSec*>(
+               &_StaPskSec_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    6;
+
+  void Swap(StaPskSec* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaPskSec* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaPskSec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaPskSec& from);
+  void MergeFrom(const StaPskSec& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaPskSec* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional bytes password = 1;
+  bool has_password() const;
+  void clear_password();
+  static const int kPasswordFieldNumber = 1;
+  const ::std::string& password() const;
+  void set_password(const ::std::string& value);
+  #if LANG_CXX11
+  void set_password(::std::string&& value);
+  #endif
+  void set_password(const char* value);
+  void set_password(const void* value, size_t size);
+  ::std::string* mutable_password();
+  ::std::string* release_password();
+  void set_allocated_password(::std::string* password);
+
+  // optional uint32 pairCipher = 2;
+  bool has_paircipher() const;
+  void clear_paircipher();
+  static const int kPairCipherFieldNumber = 2;
+  ::google::protobuf::uint32 paircipher() const;
+  void set_paircipher(::google::protobuf::uint32 value);
+
+  // optional uint32 groupCipher = 3;
+  bool has_groupcipher() const;
+  void clear_groupcipher();
+  static const int kGroupCipherFieldNumber = 3;
+  ::google::protobuf::uint32 groupcipher() const;
+  void set_groupcipher(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:StaPskSec)
+ private:
+  void set_has_password();
+  void clear_has_password();
+  void set_has_paircipher();
+  void clear_has_paircipher();
+  void set_has_groupcipher();
+  void clear_has_groupcipher();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr password_;
+  ::google::protobuf::uint32 paircipher_;
+  ::google::protobuf::uint32 groupcipher_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaEapSec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaEapSec) */ {
+ public:
+  StaEapSec();
+  virtual ~StaEapSec();
+
+  StaEapSec(const StaEapSec& from);
+
+  inline StaEapSec& operator=(const StaEapSec& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaEapSec& default_instance();
+
+  static inline const StaEapSec* internal_default_instance() {
+    return reinterpret_cast<const StaEapSec*>(
+               &_StaEapSec_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    7;
+
+  void Swap(StaEapSec* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaEapSec* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaEapSec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaEapSec& from);
+  void MergeFrom(const StaEapSec& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaEapSec* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:StaEapSec)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaStaticIpv4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaStaticIpv4) */ {
+ public:
+  StaStaticIpv4();
+  virtual ~StaStaticIpv4();
+
+  StaStaticIpv4(const StaStaticIpv4& from);
+
+  inline StaStaticIpv4& operator=(const StaStaticIpv4& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaStaticIpv4& default_instance();
+
+  static inline const StaStaticIpv4* internal_default_instance() {
+    return reinterpret_cast<const StaStaticIpv4*>(
+               &_StaStaticIpv4_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    8;
+
+  void Swap(StaStaticIpv4* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaStaticIpv4* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaStaticIpv4* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaStaticIpv4& from);
+  void MergeFrom(const StaStaticIpv4& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaStaticIpv4* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:StaStaticIpv4)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaStaticIpv6 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaStaticIpv6) */ {
+ public:
+  StaStaticIpv6();
+  virtual ~StaStaticIpv6();
+
+  StaStaticIpv6(const StaStaticIpv6& from);
+
+  inline StaStaticIpv6& operator=(const StaStaticIpv6& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaStaticIpv6& default_instance();
+
+  static inline const StaStaticIpv6* internal_default_instance() {
+    return reinterpret_cast<const StaStaticIpv6*>(
+               &_StaStaticIpv6_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    9;
+
+  void Swap(StaStaticIpv6* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaStaticIpv6* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaStaticIpv6* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaStaticIpv6& from);
+  void MergeFrom(const StaStaticIpv6& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaStaticIpv6* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:StaStaticIpv6)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaReqConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaReqConnect) */ {
+ public:
+  StaReqConnect();
+  virtual ~StaReqConnect();
+
+  StaReqConnect(const StaReqConnect& from);
+
+  inline StaReqConnect& operator=(const StaReqConnect& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaReqConnect& default_instance();
+
+  static inline const StaReqConnect* internal_default_instance() {
+    return reinterpret_cast<const StaReqConnect*>(
+               &_StaReqConnect_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    10;
+
+  void Swap(StaReqConnect* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaReqConnect* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaReqConnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaReqConnect& from);
+  void MergeFrom(const StaReqConnect& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaReqConnect* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional bytes ssid = 1;
+  bool has_ssid() const;
+  void clear_ssid();
+  static const int kSsidFieldNumber = 1;
+  const ::std::string& ssid() const;
+  void set_ssid(const ::std::string& value);
+  #if LANG_CXX11
+  void set_ssid(::std::string&& value);
+  #endif
+  void set_ssid(const char* value);
+  void set_ssid(const void* value, size_t size);
+  ::std::string* mutable_ssid();
+  ::std::string* release_ssid();
+  void set_allocated_ssid(::std::string* ssid);
+
+  // optional bytes bssid = 2;
+  bool has_bssid() const;
+  void clear_bssid();
+  static const int kBssidFieldNumber = 2;
+  const ::std::string& bssid() const;
+  void set_bssid(const ::std::string& value);
+  #if LANG_CXX11
+  void set_bssid(::std::string&& value);
+  #endif
+  void set_bssid(const char* value);
+  void set_bssid(const void* value, size_t size);
+  ::std::string* mutable_bssid();
+  ::std::string* release_bssid();
+  void set_allocated_bssid(::std::string* bssid);
+
+  // optional .StaWepSec wepSec = 5;
+  bool has_wepsec() const;
+  void clear_wepsec();
+  static const int kWepSecFieldNumber = 5;
+  const ::StaWepSec& wepsec() const;
+  ::StaWepSec* mutable_wepsec();
+  ::StaWepSec* release_wepsec();
+  void set_allocated_wepsec(::StaWepSec* wepsec);
+
+  // optional .StaWpsSec wpsSec = 6;
+  bool has_wpssec() const;
+  void clear_wpssec();
+  static const int kWpsSecFieldNumber = 6;
+  const ::StaWpsSec& wpssec() const;
+  ::StaWpsSec* mutable_wpssec();
+  ::StaWpsSec* release_wpssec();
+  void set_allocated_wpssec(::StaWpsSec* wpssec);
+
+  // optional .StaPskSec pskSec = 7;
+  bool has_psksec() const;
+  void clear_psksec();
+  static const int kPskSecFieldNumber = 7;
+  const ::StaPskSec& psksec() const;
+  ::StaPskSec* mutable_psksec();
+  ::StaPskSec* release_psksec();
+  void set_allocated_psksec(::StaPskSec* psksec);
+
+  // optional .StaEapSec eapSec = 8;
+  bool has_eapsec() const;
+  void clear_eapsec();
+  static const int kEapSecFieldNumber = 8;
+  const ::StaEapSec& eapsec() const;
+  ::StaEapSec* mutable_eapsec();
+  ::StaEapSec* release_eapsec();
+  void set_allocated_eapsec(::StaEapSec* eapsec);
+
+  // optional .StaStaticIpv4 staticIpv4 = 10;
+  bool has_staticipv4() const;
+  void clear_staticipv4();
+  static const int kStaticIpv4FieldNumber = 10;
+  const ::StaStaticIpv4& staticipv4() const;
+  ::StaStaticIpv4* mutable_staticipv4();
+  ::StaStaticIpv4* release_staticipv4();
+  void set_allocated_staticipv4(::StaStaticIpv4* staticipv4);
+
+  // optional .StaStaticIpv6 staticIpv6 = 12;
+  bool has_staticipv6() const;
+  void clear_staticipv6();
+  static const int kStaticIpv6FieldNumber = 12;
+  const ::StaStaticIpv6& staticipv6() const;
+  ::StaStaticIpv6* mutable_staticipv6();
+  ::StaStaticIpv6* release_staticipv6();
+  void set_allocated_staticipv6(::StaStaticIpv6* staticipv6);
+
+  // optional uint32 channel = 3;
+  bool has_channel() const;
+  void clear_channel();
+  static const int kChannelFieldNumber = 3;
+  ::google::protobuf::uint32 channel() const;
+  void set_channel(::google::protobuf::uint32 value);
+
+  // optional uint32 secType = 4;
+  bool has_sectype() const;
+  void clear_sectype();
+  static const int kSecTypeFieldNumber = 4;
+  ::google::protobuf::uint32 sectype() const;
+  void set_sectype(::google::protobuf::uint32 value);
+
+  // optional uint32 ipv4Type = 9;
+  bool has_ipv4type() const;
+  void clear_ipv4type();
+  static const int kIpv4TypeFieldNumber = 9;
+  ::google::protobuf::uint32 ipv4type() const;
+  void set_ipv4type(::google::protobuf::uint32 value);
+
+  // optional uint32 ipv6Type = 11;
+  bool has_ipv6type() const;
+  void clear_ipv6type();
+  static const int kIpv6TypeFieldNumber = 11;
+  ::google::protobuf::uint32 ipv6type() const;
+  void set_ipv6type(::google::protobuf::uint32 value);
+
+  // @@protoc_insertion_point(class_scope:StaReqConnect)
+ private:
+  void set_has_ssid();
+  void clear_has_ssid();
+  void set_has_bssid();
+  void clear_has_bssid();
+  void set_has_channel();
+  void clear_has_channel();
+  void set_has_sectype();
+  void clear_has_sectype();
+  void set_has_wepsec();
+  void clear_has_wepsec();
+  void set_has_wpssec();
+  void clear_has_wpssec();
+  void set_has_psksec();
+  void clear_has_psksec();
+  void set_has_eapsec();
+  void clear_has_eapsec();
+  void set_has_ipv4type();
+  void clear_has_ipv4type();
+  void set_has_staticipv4();
+  void clear_has_staticipv4();
+  void set_has_ipv6type();
+  void clear_has_ipv6type();
+  void set_has_staticipv6();
+  void clear_has_staticipv6();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr ssid_;
+  ::google::protobuf::internal::ArenaStringPtr bssid_;
+  ::StaWepSec* wepsec_;
+  ::StaWpsSec* wpssec_;
+  ::StaPskSec* psksec_;
+  ::StaEapSec* eapsec_;
+  ::StaStaticIpv4* staticipv4_;
+  ::StaStaticIpv6* staticipv6_;
+  ::google::protobuf::uint32 channel_;
+  ::google::protobuf::uint32 sectype_;
+  ::google::protobuf::uint32 ipv4type_;
+  ::google::protobuf::uint32 ipv6type_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaRspConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaRspConnect) */ {
+ public:
+  StaRspConnect();
+  virtual ~StaRspConnect();
+
+  StaRspConnect(const StaRspConnect& from);
+
+  inline StaRspConnect& operator=(const StaRspConnect& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaRspConnect& default_instance();
+
+  static inline const StaRspConnect* internal_default_instance() {
+    return reinterpret_cast<const StaRspConnect*>(
+               &_StaRspConnect_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    11;
+
+  void Swap(StaRspConnect* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaRspConnect* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaRspConnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaRspConnect& from);
+  void MergeFrom(const StaRspConnect& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaRspConnect* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional .WlanIpcCmdRsp rsp = 1;
+  bool has_rsp() const;
+  void clear_rsp();
+  static const int kRspFieldNumber = 1;
+  ::WlanIpcCmdRsp rsp() const;
+  void set_rsp(::WlanIpcCmdRsp value);
+
+  // @@protoc_insertion_point(class_scope:StaRspConnect)
+ private:
+  void set_has_rsp();
+  void clear_has_rsp();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  int rsp_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaReqDisconnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaReqDisconnect) */ {
+ public:
+  StaReqDisconnect();
+  virtual ~StaReqDisconnect();
+
+  StaReqDisconnect(const StaReqDisconnect& from);
+
+  inline StaReqDisconnect& operator=(const StaReqDisconnect& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaReqDisconnect& default_instance();
+
+  static inline const StaReqDisconnect* internal_default_instance() {
+    return reinterpret_cast<const StaReqDisconnect*>(
+               &_StaReqDisconnect_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    12;
+
+  void Swap(StaReqDisconnect* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaReqDisconnect* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaReqDisconnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaReqDisconnect& from);
+  void MergeFrom(const StaReqDisconnect& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaReqDisconnect* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:StaReqDisconnect)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaRspDisconnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaRspDisconnect) */ {
+ public:
+  StaRspDisconnect();
+  virtual ~StaRspDisconnect();
+
+  StaRspDisconnect(const StaRspDisconnect& from);
+
+  inline StaRspDisconnect& operator=(const StaRspDisconnect& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaRspDisconnect& default_instance();
+
+  static inline const StaRspDisconnect* internal_default_instance() {
+    return reinterpret_cast<const StaRspDisconnect*>(
+               &_StaRspDisconnect_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    13;
+
+  void Swap(StaRspDisconnect* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaRspDisconnect* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaRspDisconnect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaRspDisconnect& from);
+  void MergeFrom(const StaRspDisconnect& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaRspDisconnect* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional .WlanIpcCmdRsp rsp = 1;
+  bool has_rsp() const;
+  void clear_rsp();
+  static const int kRspFieldNumber = 1;
+  ::WlanIpcCmdRsp rsp() const;
+  void set_rsp(::WlanIpcCmdRsp value);
+
+  // @@protoc_insertion_point(class_scope:StaRspDisconnect)
+ private:
+  void set_has_rsp();
+  void clear_has_rsp();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  int rsp_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class StaStatusUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StaStatusUpdate) */ {
+ public:
+  StaStatusUpdate();
+  virtual ~StaStatusUpdate();
+
+  StaStatusUpdate(const StaStatusUpdate& from);
+
+  inline StaStatusUpdate& operator=(const StaStatusUpdate& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const StaStatusUpdate& default_instance();
+
+  static inline const StaStatusUpdate* internal_default_instance() {
+    return reinterpret_cast<const StaStatusUpdate*>(
+               &_StaStatusUpdate_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    14;
+
+  void Swap(StaStatusUpdate* other);
+
+  // implements Message ----------------------------------------------
+
+  inline StaStatusUpdate* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  StaStatusUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const StaStatusUpdate& from);
+  void MergeFrom(const StaStatusUpdate& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(StaStatusUpdate* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional bytes macAddr = 1;
+  bool has_macaddr() const;
+  void clear_macaddr();
+  static const int kMacAddrFieldNumber = 1;
+  const ::std::string& macaddr() const;
+  void set_macaddr(const ::std::string& value);
+  #if LANG_CXX11
+  void set_macaddr(::std::string&& value);
+  #endif
+  void set_macaddr(const char* value);
+  void set_macaddr(const void* value, size_t size);
+  ::std::string* mutable_macaddr();
+  ::std::string* release_macaddr();
+  void set_allocated_macaddr(::std::string* macaddr);
+
+  // optional bytes ssid = 4;
+  bool has_ssid() const;
+  void clear_ssid();
+  static const int kSsidFieldNumber = 4;
+  const ::std::string& ssid() const;
+  void set_ssid(const ::std::string& value);
+  #if LANG_CXX11
+  void set_ssid(::std::string&& value);
+  #endif
+  void set_ssid(const char* value);
+  void set_ssid(const void* value, size_t size);
+  ::std::string* mutable_ssid();
+  ::std::string* release_ssid();
+  void set_allocated_ssid(::std::string* ssid);
+
+  // optional bytes ip = 15;
+  bool has_ip() const;
+  void clear_ip();
+  static const int kIpFieldNumber = 15;
+  const ::std::string& ip() const;
+  void set_ip(const ::std::string& value);
+  #if LANG_CXX11
+  void set_ip(::std::string&& value);
+  #endif
+  void set_ip(const char* value);
+  void set_ip(const void* value, size_t size);
+  ::std::string* mutable_ip();
+  ::std::string* release_ip();
+  void set_allocated_ip(::std::string* ip);
+
+  // optional bytes netmask = 16;
+  bool has_netmask() const;
+  void clear_netmask();
+  static const int kNetmaskFieldNumber = 16;
+  const ::std::string& netmask() const;
+  void set_netmask(const ::std::string& value);
+  #if LANG_CXX11
+  void set_netmask(::std::string&& value);
+  #endif
+  void set_netmask(const char* value);
+  void set_netmask(const void* value, size_t size);
+  ::std::string* mutable_netmask();
+  ::std::string* release_netmask();
+  void set_allocated_netmask(::std::string* netmask);
+
+  // optional bytes gateway = 17;
+  bool has_gateway() const;
+  void clear_gateway();
+  static const int kGatewayFieldNumber = 17;
+  const ::std::string& gateway() const;
+  void set_gateway(const ::std::string& value);
+  #if LANG_CXX11
+  void set_gateway(::std::string&& value);
+  #endif
+  void set_gateway(const char* value);
+  void set_gateway(const void* value, size_t size);
+  ::std::string* mutable_gateway();
+  ::std::string* release_gateway();
+  void set_allocated_gateway(::std::string* gateway);
+
+  // optional bytes dnsPref = 18;
+  bool has_dnspref() const;
+  void clear_dnspref();
+  static const int kDnsPrefFieldNumber = 18;
+  const ::std::string& dnspref() const;
+  void set_dnspref(const ::std::string& value);
+  #if LANG_CXX11
+  void set_dnspref(::std::string&& value);
+  #endif
+  void set_dnspref(const char* value);
+  void set_dnspref(const void* value, size_t size);
+  ::std::string* mutable_dnspref();
+  ::std::string* release_dnspref();
+  void set_allocated_dnspref(::std::string* dnspref);
+
+  // optional bytes dnsAlt = 19;
+  bool has_dnsalt() const;
+  void clear_dnsalt();
+  static const int kDnsAltFieldNumber = 19;
+  const ::std::string& dnsalt() const;
+  void set_dnsalt(const ::std::string& value);
+  #if LANG_CXX11
+  void set_dnsalt(::std::string&& value);
+  #endif
+  void set_dnsalt(const char* value);
+  void set_dnsalt(const void* value, size_t size);
+  ::std::string* mutable_dnsalt();
+  ::std::string* release_dnsalt();
+  void set_allocated_dnsalt(::std::string* dnsalt);
+
+  // optional uint32 smState = 2;
+  bool has_smstate() const;
+  void clear_smstate();
+  static const int kSmStateFieldNumber = 2;
+  ::google::protobuf::uint32 smstate() const;
+  void set_smstate(::google::protobuf::uint32 value);
+
+  // optional uint32 conState = 3;
+  bool has_constate() const;
+  void clear_constate();
+  static const int kConStateFieldNumber = 3;
+  ::google::protobuf::uint32 constate() const;
+  void set_constate(::google::protobuf::uint32 value);
+
+  // optional uint32 security = 5;
+  bool has_security() const;
+  void clear_security();
+  static const int kSecurityFieldNumber = 5;
+  ::google::protobuf::uint32 security() const;
+  void set_security(::google::protobuf::uint32 value);
+
+  // optional uint32 pairCipher = 6;
+  bool has_paircipher() const;
+  void clear_paircipher();
+  static const int kPairCipherFieldNumber = 6;
+  ::google::protobuf::uint32 paircipher() const;
+  void set_paircipher(::google::protobuf::uint32 value);
+
+  // optional uint32 groupCipher = 7;
+  bool has_groupcipher() const;
+  void clear_groupcipher();
+  static const int kGroupCipherFieldNumber = 7;
+  ::google::protobuf::uint32 groupcipher() const;
+  void set_groupcipher(::google::protobuf::uint32 value);
+
+  // optional uint32 channel = 8;
+  bool has_channel() const;
+  void clear_channel();
+  static const int kChannelFieldNumber = 8;
+  ::google::protobuf::uint32 channel() const;
+  void set_channel(::google::protobuf::uint32 value);
+
+  // optional uint32 bw = 9;
+  bool has_bw() const;
+  void clear_bw();
+  static const int kBwFieldNumber = 9;
+  ::google::protobuf::uint32 bw() const;
+  void set_bw(::google::protobuf::uint32 value);
+
+  // optional uint32 tech = 10;
+  bool has_tech() const;
+  void clear_tech();
+  static const int kTechFieldNumber = 10;
+  ::google::protobuf::uint32 tech() const;
+  void set_tech(::google::protobuf::uint32 value);
+
+  // optional uint32 dataRate = 11;
+  bool has_datarate() const;
+  void clear_datarate();
+  static const int kDataRateFieldNumber = 11;
+  ::google::protobuf::uint32 datarate() const;
+  void set_datarate(::google::protobuf::uint32 value);
+
+  // optional int32 rssi = 12;
+  bool has_rssi() const;
+  void clear_rssi();
+  static const int kRssiFieldNumber = 12;
+  ::google::protobuf::int32 rssi() const;
+  void set_rssi(::google::protobuf::int32 value);
+
+  // optional int32 noise = 13;
+  bool has_noise() const;
+  void clear_noise();
+  static const int kNoiseFieldNumber = 13;
+  ::google::protobuf::int32 noise() const;
+  void set_noise(::google::protobuf::int32 value);
+
+  // optional int32 snr = 14;
+  bool has_snr() const;
+  void clear_snr();
+  static const int kSnrFieldNumber = 14;
+  ::google::protobuf::int32 snr() const;
+  void set_snr(::google::protobuf::int32 value);
+
+  // @@protoc_insertion_point(class_scope:StaStatusUpdate)
+ private:
+  void set_has_macaddr();
+  void clear_has_macaddr();
+  void set_has_smstate();
+  void clear_has_smstate();
+  void set_has_constate();
+  void clear_has_constate();
+  void set_has_ssid();
+  void clear_has_ssid();
+  void set_has_security();
+  void clear_has_security();
+  void set_has_paircipher();
+  void clear_has_paircipher();
+  void set_has_groupcipher();
+  void clear_has_groupcipher();
+  void set_has_channel();
+  void clear_has_channel();
+  void set_has_bw();
+  void clear_has_bw();
+  void set_has_tech();
+  void clear_has_tech();
+  void set_has_datarate();
+  void clear_has_datarate();
+  void set_has_rssi();
+  void clear_has_rssi();
+  void set_has_noise();
+  void clear_has_noise();
+  void set_has_snr();
+  void clear_has_snr();
+  void set_has_ip();
+  void clear_has_ip();
+  void set_has_netmask();
+  void clear_has_netmask();
+  void set_has_gateway();
+  void clear_has_gateway();
+  void set_has_dnspref();
+  void clear_has_dnspref();
+  void set_has_dnsalt();
+  void clear_has_dnsalt();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::google::protobuf::internal::ArenaStringPtr macaddr_;
+  ::google::protobuf::internal::ArenaStringPtr ssid_;
+  ::google::protobuf::internal::ArenaStringPtr ip_;
+  ::google::protobuf::internal::ArenaStringPtr netmask_;
+  ::google::protobuf::internal::ArenaStringPtr gateway_;
+  ::google::protobuf::internal::ArenaStringPtr dnspref_;
+  ::google::protobuf::internal::ArenaStringPtr dnsalt_;
+  ::google::protobuf::uint32 smstate_;
+  ::google::protobuf::uint32 constate_;
+  ::google::protobuf::uint32 security_;
+  ::google::protobuf::uint32 paircipher_;
+  ::google::protobuf::uint32 groupcipher_;
+  ::google::protobuf::uint32 channel_;
+  ::google::protobuf::uint32 bw_;
+  ::google::protobuf::uint32 tech_;
+  ::google::protobuf::uint32 datarate_;
+  ::google::protobuf::int32 rssi_;
+  ::google::protobuf::int32 noise_;
+  ::google::protobuf::int32 snr_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class BtReqRequestFw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BtReqRequestFw) */ {
+ public:
+  BtReqRequestFw();
+  virtual ~BtReqRequestFw();
+
+  BtReqRequestFw(const BtReqRequestFw& from);
+
+  inline BtReqRequestFw& operator=(const BtReqRequestFw& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const BtReqRequestFw& default_instance();
+
+  static inline const BtReqRequestFw* internal_default_instance() {
+    return reinterpret_cast<const BtReqRequestFw*>(
+               &_BtReqRequestFw_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    15;
+
+  void Swap(BtReqRequestFw* other);
+
+  // implements Message ----------------------------------------------
+
+  inline BtReqRequestFw* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  BtReqRequestFw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const BtReqRequestFw& from);
+  void MergeFrom(const BtReqRequestFw& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(BtReqRequestFw* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:BtReqRequestFw)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class BtRspRequestFw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BtRspRequestFw) */ {
+ public:
+  BtRspRequestFw();
+  virtual ~BtRspRequestFw();
+
+  BtRspRequestFw(const BtRspRequestFw& from);
+
+  inline BtRspRequestFw& operator=(const BtRspRequestFw& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const BtRspRequestFw& default_instance();
+
+  static inline const BtRspRequestFw* internal_default_instance() {
+    return reinterpret_cast<const BtRspRequestFw*>(
+               &_BtRspRequestFw_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    16;
+
+  void Swap(BtRspRequestFw* other);
+
+  // implements Message ----------------------------------------------
+
+  inline BtRspRequestFw* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  BtRspRequestFw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const BtRspRequestFw& from);
+  void MergeFrom(const BtRspRequestFw& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(BtRspRequestFw* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional .WlanIpcCmdRsp rsp = 1;
+  bool has_rsp() const;
+  void clear_rsp();
+  static const int kRspFieldNumber = 1;
+  ::WlanIpcCmdRsp rsp() const;
+  void set_rsp(::WlanIpcCmdRsp value);
+
+  // @@protoc_insertion_point(class_scope:BtRspRequestFw)
+ private:
+  void set_has_rsp();
+  void clear_has_rsp();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  int rsp_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class BtReqDeclineFw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BtReqDeclineFw) */ {
+ public:
+  BtReqDeclineFw();
+  virtual ~BtReqDeclineFw();
+
+  BtReqDeclineFw(const BtReqDeclineFw& from);
+
+  inline BtReqDeclineFw& operator=(const BtReqDeclineFw& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const BtReqDeclineFw& default_instance();
+
+  static inline const BtReqDeclineFw* internal_default_instance() {
+    return reinterpret_cast<const BtReqDeclineFw*>(
+               &_BtReqDeclineFw_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    17;
+
+  void Swap(BtReqDeclineFw* other);
+
+  // implements Message ----------------------------------------------
+
+  inline BtReqDeclineFw* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  BtReqDeclineFw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const BtReqDeclineFw& from);
+  void MergeFrom(const BtReqDeclineFw& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(BtReqDeclineFw* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // @@protoc_insertion_point(class_scope:BtReqDeclineFw)
+ private:
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class BtRspDeclineFw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BtRspDeclineFw) */ {
+ public:
+  BtRspDeclineFw();
+  virtual ~BtRspDeclineFw();
+
+  BtRspDeclineFw(const BtRspDeclineFw& from);
+
+  inline BtRspDeclineFw& operator=(const BtRspDeclineFw& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const BtRspDeclineFw& default_instance();
+
+  static inline const BtRspDeclineFw* internal_default_instance() {
+    return reinterpret_cast<const BtRspDeclineFw*>(
+               &_BtRspDeclineFw_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    18;
+
+  void Swap(BtRspDeclineFw* other);
+
+  // implements Message ----------------------------------------------
+
+  inline BtRspDeclineFw* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  BtRspDeclineFw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const BtRspDeclineFw& from);
+  void MergeFrom(const BtRspDeclineFw& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(BtRspDeclineFw* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional .WlanIpcCmdRsp rsp = 1;
+  bool has_rsp() const;
+  void clear_rsp();
+  static const int kRspFieldNumber = 1;
+  ::WlanIpcCmdRsp rsp() const;
+  void set_rsp(::WlanIpcCmdRsp value);
+
+  // @@protoc_insertion_point(class_scope:BtRspDeclineFw)
+ private:
+  void set_has_rsp();
+  void clear_has_rsp();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  int rsp_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class WlanIpcCmdData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WlanIpcCmdData) */ {
+ public:
+  WlanIpcCmdData();
+  virtual ~WlanIpcCmdData();
+
+  WlanIpcCmdData(const WlanIpcCmdData& from);
+
+  inline WlanIpcCmdData& operator=(const WlanIpcCmdData& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const WlanIpcCmdData& default_instance();
+
+  static inline const WlanIpcCmdData* internal_default_instance() {
+    return reinterpret_cast<const WlanIpcCmdData*>(
+               &_WlanIpcCmdData_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    19;
+
+  void Swap(WlanIpcCmdData* other);
+
+  // implements Message ----------------------------------------------
+
+  inline WlanIpcCmdData* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  WlanIpcCmdData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const WlanIpcCmdData& from);
+  void MergeFrom(const WlanIpcCmdData& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(WlanIpcCmdData* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional .StaReqScan reqScan = 1;
+  bool has_reqscan() const;
+  void clear_reqscan();
+  static const int kReqScanFieldNumber = 1;
+  const ::StaReqScan& reqscan() const;
+  ::StaReqScan* mutable_reqscan();
+  ::StaReqScan* release_reqscan();
+  void set_allocated_reqscan(::StaReqScan* reqscan);
+
+  // optional .StaRspScan rspScan = 2;
+  bool has_rspscan() const;
+  void clear_rspscan();
+  static const int kRspScanFieldNumber = 2;
+  const ::StaRspScan& rspscan() const;
+  ::StaRspScan* mutable_rspscan();
+  ::StaRspScan* release_rspscan();
+  void set_allocated_rspscan(::StaRspScan* rspscan);
+
+  // optional .StaReqConnect reqConnect = 3;
+  bool has_reqconnect() const;
+  void clear_reqconnect();
+  static const int kReqConnectFieldNumber = 3;
+  const ::StaReqConnect& reqconnect() const;
+  ::StaReqConnect* mutable_reqconnect();
+  ::StaReqConnect* release_reqconnect();
+  void set_allocated_reqconnect(::StaReqConnect* reqconnect);
+
+  // optional .StaRspConnect rspConnect = 4;
+  bool has_rspconnect() const;
+  void clear_rspconnect();
+  static const int kRspConnectFieldNumber = 4;
+  const ::StaRspConnect& rspconnect() const;
+  ::StaRspConnect* mutable_rspconnect();
+  ::StaRspConnect* release_rspconnect();
+  void set_allocated_rspconnect(::StaRspConnect* rspconnect);
+
+  // optional .StaReqDisconnect reqDisconnect = 5;
+  bool has_reqdisconnect() const;
+  void clear_reqdisconnect();
+  static const int kReqDisconnectFieldNumber = 5;
+  const ::StaReqDisconnect& reqdisconnect() const;
+  ::StaReqDisconnect* mutable_reqdisconnect();
+  ::StaReqDisconnect* release_reqdisconnect();
+  void set_allocated_reqdisconnect(::StaReqDisconnect* reqdisconnect);
+
+  // optional .StaRspDisconnect rspDisconnect = 6;
+  bool has_rspdisconnect() const;
+  void clear_rspdisconnect();
+  static const int kRspDisconnectFieldNumber = 6;
+  const ::StaRspDisconnect& rspdisconnect() const;
+  ::StaRspDisconnect* mutable_rspdisconnect();
+  ::StaRspDisconnect* release_rspdisconnect();
+  void set_allocated_rspdisconnect(::StaRspDisconnect* rspdisconnect);
+
+  // optional .BtReqRequestFw reqRequestFw = 301;
+  bool has_reqrequestfw() const;
+  void clear_reqrequestfw();
+  static const int kReqRequestFwFieldNumber = 301;
+  const ::BtReqRequestFw& reqrequestfw() const;
+  ::BtReqRequestFw* mutable_reqrequestfw();
+  ::BtReqRequestFw* release_reqrequestfw();
+  void set_allocated_reqrequestfw(::BtReqRequestFw* reqrequestfw);
+
+  // optional .BtRspRequestFw rspRequestFw = 302;
+  bool has_rsprequestfw() const;
+  void clear_rsprequestfw();
+  static const int kRspRequestFwFieldNumber = 302;
+  const ::BtRspRequestFw& rsprequestfw() const;
+  ::BtRspRequestFw* mutable_rsprequestfw();
+  ::BtRspRequestFw* release_rsprequestfw();
+  void set_allocated_rsprequestfw(::BtRspRequestFw* rsprequestfw);
+
+  // optional .BtReqDeclineFw reqDeclineFw = 303;
+  bool has_reqdeclinefw() const;
+  void clear_reqdeclinefw();
+  static const int kReqDeclineFwFieldNumber = 303;
+  const ::BtReqDeclineFw& reqdeclinefw() const;
+  ::BtReqDeclineFw* mutable_reqdeclinefw();
+  ::BtReqDeclineFw* release_reqdeclinefw();
+  void set_allocated_reqdeclinefw(::BtReqDeclineFw* reqdeclinefw);
+
+  // optional .BtRspDeclineFw rspDeclineFw = 304;
+  bool has_rspdeclinefw() const;
+  void clear_rspdeclinefw();
+  static const int kRspDeclineFwFieldNumber = 304;
+  const ::BtRspDeclineFw& rspdeclinefw() const;
+  ::BtRspDeclineFw* mutable_rspdeclinefw();
+  ::BtRspDeclineFw* release_rspdeclinefw();
+  void set_allocated_rspdeclinefw(::BtRspDeclineFw* rspdeclinefw);
+
+  // optional .StaScanResults scanRes = 401;
+  bool has_scanres() const;
+  void clear_scanres();
+  static const int kScanResFieldNumber = 401;
+  const ::StaScanResults& scanres() const;
+  ::StaScanResults* mutable_scanres();
+  ::StaScanResults* release_scanres();
+  void set_allocated_scanres(::StaScanResults* scanres);
+
+  // optional .StaStatusUpdate staStatus = 402;
+  bool has_stastatus() const;
+  void clear_stastatus();
+  static const int kStaStatusFieldNumber = 402;
+  const ::StaStatusUpdate& stastatus() const;
+  ::StaStatusUpdate* mutable_stastatus();
+  ::StaStatusUpdate* release_stastatus();
+  void set_allocated_stastatus(::StaStatusUpdate* stastatus);
+
+  // @@protoc_insertion_point(class_scope:WlanIpcCmdData)
+ private:
+  void set_has_reqscan();
+  void clear_has_reqscan();
+  void set_has_rspscan();
+  void clear_has_rspscan();
+  void set_has_reqconnect();
+  void clear_has_reqconnect();
+  void set_has_rspconnect();
+  void clear_has_rspconnect();
+  void set_has_reqdisconnect();
+  void clear_has_reqdisconnect();
+  void set_has_rspdisconnect();
+  void clear_has_rspdisconnect();
+  void set_has_reqrequestfw();
+  void clear_has_reqrequestfw();
+  void set_has_rsprequestfw();
+  void clear_has_rsprequestfw();
+  void set_has_reqdeclinefw();
+  void clear_has_reqdeclinefw();
+  void set_has_rspdeclinefw();
+  void clear_has_rspdeclinefw();
+  void set_has_scanres();
+  void clear_has_scanres();
+  void set_has_stastatus();
+  void clear_has_stastatus();
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::StaReqScan* reqscan_;
+  ::StaRspScan* rspscan_;
+  ::StaReqConnect* reqconnect_;
+  ::StaRspConnect* rspconnect_;
+  ::StaReqDisconnect* reqdisconnect_;
+  ::StaRspDisconnect* rspdisconnect_;
+  ::BtReqRequestFw* reqrequestfw_;
+  ::BtRspRequestFw* rsprequestfw_;
+  ::BtReqDeclineFw* reqdeclinefw_;
+  ::BtRspDeclineFw* rspdeclinefw_;
+  ::StaScanResults* scanres_;
+  ::StaStatusUpdate* stastatus_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// -------------------------------------------------------------------
+
+class WlanIpcMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WlanIpcMsg) */ {
+ public:
+  WlanIpcMsg();
+  virtual ~WlanIpcMsg();
+
+  WlanIpcMsg(const WlanIpcMsg& from);
+
+  inline WlanIpcMsg& operator=(const WlanIpcMsg& from) {
+    CopyFrom(from);
+    return *this;
+  }
+
+  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
+    return _internal_metadata_.unknown_fields();
+  }
+
+  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
+    return _internal_metadata_.mutable_unknown_fields();
+  }
+
+  static const ::google::protobuf::Descriptor* descriptor();
+  static const WlanIpcMsg& default_instance();
+
+  static inline const WlanIpcMsg* internal_default_instance() {
+    return reinterpret_cast<const WlanIpcMsg*>(
+               &_WlanIpcMsg_default_instance_);
+  }
+  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
+    20;
+
+  void Swap(WlanIpcMsg* other);
+
+  // implements Message ----------------------------------------------
+
+  inline WlanIpcMsg* New() const PROTOBUF_FINAL { return New(NULL); }
+
+  WlanIpcMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
+  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
+  void CopyFrom(const WlanIpcMsg& from);
+  void MergeFrom(const WlanIpcMsg& from);
+  void Clear() PROTOBUF_FINAL;
+  bool IsInitialized() const PROTOBUF_FINAL;
+
+  size_t ByteSizeLong() const PROTOBUF_FINAL;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
+  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
+      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
+  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const PROTOBUF_FINAL;
+  void InternalSwap(WlanIpcMsg* other);
+  private:
+  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
+    return NULL;
+  }
+  inline void* MaybeArenaPtr() const {
+    return NULL;
+  }
+  public:
+
+  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;
+
+  // nested types ----------------------------------------------------
+
+  // accessors -------------------------------------------------------
+
+  // optional .WlanIpcCmdData data = 3;
+  bool has_data() const;
+  void clear_data();
+  static const int kDataFieldNumber = 3;
+  const ::WlanIpcCmdData& data() const;
+  ::WlanIpcCmdData* mutable_data();
+  ::WlanIpcCmdData* release_data();
+  void set_allocated_data(::WlanIpcCmdData* data);
+
+  // required int32 ver = 1;
+  bool has_ver() const;
+  void clear_ver();
+  static const int kVerFieldNumber = 1;
+  ::google::protobuf::int32 ver() const;
+  void set_ver(::google::protobuf::int32 value);
+
+  // required .WlanIpcCmdType type = 2;
+  bool has_type() const;
+  void clear_type();
+  static const int kTypeFieldNumber = 2;
+  ::WlanIpcCmdType type() const;
+  void set_type(::WlanIpcCmdType value);
+
+  // @@protoc_insertion_point(class_scope:WlanIpcMsg)
+ private:
+  void set_has_ver();
+  void clear_has_ver();
+  void set_has_type();
+  void clear_has_type();
+  void set_has_data();
+  void clear_has_data();
+
+  // helper for ByteSizeLong()
+  size_t RequiredFieldsByteSizeFallback() const;
+
+  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
+  ::google::protobuf::internal::HasBits<1> _has_bits_;
+  mutable int _cached_size_;
+  ::WlanIpcCmdData* data_;
+  ::google::protobuf::int32 ver_;
+  int type_;
+  friend struct protobuf_wlan_5fipc_2eproto::TableStruct;
+};
+// ===================================================================
+
+
+// ===================================================================
+
+#if !PROTOBUF_INLINE_NOT_IN_HEADERS
+// StaReqScan
+
+// repeated bytes ssid = 1;
+inline int StaReqScan::ssid_size() const {
+  return ssid_.size();
+}
+inline void StaReqScan::clear_ssid() {
+  ssid_.Clear();
+}
+inline const ::std::string& StaReqScan::ssid(int index) const {
+  // @@protoc_insertion_point(field_get:StaReqScan.ssid)
+  return ssid_.Get(index);
+}
+inline ::std::string* StaReqScan::mutable_ssid(int index) {
+  // @@protoc_insertion_point(field_mutable:StaReqScan.ssid)
+  return ssid_.Mutable(index);
+}
+inline void StaReqScan::set_ssid(int index, const ::std::string& value) {
+  // @@protoc_insertion_point(field_set:StaReqScan.ssid)
+  ssid_.Mutable(index)->assign(value);
+}
+#if LANG_CXX11
+inline void StaReqScan::set_ssid(int index, ::std::string&& value) {
+  // @@protoc_insertion_point(field_set:StaReqScan.ssid)
+  ssid_.Mutable(index)->assign(std::move(value));
+}
+#endif
+inline void StaReqScan::set_ssid(int index, const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  ssid_.Mutable(index)->assign(value);
+  // @@protoc_insertion_point(field_set_char:StaReqScan.ssid)
+}
+inline void StaReqScan::set_ssid(int index, const void* value, size_t size) {
+  ssid_.Mutable(index)->assign(
+    reinterpret_cast<const char*>(value), size);
+  // @@protoc_insertion_point(field_set_pointer:StaReqScan.ssid)
+}
+inline ::std::string* StaReqScan::add_ssid() {
+  // @@protoc_insertion_point(field_add_mutable:StaReqScan.ssid)
+  return ssid_.Add();
+}
+inline void StaReqScan::add_ssid(const ::std::string& value) {
+  ssid_.Add()->assign(value);
+  // @@protoc_insertion_point(field_add:StaReqScan.ssid)
+}
+#if LANG_CXX11
+inline void StaReqScan::add_ssid(::std::string&& value) {
+  ssid_.Add(std::move(value));
+  // @@protoc_insertion_point(field_add:StaReqScan.ssid)
+}
+#endif
+inline void StaReqScan::add_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  ssid_.Add()->assign(value);
+  // @@protoc_insertion_point(field_add_char:StaReqScan.ssid)
+}
+inline void StaReqScan::add_ssid(const void* value, size_t size) {
+  ssid_.Add()->assign(reinterpret_cast<const char*>(value), size);
+  // @@protoc_insertion_point(field_add_pointer:StaReqScan.ssid)
+}
+inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
+StaReqScan::ssid() const {
+  // @@protoc_insertion_point(field_list:StaReqScan.ssid)
+  return ssid_;
+}
+inline ::google::protobuf::RepeatedPtrField< ::std::string>*
+StaReqScan::mutable_ssid() {
+  // @@protoc_insertion_point(field_mutable_list:StaReqScan.ssid)
+  return &ssid_;
+}
+
+// repeated uint32 channel = 2;
+inline int StaReqScan::channel_size() const {
+  return channel_.size();
+}
+inline void StaReqScan::clear_channel() {
+  channel_.Clear();
+}
+inline ::google::protobuf::uint32 StaReqScan::channel(int index) const {
+  // @@protoc_insertion_point(field_get:StaReqScan.channel)
+  return channel_.Get(index);
+}
+inline void StaReqScan::set_channel(int index, ::google::protobuf::uint32 value) {
+  channel_.Set(index, value);
+  // @@protoc_insertion_point(field_set:StaReqScan.channel)
+}
+inline void StaReqScan::add_channel(::google::protobuf::uint32 value) {
+  channel_.Add(value);
+  // @@protoc_insertion_point(field_add:StaReqScan.channel)
+}
+inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
+StaReqScan::channel() const {
+  // @@protoc_insertion_point(field_list:StaReqScan.channel)
+  return channel_;
+}
+inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
+StaReqScan::mutable_channel() {
+  // @@protoc_insertion_point(field_mutable_list:StaReqScan.channel)
+  return &channel_;
+}
+
+// optional .StaScanType type = 3 [default = SCAN_TYPE_ACTIVE];
+inline bool StaReqScan::has_type() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaReqScan::set_has_type() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaReqScan::clear_has_type() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaReqScan::clear_type() {
+  type_ = 0;
+  clear_has_type();
+}
+inline ::StaScanType StaReqScan::type() const {
+  // @@protoc_insertion_point(field_get:StaReqScan.type)
+  return static_cast< ::StaScanType >(type_);
+}
+inline void StaReqScan::set_type(::StaScanType value) {
+  assert(::StaScanType_IsValid(value));
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:StaReqScan.type)
+}
+
+// -------------------------------------------------------------------
+
+// StaRspScan
+
+// optional int32 scan_id = 2;
+inline bool StaRspScan::has_scan_id() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaRspScan::set_has_scan_id() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaRspScan::clear_has_scan_id() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaRspScan::clear_scan_id() {
+  scan_id_ = 0;
+  clear_has_scan_id();
+}
+inline ::google::protobuf::int32 StaRspScan::scan_id() const {
+  // @@protoc_insertion_point(field_get:StaRspScan.scan_id)
+  return scan_id_;
+}
+inline void StaRspScan::set_scan_id(::google::protobuf::int32 value) {
+  set_has_scan_id();
+  scan_id_ = value;
+  // @@protoc_insertion_point(field_set:StaRspScan.scan_id)
+}
+
+// -------------------------------------------------------------------
+
+// StaScanResult
+
+// optional bytes ssid = 1;
+inline bool StaScanResult::has_ssid() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaScanResult::set_has_ssid() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaScanResult::clear_has_ssid() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaScanResult::clear_ssid() {
+  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ssid();
+}
+inline const ::std::string& StaScanResult::ssid() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.ssid)
+  return ssid_.GetNoArena();
+}
+inline void StaScanResult::set_ssid(const ::std::string& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaScanResult.ssid)
+}
+#if LANG_CXX11
+inline void StaScanResult::set_ssid(::std::string&& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaScanResult.ssid)
+}
+#endif
+inline void StaScanResult::set_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaScanResult.ssid)
+}
+inline void StaScanResult::set_ssid(const void* value, size_t size) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaScanResult.ssid)
+}
+inline ::std::string* StaScanResult::mutable_ssid() {
+  set_has_ssid();
+  // @@protoc_insertion_point(field_mutable:StaScanResult.ssid)
+  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaScanResult::release_ssid() {
+  // @@protoc_insertion_point(field_release:StaScanResult.ssid)
+  clear_has_ssid();
+  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaScanResult::set_allocated_ssid(::std::string* ssid) {
+  if (ssid != NULL) {
+    set_has_ssid();
+  } else {
+    clear_has_ssid();
+  }
+  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
+  // @@protoc_insertion_point(field_set_allocated:StaScanResult.ssid)
+}
+
+// optional bytes bssid = 2;
+inline bool StaScanResult::has_bssid() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaScanResult::set_has_bssid() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaScanResult::clear_has_bssid() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaScanResult::clear_bssid() {
+  bssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_bssid();
+}
+inline const ::std::string& StaScanResult::bssid() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.bssid)
+  return bssid_.GetNoArena();
+}
+inline void StaScanResult::set_bssid(const ::std::string& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaScanResult.bssid)
+}
+#if LANG_CXX11
+inline void StaScanResult::set_bssid(::std::string&& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaScanResult.bssid)
+}
+#endif
+inline void StaScanResult::set_bssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaScanResult.bssid)
+}
+inline void StaScanResult::set_bssid(const void* value, size_t size) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaScanResult.bssid)
+}
+inline ::std::string* StaScanResult::mutable_bssid() {
+  set_has_bssid();
+  // @@protoc_insertion_point(field_mutable:StaScanResult.bssid)
+  return bssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaScanResult::release_bssid() {
+  // @@protoc_insertion_point(field_release:StaScanResult.bssid)
+  clear_has_bssid();
+  return bssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaScanResult::set_allocated_bssid(::std::string* bssid) {
+  if (bssid != NULL) {
+    set_has_bssid();
+  } else {
+    clear_has_bssid();
+  }
+  bssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bssid);
+  // @@protoc_insertion_point(field_set_allocated:StaScanResult.bssid)
+}
+
+// optional uint32 ch = 3;
+inline bool StaScanResult::has_ch() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void StaScanResult::set_has_ch() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void StaScanResult::clear_has_ch() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void StaScanResult::clear_ch() {
+  ch_ = 0u;
+  clear_has_ch();
+}
+inline ::google::protobuf::uint32 StaScanResult::ch() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.ch)
+  return ch_;
+}
+inline void StaScanResult::set_ch(::google::protobuf::uint32 value) {
+  set_has_ch();
+  ch_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.ch)
+}
+
+// optional uint32 bw = 4;
+inline bool StaScanResult::has_bw() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void StaScanResult::set_has_bw() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void StaScanResult::clear_has_bw() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void StaScanResult::clear_bw() {
+  bw_ = 0u;
+  clear_has_bw();
+}
+inline ::google::protobuf::uint32 StaScanResult::bw() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.bw)
+  return bw_;
+}
+inline void StaScanResult::set_bw(::google::protobuf::uint32 value) {
+  set_has_bw();
+  bw_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.bw)
+}
+
+// optional int32 rssi = 5;
+inline bool StaScanResult::has_rssi() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void StaScanResult::set_has_rssi() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void StaScanResult::clear_has_rssi() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void StaScanResult::clear_rssi() {
+  rssi_ = 0;
+  clear_has_rssi();
+}
+inline ::google::protobuf::int32 StaScanResult::rssi() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.rssi)
+  return rssi_;
+}
+inline void StaScanResult::set_rssi(::google::protobuf::int32 value) {
+  set_has_rssi();
+  rssi_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.rssi)
+}
+
+// optional uint32 sec = 6;
+inline bool StaScanResult::has_sec() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+inline void StaScanResult::set_has_sec() {
+  _has_bits_[0] |= 0x00000020u;
+}
+inline void StaScanResult::clear_has_sec() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+inline void StaScanResult::clear_sec() {
+  sec_ = 0u;
+  clear_has_sec();
+}
+inline ::google::protobuf::uint32 StaScanResult::sec() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.sec)
+  return sec_;
+}
+inline void StaScanResult::set_sec(::google::protobuf::uint32 value) {
+  set_has_sec();
+  sec_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.sec)
+}
+
+// optional bool wps = 7;
+inline bool StaScanResult::has_wps() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+inline void StaScanResult::set_has_wps() {
+  _has_bits_[0] |= 0x00000040u;
+}
+inline void StaScanResult::clear_has_wps() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+inline void StaScanResult::clear_wps() {
+  wps_ = false;
+  clear_has_wps();
+}
+inline bool StaScanResult::wps() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.wps)
+  return wps_;
+}
+inline void StaScanResult::set_wps(bool value) {
+  set_has_wps();
+  wps_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.wps)
+}
+
+// optional bool ess = 8;
+inline bool StaScanResult::has_ess() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+inline void StaScanResult::set_has_ess() {
+  _has_bits_[0] |= 0x00000080u;
+}
+inline void StaScanResult::clear_has_ess() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+inline void StaScanResult::clear_ess() {
+  ess_ = false;
+  clear_has_ess();
+}
+inline bool StaScanResult::ess() const {
+  // @@protoc_insertion_point(field_get:StaScanResult.ess)
+  return ess_;
+}
+inline void StaScanResult::set_ess(bool value) {
+  set_has_ess();
+  ess_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResult.ess)
+}
+
+// -------------------------------------------------------------------
+
+// StaScanResults
+
+// optional int32 scan_id = 1;
+inline bool StaScanResults::has_scan_id() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaScanResults::set_has_scan_id() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaScanResults::clear_has_scan_id() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaScanResults::clear_scan_id() {
+  scan_id_ = 0;
+  clear_has_scan_id();
+}
+inline ::google::protobuf::int32 StaScanResults::scan_id() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.scan_id)
+  return scan_id_;
+}
+inline void StaScanResults::set_scan_id(::google::protobuf::int32 value) {
+  set_has_scan_id();
+  scan_id_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResults.scan_id)
+}
+
+// optional bool success = 2;
+inline bool StaScanResults::has_success() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void StaScanResults::set_has_success() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void StaScanResults::clear_has_success() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void StaScanResults::clear_success() {
+  success_ = false;
+  clear_has_success();
+}
+inline bool StaScanResults::success() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.success)
+  return success_;
+}
+inline void StaScanResults::set_success(bool value) {
+  set_has_success();
+  success_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResults.success)
+}
+
+// optional .StaReqScan params = 3;
+inline bool StaScanResults::has_params() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaScanResults::set_has_params() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaScanResults::clear_has_params() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaScanResults::clear_params() {
+  if (params_ != NULL) params_->::StaReqScan::Clear();
+  clear_has_params();
+}
+inline const ::StaReqScan& StaScanResults::params() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.params)
+  return params_ != NULL ? *params_
+                         : *::StaReqScan::internal_default_instance();
+}
+inline ::StaReqScan* StaScanResults::mutable_params() {
+  set_has_params();
+  if (params_ == NULL) {
+    params_ = new ::StaReqScan;
+  }
+  // @@protoc_insertion_point(field_mutable:StaScanResults.params)
+  return params_;
+}
+inline ::StaReqScan* StaScanResults::release_params() {
+  // @@protoc_insertion_point(field_release:StaScanResults.params)
+  clear_has_params();
+  ::StaReqScan* temp = params_;
+  params_ = NULL;
+  return temp;
+}
+inline void StaScanResults::set_allocated_params(::StaReqScan* params) {
+  delete params_;
+  params_ = params;
+  if (params) {
+    set_has_params();
+  } else {
+    clear_has_params();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaScanResults.params)
+}
+
+// optional int32 count = 4;
+inline bool StaScanResults::has_count() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void StaScanResults::set_has_count() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void StaScanResults::clear_has_count() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void StaScanResults::clear_count() {
+  count_ = 0;
+  clear_has_count();
+}
+inline ::google::protobuf::int32 StaScanResults::count() const {
+  // @@protoc_insertion_point(field_get:StaScanResults.count)
+  return count_;
+}
+inline void StaScanResults::set_count(::google::protobuf::int32 value) {
+  set_has_count();
+  count_ = value;
+  // @@protoc_insertion_point(field_set:StaScanResults.count)
+}
+
+// repeated .StaScanResult res = 5;
+inline int StaScanResults::res_size() const {
+  return res_.size();
+}
+inline void StaScanResults::clear_res() {
+  res_.Clear();
+}
+inline const ::StaScanResult& StaScanResults::res(int index) const {
+  // @@protoc_insertion_point(field_get:StaScanResults.res)
+  return res_.Get(index);
+}
+inline ::StaScanResult* StaScanResults::mutable_res(int index) {
+  // @@protoc_insertion_point(field_mutable:StaScanResults.res)
+  return res_.Mutable(index);
+}
+inline ::StaScanResult* StaScanResults::add_res() {
+  // @@protoc_insertion_point(field_add:StaScanResults.res)
+  return res_.Add();
+}
+inline ::google::protobuf::RepeatedPtrField< ::StaScanResult >*
+StaScanResults::mutable_res() {
+  // @@protoc_insertion_point(field_mutable_list:StaScanResults.res)
+  return &res_;
+}
+inline const ::google::protobuf::RepeatedPtrField< ::StaScanResult >&
+StaScanResults::res() const {
+  // @@protoc_insertion_point(field_list:StaScanResults.res)
+  return res_;
+}
+
+// -------------------------------------------------------------------
+
+// StaWepSec
+
+// optional bytes key0 = 1;
+inline bool StaWepSec::has_key0() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaWepSec::set_has_key0() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaWepSec::clear_has_key0() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaWepSec::clear_key0() {
+  key0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key0();
+}
+inline const ::std::string& StaWepSec::key0() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key0)
+  return key0_.GetNoArena();
+}
+inline void StaWepSec::set_key0(const ::std::string& value) {
+  set_has_key0();
+  key0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key0)
+}
+#if LANG_CXX11
+inline void StaWepSec::set_key0(::std::string&& value) {
+  set_has_key0();
+  key0_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key0)
+}
+#endif
+inline void StaWepSec::set_key0(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key0();
+  key0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key0)
+}
+inline void StaWepSec::set_key0(const void* value, size_t size) {
+  set_has_key0();
+  key0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key0)
+}
+inline ::std::string* StaWepSec::mutable_key0() {
+  set_has_key0();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key0)
+  return key0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaWepSec::release_key0() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key0)
+  clear_has_key0();
+  return key0_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaWepSec::set_allocated_key0(::std::string* key0) {
+  if (key0 != NULL) {
+    set_has_key0();
+  } else {
+    clear_has_key0();
+  }
+  key0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key0);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key0)
+}
+
+// optional bytes key1 = 2;
+inline bool StaWepSec::has_key1() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaWepSec::set_has_key1() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaWepSec::clear_has_key1() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaWepSec::clear_key1() {
+  key1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key1();
+}
+inline const ::std::string& StaWepSec::key1() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key1)
+  return key1_.GetNoArena();
+}
+inline void StaWepSec::set_key1(const ::std::string& value) {
+  set_has_key1();
+  key1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key1)
+}
+#if LANG_CXX11
+inline void StaWepSec::set_key1(::std::string&& value) {
+  set_has_key1();
+  key1_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key1)
+}
+#endif
+inline void StaWepSec::set_key1(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key1();
+  key1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key1)
+}
+inline void StaWepSec::set_key1(const void* value, size_t size) {
+  set_has_key1();
+  key1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key1)
+}
+inline ::std::string* StaWepSec::mutable_key1() {
+  set_has_key1();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key1)
+  return key1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaWepSec::release_key1() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key1)
+  clear_has_key1();
+  return key1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaWepSec::set_allocated_key1(::std::string* key1) {
+  if (key1 != NULL) {
+    set_has_key1();
+  } else {
+    clear_has_key1();
+  }
+  key1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key1);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key1)
+}
+
+// optional bytes key2 = 3;
+inline bool StaWepSec::has_key2() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void StaWepSec::set_has_key2() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void StaWepSec::clear_has_key2() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void StaWepSec::clear_key2() {
+  key2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key2();
+}
+inline const ::std::string& StaWepSec::key2() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key2)
+  return key2_.GetNoArena();
+}
+inline void StaWepSec::set_key2(const ::std::string& value) {
+  set_has_key2();
+  key2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key2)
+}
+#if LANG_CXX11
+inline void StaWepSec::set_key2(::std::string&& value) {
+  set_has_key2();
+  key2_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key2)
+}
+#endif
+inline void StaWepSec::set_key2(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key2();
+  key2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key2)
+}
+inline void StaWepSec::set_key2(const void* value, size_t size) {
+  set_has_key2();
+  key2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key2)
+}
+inline ::std::string* StaWepSec::mutable_key2() {
+  set_has_key2();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key2)
+  return key2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaWepSec::release_key2() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key2)
+  clear_has_key2();
+  return key2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaWepSec::set_allocated_key2(::std::string* key2) {
+  if (key2 != NULL) {
+    set_has_key2();
+  } else {
+    clear_has_key2();
+  }
+  key2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key2);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key2)
+}
+
+// optional bytes key3 = 4;
+inline bool StaWepSec::has_key3() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void StaWepSec::set_has_key3() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void StaWepSec::clear_has_key3() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void StaWepSec::clear_key3() {
+  key3_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_key3();
+}
+inline const ::std::string& StaWepSec::key3() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.key3)
+  return key3_.GetNoArena();
+}
+inline void StaWepSec::set_key3(const ::std::string& value) {
+  set_has_key3();
+  key3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWepSec.key3)
+}
+#if LANG_CXX11
+inline void StaWepSec::set_key3(::std::string&& value) {
+  set_has_key3();
+  key3_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWepSec.key3)
+}
+#endif
+inline void StaWepSec::set_key3(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_key3();
+  key3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWepSec.key3)
+}
+inline void StaWepSec::set_key3(const void* value, size_t size) {
+  set_has_key3();
+  key3_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWepSec.key3)
+}
+inline ::std::string* StaWepSec::mutable_key3() {
+  set_has_key3();
+  // @@protoc_insertion_point(field_mutable:StaWepSec.key3)
+  return key3_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaWepSec::release_key3() {
+  // @@protoc_insertion_point(field_release:StaWepSec.key3)
+  clear_has_key3();
+  return key3_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaWepSec::set_allocated_key3(::std::string* key3) {
+  if (key3 != NULL) {
+    set_has_key3();
+  } else {
+    clear_has_key3();
+  }
+  key3_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key3);
+  // @@protoc_insertion_point(field_set_allocated:StaWepSec.key3)
+}
+
+// optional uint32 defaultKey = 5;
+inline bool StaWepSec::has_defaultkey() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void StaWepSec::set_has_defaultkey() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void StaWepSec::clear_has_defaultkey() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void StaWepSec::clear_defaultkey() {
+  defaultkey_ = 0u;
+  clear_has_defaultkey();
+}
+inline ::google::protobuf::uint32 StaWepSec::defaultkey() const {
+  // @@protoc_insertion_point(field_get:StaWepSec.defaultKey)
+  return defaultkey_;
+}
+inline void StaWepSec::set_defaultkey(::google::protobuf::uint32 value) {
+  set_has_defaultkey();
+  defaultkey_ = value;
+  // @@protoc_insertion_point(field_set:StaWepSec.defaultKey)
+}
+
+// -------------------------------------------------------------------
+
+// StaWpsSec
+
+// optional uint32 type = 1;
+inline bool StaWpsSec::has_type() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaWpsSec::set_has_type() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaWpsSec::clear_has_type() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaWpsSec::clear_type() {
+  type_ = 0u;
+  clear_has_type();
+}
+inline ::google::protobuf::uint32 StaWpsSec::type() const {
+  // @@protoc_insertion_point(field_get:StaWpsSec.type)
+  return type_;
+}
+inline void StaWpsSec::set_type(::google::protobuf::uint32 value) {
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:StaWpsSec.type)
+}
+
+// optional bytes pin = 2;
+inline bool StaWpsSec::has_pin() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaWpsSec::set_has_pin() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaWpsSec::clear_has_pin() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaWpsSec::clear_pin() {
+  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_pin();
+}
+inline const ::std::string& StaWpsSec::pin() const {
+  // @@protoc_insertion_point(field_get:StaWpsSec.pin)
+  return pin_.GetNoArena();
+}
+inline void StaWpsSec::set_pin(const ::std::string& value) {
+  set_has_pin();
+  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaWpsSec.pin)
+}
+#if LANG_CXX11
+inline void StaWpsSec::set_pin(::std::string&& value) {
+  set_has_pin();
+  pin_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaWpsSec.pin)
+}
+#endif
+inline void StaWpsSec::set_pin(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_pin();
+  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaWpsSec.pin)
+}
+inline void StaWpsSec::set_pin(const void* value, size_t size) {
+  set_has_pin();
+  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaWpsSec.pin)
+}
+inline ::std::string* StaWpsSec::mutable_pin() {
+  set_has_pin();
+  // @@protoc_insertion_point(field_mutable:StaWpsSec.pin)
+  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaWpsSec::release_pin() {
+  // @@protoc_insertion_point(field_release:StaWpsSec.pin)
+  clear_has_pin();
+  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaWpsSec::set_allocated_pin(::std::string* pin) {
+  if (pin != NULL) {
+    set_has_pin();
+  } else {
+    clear_has_pin();
+  }
+  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
+  // @@protoc_insertion_point(field_set_allocated:StaWpsSec.pin)
+}
+
+// -------------------------------------------------------------------
+
+// StaPskSec
+
+// optional bytes password = 1;
+inline bool StaPskSec::has_password() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaPskSec::set_has_password() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaPskSec::clear_has_password() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaPskSec::clear_password() {
+  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_password();
+}
+inline const ::std::string& StaPskSec::password() const {
+  // @@protoc_insertion_point(field_get:StaPskSec.password)
+  return password_.GetNoArena();
+}
+inline void StaPskSec::set_password(const ::std::string& value) {
+  set_has_password();
+  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaPskSec.password)
+}
+#if LANG_CXX11
+inline void StaPskSec::set_password(::std::string&& value) {
+  set_has_password();
+  password_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaPskSec.password)
+}
+#endif
+inline void StaPskSec::set_password(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_password();
+  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaPskSec.password)
+}
+inline void StaPskSec::set_password(const void* value, size_t size) {
+  set_has_password();
+  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaPskSec.password)
+}
+inline ::std::string* StaPskSec::mutable_password() {
+  set_has_password();
+  // @@protoc_insertion_point(field_mutable:StaPskSec.password)
+  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaPskSec::release_password() {
+  // @@protoc_insertion_point(field_release:StaPskSec.password)
+  clear_has_password();
+  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaPskSec::set_allocated_password(::std::string* password) {
+  if (password != NULL) {
+    set_has_password();
+  } else {
+    clear_has_password();
+  }
+  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
+  // @@protoc_insertion_point(field_set_allocated:StaPskSec.password)
+}
+
+// optional uint32 pairCipher = 2;
+inline bool StaPskSec::has_paircipher() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaPskSec::set_has_paircipher() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaPskSec::clear_has_paircipher() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaPskSec::clear_paircipher() {
+  paircipher_ = 0u;
+  clear_has_paircipher();
+}
+inline ::google::protobuf::uint32 StaPskSec::paircipher() const {
+  // @@protoc_insertion_point(field_get:StaPskSec.pairCipher)
+  return paircipher_;
+}
+inline void StaPskSec::set_paircipher(::google::protobuf::uint32 value) {
+  set_has_paircipher();
+  paircipher_ = value;
+  // @@protoc_insertion_point(field_set:StaPskSec.pairCipher)
+}
+
+// optional uint32 groupCipher = 3;
+inline bool StaPskSec::has_groupcipher() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void StaPskSec::set_has_groupcipher() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void StaPskSec::clear_has_groupcipher() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void StaPskSec::clear_groupcipher() {
+  groupcipher_ = 0u;
+  clear_has_groupcipher();
+}
+inline ::google::protobuf::uint32 StaPskSec::groupcipher() const {
+  // @@protoc_insertion_point(field_get:StaPskSec.groupCipher)
+  return groupcipher_;
+}
+inline void StaPskSec::set_groupcipher(::google::protobuf::uint32 value) {
+  set_has_groupcipher();
+  groupcipher_ = value;
+  // @@protoc_insertion_point(field_set:StaPskSec.groupCipher)
+}
+
+// -------------------------------------------------------------------
+
+// StaEapSec
+
+// -------------------------------------------------------------------
+
+// StaStaticIpv4
+
+// -------------------------------------------------------------------
+
+// StaStaticIpv6
+
+// -------------------------------------------------------------------
+
+// StaReqConnect
+
+// optional bytes ssid = 1;
+inline bool StaReqConnect::has_ssid() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaReqConnect::set_has_ssid() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaReqConnect::clear_has_ssid() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaReqConnect::clear_ssid() {
+  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ssid();
+}
+inline const ::std::string& StaReqConnect::ssid() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.ssid)
+  return ssid_.GetNoArena();
+}
+inline void StaReqConnect::set_ssid(const ::std::string& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaReqConnect.ssid)
+}
+#if LANG_CXX11
+inline void StaReqConnect::set_ssid(::std::string&& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaReqConnect.ssid)
+}
+#endif
+inline void StaReqConnect::set_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaReqConnect.ssid)
+}
+inline void StaReqConnect::set_ssid(const void* value, size_t size) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaReqConnect.ssid)
+}
+inline ::std::string* StaReqConnect::mutable_ssid() {
+  set_has_ssid();
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.ssid)
+  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaReqConnect::release_ssid() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.ssid)
+  clear_has_ssid();
+  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaReqConnect::set_allocated_ssid(::std::string* ssid) {
+  if (ssid != NULL) {
+    set_has_ssid();
+  } else {
+    clear_has_ssid();
+  }
+  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.ssid)
+}
+
+// optional bytes bssid = 2;
+inline bool StaReqConnect::has_bssid() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaReqConnect::set_has_bssid() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaReqConnect::clear_has_bssid() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaReqConnect::clear_bssid() {
+  bssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_bssid();
+}
+inline const ::std::string& StaReqConnect::bssid() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.bssid)
+  return bssid_.GetNoArena();
+}
+inline void StaReqConnect::set_bssid(const ::std::string& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaReqConnect.bssid)
+}
+#if LANG_CXX11
+inline void StaReqConnect::set_bssid(::std::string&& value) {
+  set_has_bssid();
+  bssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaReqConnect.bssid)
+}
+#endif
+inline void StaReqConnect::set_bssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaReqConnect.bssid)
+}
+inline void StaReqConnect::set_bssid(const void* value, size_t size) {
+  set_has_bssid();
+  bssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaReqConnect.bssid)
+}
+inline ::std::string* StaReqConnect::mutable_bssid() {
+  set_has_bssid();
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.bssid)
+  return bssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaReqConnect::release_bssid() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.bssid)
+  clear_has_bssid();
+  return bssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaReqConnect::set_allocated_bssid(::std::string* bssid) {
+  if (bssid != NULL) {
+    set_has_bssid();
+  } else {
+    clear_has_bssid();
+  }
+  bssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bssid);
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.bssid)
+}
+
+// optional uint32 channel = 3;
+inline bool StaReqConnect::has_channel() const {
+  return (_has_bits_[0] & 0x00000100u) != 0;
+}
+inline void StaReqConnect::set_has_channel() {
+  _has_bits_[0] |= 0x00000100u;
+}
+inline void StaReqConnect::clear_has_channel() {
+  _has_bits_[0] &= ~0x00000100u;
+}
+inline void StaReqConnect::clear_channel() {
+  channel_ = 0u;
+  clear_has_channel();
+}
+inline ::google::protobuf::uint32 StaReqConnect::channel() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.channel)
+  return channel_;
+}
+inline void StaReqConnect::set_channel(::google::protobuf::uint32 value) {
+  set_has_channel();
+  channel_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.channel)
+}
+
+// optional uint32 secType = 4;
+inline bool StaReqConnect::has_sectype() const {
+  return (_has_bits_[0] & 0x00000200u) != 0;
+}
+inline void StaReqConnect::set_has_sectype() {
+  _has_bits_[0] |= 0x00000200u;
+}
+inline void StaReqConnect::clear_has_sectype() {
+  _has_bits_[0] &= ~0x00000200u;
+}
+inline void StaReqConnect::clear_sectype() {
+  sectype_ = 0u;
+  clear_has_sectype();
+}
+inline ::google::protobuf::uint32 StaReqConnect::sectype() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.secType)
+  return sectype_;
+}
+inline void StaReqConnect::set_sectype(::google::protobuf::uint32 value) {
+  set_has_sectype();
+  sectype_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.secType)
+}
+
+// optional .StaWepSec wepSec = 5;
+inline bool StaReqConnect::has_wepsec() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void StaReqConnect::set_has_wepsec() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void StaReqConnect::clear_has_wepsec() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void StaReqConnect::clear_wepsec() {
+  if (wepsec_ != NULL) wepsec_->::StaWepSec::Clear();
+  clear_has_wepsec();
+}
+inline const ::StaWepSec& StaReqConnect::wepsec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.wepSec)
+  return wepsec_ != NULL ? *wepsec_
+                         : *::StaWepSec::internal_default_instance();
+}
+inline ::StaWepSec* StaReqConnect::mutable_wepsec() {
+  set_has_wepsec();
+  if (wepsec_ == NULL) {
+    wepsec_ = new ::StaWepSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.wepSec)
+  return wepsec_;
+}
+inline ::StaWepSec* StaReqConnect::release_wepsec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.wepSec)
+  clear_has_wepsec();
+  ::StaWepSec* temp = wepsec_;
+  wepsec_ = NULL;
+  return temp;
+}
+inline void StaReqConnect::set_allocated_wepsec(::StaWepSec* wepsec) {
+  delete wepsec_;
+  wepsec_ = wepsec;
+  if (wepsec) {
+    set_has_wepsec();
+  } else {
+    clear_has_wepsec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.wepSec)
+}
+
+// optional .StaWpsSec wpsSec = 6;
+inline bool StaReqConnect::has_wpssec() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void StaReqConnect::set_has_wpssec() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void StaReqConnect::clear_has_wpssec() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void StaReqConnect::clear_wpssec() {
+  if (wpssec_ != NULL) wpssec_->::StaWpsSec::Clear();
+  clear_has_wpssec();
+}
+inline const ::StaWpsSec& StaReqConnect::wpssec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.wpsSec)
+  return wpssec_ != NULL ? *wpssec_
+                         : *::StaWpsSec::internal_default_instance();
+}
+inline ::StaWpsSec* StaReqConnect::mutable_wpssec() {
+  set_has_wpssec();
+  if (wpssec_ == NULL) {
+    wpssec_ = new ::StaWpsSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.wpsSec)
+  return wpssec_;
+}
+inline ::StaWpsSec* StaReqConnect::release_wpssec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.wpsSec)
+  clear_has_wpssec();
+  ::StaWpsSec* temp = wpssec_;
+  wpssec_ = NULL;
+  return temp;
+}
+inline void StaReqConnect::set_allocated_wpssec(::StaWpsSec* wpssec) {
+  delete wpssec_;
+  wpssec_ = wpssec;
+  if (wpssec) {
+    set_has_wpssec();
+  } else {
+    clear_has_wpssec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.wpsSec)
+}
+
+// optional .StaPskSec pskSec = 7;
+inline bool StaReqConnect::has_psksec() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void StaReqConnect::set_has_psksec() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void StaReqConnect::clear_has_psksec() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void StaReqConnect::clear_psksec() {
+  if (psksec_ != NULL) psksec_->::StaPskSec::Clear();
+  clear_has_psksec();
+}
+inline const ::StaPskSec& StaReqConnect::psksec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.pskSec)
+  return psksec_ != NULL ? *psksec_
+                         : *::StaPskSec::internal_default_instance();
+}
+inline ::StaPskSec* StaReqConnect::mutable_psksec() {
+  set_has_psksec();
+  if (psksec_ == NULL) {
+    psksec_ = new ::StaPskSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.pskSec)
+  return psksec_;
+}
+inline ::StaPskSec* StaReqConnect::release_psksec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.pskSec)
+  clear_has_psksec();
+  ::StaPskSec* temp = psksec_;
+  psksec_ = NULL;
+  return temp;
+}
+inline void StaReqConnect::set_allocated_psksec(::StaPskSec* psksec) {
+  delete psksec_;
+  psksec_ = psksec;
+  if (psksec) {
+    set_has_psksec();
+  } else {
+    clear_has_psksec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.pskSec)
+}
+
+// optional .StaEapSec eapSec = 8;
+inline bool StaReqConnect::has_eapsec() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+inline void StaReqConnect::set_has_eapsec() {
+  _has_bits_[0] |= 0x00000020u;
+}
+inline void StaReqConnect::clear_has_eapsec() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+inline void StaReqConnect::clear_eapsec() {
+  if (eapsec_ != NULL) eapsec_->::StaEapSec::Clear();
+  clear_has_eapsec();
+}
+inline const ::StaEapSec& StaReqConnect::eapsec() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.eapSec)
+  return eapsec_ != NULL ? *eapsec_
+                         : *::StaEapSec::internal_default_instance();
+}
+inline ::StaEapSec* StaReqConnect::mutable_eapsec() {
+  set_has_eapsec();
+  if (eapsec_ == NULL) {
+    eapsec_ = new ::StaEapSec;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.eapSec)
+  return eapsec_;
+}
+inline ::StaEapSec* StaReqConnect::release_eapsec() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.eapSec)
+  clear_has_eapsec();
+  ::StaEapSec* temp = eapsec_;
+  eapsec_ = NULL;
+  return temp;
+}
+inline void StaReqConnect::set_allocated_eapsec(::StaEapSec* eapsec) {
+  delete eapsec_;
+  eapsec_ = eapsec;
+  if (eapsec) {
+    set_has_eapsec();
+  } else {
+    clear_has_eapsec();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.eapSec)
+}
+
+// optional uint32 ipv4Type = 9;
+inline bool StaReqConnect::has_ipv4type() const {
+  return (_has_bits_[0] & 0x00000400u) != 0;
+}
+inline void StaReqConnect::set_has_ipv4type() {
+  _has_bits_[0] |= 0x00000400u;
+}
+inline void StaReqConnect::clear_has_ipv4type() {
+  _has_bits_[0] &= ~0x00000400u;
+}
+inline void StaReqConnect::clear_ipv4type() {
+  ipv4type_ = 0u;
+  clear_has_ipv4type();
+}
+inline ::google::protobuf::uint32 StaReqConnect::ipv4type() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.ipv4Type)
+  return ipv4type_;
+}
+inline void StaReqConnect::set_ipv4type(::google::protobuf::uint32 value) {
+  set_has_ipv4type();
+  ipv4type_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.ipv4Type)
+}
+
+// optional .StaStaticIpv4 staticIpv4 = 10;
+inline bool StaReqConnect::has_staticipv4() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+inline void StaReqConnect::set_has_staticipv4() {
+  _has_bits_[0] |= 0x00000040u;
+}
+inline void StaReqConnect::clear_has_staticipv4() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+inline void StaReqConnect::clear_staticipv4() {
+  if (staticipv4_ != NULL) staticipv4_->::StaStaticIpv4::Clear();
+  clear_has_staticipv4();
+}
+inline const ::StaStaticIpv4& StaReqConnect::staticipv4() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.staticIpv4)
+  return staticipv4_ != NULL ? *staticipv4_
+                         : *::StaStaticIpv4::internal_default_instance();
+}
+inline ::StaStaticIpv4* StaReqConnect::mutable_staticipv4() {
+  set_has_staticipv4();
+  if (staticipv4_ == NULL) {
+    staticipv4_ = new ::StaStaticIpv4;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.staticIpv4)
+  return staticipv4_;
+}
+inline ::StaStaticIpv4* StaReqConnect::release_staticipv4() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.staticIpv4)
+  clear_has_staticipv4();
+  ::StaStaticIpv4* temp = staticipv4_;
+  staticipv4_ = NULL;
+  return temp;
+}
+inline void StaReqConnect::set_allocated_staticipv4(::StaStaticIpv4* staticipv4) {
+  delete staticipv4_;
+  staticipv4_ = staticipv4;
+  if (staticipv4) {
+    set_has_staticipv4();
+  } else {
+    clear_has_staticipv4();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.staticIpv4)
+}
+
+// optional uint32 ipv6Type = 11;
+inline bool StaReqConnect::has_ipv6type() const {
+  return (_has_bits_[0] & 0x00000800u) != 0;
+}
+inline void StaReqConnect::set_has_ipv6type() {
+  _has_bits_[0] |= 0x00000800u;
+}
+inline void StaReqConnect::clear_has_ipv6type() {
+  _has_bits_[0] &= ~0x00000800u;
+}
+inline void StaReqConnect::clear_ipv6type() {
+  ipv6type_ = 0u;
+  clear_has_ipv6type();
+}
+inline ::google::protobuf::uint32 StaReqConnect::ipv6type() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.ipv6Type)
+  return ipv6type_;
+}
+inline void StaReqConnect::set_ipv6type(::google::protobuf::uint32 value) {
+  set_has_ipv6type();
+  ipv6type_ = value;
+  // @@protoc_insertion_point(field_set:StaReqConnect.ipv6Type)
+}
+
+// optional .StaStaticIpv6 staticIpv6 = 12;
+inline bool StaReqConnect::has_staticipv6() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+inline void StaReqConnect::set_has_staticipv6() {
+  _has_bits_[0] |= 0x00000080u;
+}
+inline void StaReqConnect::clear_has_staticipv6() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+inline void StaReqConnect::clear_staticipv6() {
+  if (staticipv6_ != NULL) staticipv6_->::StaStaticIpv6::Clear();
+  clear_has_staticipv6();
+}
+inline const ::StaStaticIpv6& StaReqConnect::staticipv6() const {
+  // @@protoc_insertion_point(field_get:StaReqConnect.staticIpv6)
+  return staticipv6_ != NULL ? *staticipv6_
+                         : *::StaStaticIpv6::internal_default_instance();
+}
+inline ::StaStaticIpv6* StaReqConnect::mutable_staticipv6() {
+  set_has_staticipv6();
+  if (staticipv6_ == NULL) {
+    staticipv6_ = new ::StaStaticIpv6;
+  }
+  // @@protoc_insertion_point(field_mutable:StaReqConnect.staticIpv6)
+  return staticipv6_;
+}
+inline ::StaStaticIpv6* StaReqConnect::release_staticipv6() {
+  // @@protoc_insertion_point(field_release:StaReqConnect.staticIpv6)
+  clear_has_staticipv6();
+  ::StaStaticIpv6* temp = staticipv6_;
+  staticipv6_ = NULL;
+  return temp;
+}
+inline void StaReqConnect::set_allocated_staticipv6(::StaStaticIpv6* staticipv6) {
+  delete staticipv6_;
+  staticipv6_ = staticipv6;
+  if (staticipv6) {
+    set_has_staticipv6();
+  } else {
+    clear_has_staticipv6();
+  }
+  // @@protoc_insertion_point(field_set_allocated:StaReqConnect.staticIpv6)
+}
+
+// -------------------------------------------------------------------
+
+// StaRspConnect
+
+// optional .WlanIpcCmdRsp rsp = 1;
+inline bool StaRspConnect::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaRspConnect::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaRspConnect::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaRspConnect::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+inline ::WlanIpcCmdRsp StaRspConnect::rsp() const {
+  // @@protoc_insertion_point(field_get:StaRspConnect.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+inline void StaRspConnect::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:StaRspConnect.rsp)
+}
+
+// -------------------------------------------------------------------
+
+// StaReqDisconnect
+
+// -------------------------------------------------------------------
+
+// StaRspDisconnect
+
+// optional .WlanIpcCmdRsp rsp = 1;
+inline bool StaRspDisconnect::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaRspDisconnect::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaRspDisconnect::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaRspDisconnect::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+inline ::WlanIpcCmdRsp StaRspDisconnect::rsp() const {
+  // @@protoc_insertion_point(field_get:StaRspDisconnect.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+inline void StaRspDisconnect::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:StaRspDisconnect.rsp)
+}
+
+// -------------------------------------------------------------------
+
+// StaStatusUpdate
+
+// optional bytes macAddr = 1;
+inline bool StaStatusUpdate::has_macaddr() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void StaStatusUpdate::set_has_macaddr() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void StaStatusUpdate::clear_has_macaddr() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void StaStatusUpdate::clear_macaddr() {
+  macaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_macaddr();
+}
+inline const ::std::string& StaStatusUpdate::macaddr() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.macAddr)
+  return macaddr_.GetNoArena();
+}
+inline void StaStatusUpdate::set_macaddr(const ::std::string& value) {
+  set_has_macaddr();
+  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.macAddr)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_macaddr(::std::string&& value) {
+  set_has_macaddr();
+  macaddr_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.macAddr)
+}
+#endif
+inline void StaStatusUpdate::set_macaddr(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_macaddr();
+  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.macAddr)
+}
+inline void StaStatusUpdate::set_macaddr(const void* value, size_t size) {
+  set_has_macaddr();
+  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.macAddr)
+}
+inline ::std::string* StaStatusUpdate::mutable_macaddr() {
+  set_has_macaddr();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.macAddr)
+  return macaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_macaddr() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.macAddr)
+  clear_has_macaddr();
+  return macaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_macaddr(::std::string* macaddr) {
+  if (macaddr != NULL) {
+    set_has_macaddr();
+  } else {
+    clear_has_macaddr();
+  }
+  macaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macaddr);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.macAddr)
+}
+
+// optional uint32 smState = 2;
+inline bool StaStatusUpdate::has_smstate() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+inline void StaStatusUpdate::set_has_smstate() {
+  _has_bits_[0] |= 0x00000080u;
+}
+inline void StaStatusUpdate::clear_has_smstate() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+inline void StaStatusUpdate::clear_smstate() {
+  smstate_ = 0u;
+  clear_has_smstate();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::smstate() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.smState)
+  return smstate_;
+}
+inline void StaStatusUpdate::set_smstate(::google::protobuf::uint32 value) {
+  set_has_smstate();
+  smstate_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.smState)
+}
+
+// optional uint32 conState = 3;
+inline bool StaStatusUpdate::has_constate() const {
+  return (_has_bits_[0] & 0x00000100u) != 0;
+}
+inline void StaStatusUpdate::set_has_constate() {
+  _has_bits_[0] |= 0x00000100u;
+}
+inline void StaStatusUpdate::clear_has_constate() {
+  _has_bits_[0] &= ~0x00000100u;
+}
+inline void StaStatusUpdate::clear_constate() {
+  constate_ = 0u;
+  clear_has_constate();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::constate() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.conState)
+  return constate_;
+}
+inline void StaStatusUpdate::set_constate(::google::protobuf::uint32 value) {
+  set_has_constate();
+  constate_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.conState)
+}
+
+// optional bytes ssid = 4;
+inline bool StaStatusUpdate::has_ssid() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void StaStatusUpdate::set_has_ssid() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void StaStatusUpdate::clear_has_ssid() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void StaStatusUpdate::clear_ssid() {
+  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ssid();
+}
+inline const ::std::string& StaStatusUpdate::ssid() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.ssid)
+  return ssid_.GetNoArena();
+}
+inline void StaStatusUpdate::set_ssid(const ::std::string& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.ssid)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_ssid(::std::string&& value) {
+  set_has_ssid();
+  ssid_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.ssid)
+}
+#endif
+inline void StaStatusUpdate::set_ssid(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.ssid)
+}
+inline void StaStatusUpdate::set_ssid(const void* value, size_t size) {
+  set_has_ssid();
+  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.ssid)
+}
+inline ::std::string* StaStatusUpdate::mutable_ssid() {
+  set_has_ssid();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.ssid)
+  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_ssid() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.ssid)
+  clear_has_ssid();
+  return ssid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_ssid(::std::string* ssid) {
+  if (ssid != NULL) {
+    set_has_ssid();
+  } else {
+    clear_has_ssid();
+  }
+  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.ssid)
+}
+
+// optional uint32 security = 5;
+inline bool StaStatusUpdate::has_security() const {
+  return (_has_bits_[0] & 0x00000200u) != 0;
+}
+inline void StaStatusUpdate::set_has_security() {
+  _has_bits_[0] |= 0x00000200u;
+}
+inline void StaStatusUpdate::clear_has_security() {
+  _has_bits_[0] &= ~0x00000200u;
+}
+inline void StaStatusUpdate::clear_security() {
+  security_ = 0u;
+  clear_has_security();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::security() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.security)
+  return security_;
+}
+inline void StaStatusUpdate::set_security(::google::protobuf::uint32 value) {
+  set_has_security();
+  security_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.security)
+}
+
+// optional uint32 pairCipher = 6;
+inline bool StaStatusUpdate::has_paircipher() const {
+  return (_has_bits_[0] & 0x00000400u) != 0;
+}
+inline void StaStatusUpdate::set_has_paircipher() {
+  _has_bits_[0] |= 0x00000400u;
+}
+inline void StaStatusUpdate::clear_has_paircipher() {
+  _has_bits_[0] &= ~0x00000400u;
+}
+inline void StaStatusUpdate::clear_paircipher() {
+  paircipher_ = 0u;
+  clear_has_paircipher();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::paircipher() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.pairCipher)
+  return paircipher_;
+}
+inline void StaStatusUpdate::set_paircipher(::google::protobuf::uint32 value) {
+  set_has_paircipher();
+  paircipher_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.pairCipher)
+}
+
+// optional uint32 groupCipher = 7;
+inline bool StaStatusUpdate::has_groupcipher() const {
+  return (_has_bits_[0] & 0x00000800u) != 0;
+}
+inline void StaStatusUpdate::set_has_groupcipher() {
+  _has_bits_[0] |= 0x00000800u;
+}
+inline void StaStatusUpdate::clear_has_groupcipher() {
+  _has_bits_[0] &= ~0x00000800u;
+}
+inline void StaStatusUpdate::clear_groupcipher() {
+  groupcipher_ = 0u;
+  clear_has_groupcipher();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::groupcipher() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.groupCipher)
+  return groupcipher_;
+}
+inline void StaStatusUpdate::set_groupcipher(::google::protobuf::uint32 value) {
+  set_has_groupcipher();
+  groupcipher_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.groupCipher)
+}
+
+// optional uint32 channel = 8;
+inline bool StaStatusUpdate::has_channel() const {
+  return (_has_bits_[0] & 0x00001000u) != 0;
+}
+inline void StaStatusUpdate::set_has_channel() {
+  _has_bits_[0] |= 0x00001000u;
+}
+inline void StaStatusUpdate::clear_has_channel() {
+  _has_bits_[0] &= ~0x00001000u;
+}
+inline void StaStatusUpdate::clear_channel() {
+  channel_ = 0u;
+  clear_has_channel();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::channel() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.channel)
+  return channel_;
+}
+inline void StaStatusUpdate::set_channel(::google::protobuf::uint32 value) {
+  set_has_channel();
+  channel_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.channel)
+}
+
+// optional uint32 bw = 9;
+inline bool StaStatusUpdate::has_bw() const {
+  return (_has_bits_[0] & 0x00002000u) != 0;
+}
+inline void StaStatusUpdate::set_has_bw() {
+  _has_bits_[0] |= 0x00002000u;
+}
+inline void StaStatusUpdate::clear_has_bw() {
+  _has_bits_[0] &= ~0x00002000u;
+}
+inline void StaStatusUpdate::clear_bw() {
+  bw_ = 0u;
+  clear_has_bw();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::bw() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.bw)
+  return bw_;
+}
+inline void StaStatusUpdate::set_bw(::google::protobuf::uint32 value) {
+  set_has_bw();
+  bw_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.bw)
+}
+
+// optional uint32 tech = 10;
+inline bool StaStatusUpdate::has_tech() const {
+  return (_has_bits_[0] & 0x00004000u) != 0;
+}
+inline void StaStatusUpdate::set_has_tech() {
+  _has_bits_[0] |= 0x00004000u;
+}
+inline void StaStatusUpdate::clear_has_tech() {
+  _has_bits_[0] &= ~0x00004000u;
+}
+inline void StaStatusUpdate::clear_tech() {
+  tech_ = 0u;
+  clear_has_tech();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::tech() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.tech)
+  return tech_;
+}
+inline void StaStatusUpdate::set_tech(::google::protobuf::uint32 value) {
+  set_has_tech();
+  tech_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.tech)
+}
+
+// optional uint32 dataRate = 11;
+inline bool StaStatusUpdate::has_datarate() const {
+  return (_has_bits_[0] & 0x00008000u) != 0;
+}
+inline void StaStatusUpdate::set_has_datarate() {
+  _has_bits_[0] |= 0x00008000u;
+}
+inline void StaStatusUpdate::clear_has_datarate() {
+  _has_bits_[0] &= ~0x00008000u;
+}
+inline void StaStatusUpdate::clear_datarate() {
+  datarate_ = 0u;
+  clear_has_datarate();
+}
+inline ::google::protobuf::uint32 StaStatusUpdate::datarate() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.dataRate)
+  return datarate_;
+}
+inline void StaStatusUpdate::set_datarate(::google::protobuf::uint32 value) {
+  set_has_datarate();
+  datarate_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.dataRate)
+}
+
+// optional int32 rssi = 12;
+inline bool StaStatusUpdate::has_rssi() const {
+  return (_has_bits_[0] & 0x00010000u) != 0;
+}
+inline void StaStatusUpdate::set_has_rssi() {
+  _has_bits_[0] |= 0x00010000u;
+}
+inline void StaStatusUpdate::clear_has_rssi() {
+  _has_bits_[0] &= ~0x00010000u;
+}
+inline void StaStatusUpdate::clear_rssi() {
+  rssi_ = 0;
+  clear_has_rssi();
+}
+inline ::google::protobuf::int32 StaStatusUpdate::rssi() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.rssi)
+  return rssi_;
+}
+inline void StaStatusUpdate::set_rssi(::google::protobuf::int32 value) {
+  set_has_rssi();
+  rssi_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.rssi)
+}
+
+// optional int32 noise = 13;
+inline bool StaStatusUpdate::has_noise() const {
+  return (_has_bits_[0] & 0x00020000u) != 0;
+}
+inline void StaStatusUpdate::set_has_noise() {
+  _has_bits_[0] |= 0x00020000u;
+}
+inline void StaStatusUpdate::clear_has_noise() {
+  _has_bits_[0] &= ~0x00020000u;
+}
+inline void StaStatusUpdate::clear_noise() {
+  noise_ = 0;
+  clear_has_noise();
+}
+inline ::google::protobuf::int32 StaStatusUpdate::noise() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.noise)
+  return noise_;
+}
+inline void StaStatusUpdate::set_noise(::google::protobuf::int32 value) {
+  set_has_noise();
+  noise_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.noise)
+}
+
+// optional int32 snr = 14;
+inline bool StaStatusUpdate::has_snr() const {
+  return (_has_bits_[0] & 0x00040000u) != 0;
+}
+inline void StaStatusUpdate::set_has_snr() {
+  _has_bits_[0] |= 0x00040000u;
+}
+inline void StaStatusUpdate::clear_has_snr() {
+  _has_bits_[0] &= ~0x00040000u;
+}
+inline void StaStatusUpdate::clear_snr() {
+  snr_ = 0;
+  clear_has_snr();
+}
+inline ::google::protobuf::int32 StaStatusUpdate::snr() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.snr)
+  return snr_;
+}
+inline void StaStatusUpdate::set_snr(::google::protobuf::int32 value) {
+  set_has_snr();
+  snr_ = value;
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.snr)
+}
+
+// optional bytes ip = 15;
+inline bool StaStatusUpdate::has_ip() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void StaStatusUpdate::set_has_ip() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void StaStatusUpdate::clear_has_ip() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void StaStatusUpdate::clear_ip() {
+  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_ip();
+}
+inline const ::std::string& StaStatusUpdate::ip() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.ip)
+  return ip_.GetNoArena();
+}
+inline void StaStatusUpdate::set_ip(const ::std::string& value) {
+  set_has_ip();
+  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.ip)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_ip(::std::string&& value) {
+  set_has_ip();
+  ip_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.ip)
+}
+#endif
+inline void StaStatusUpdate::set_ip(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_ip();
+  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.ip)
+}
+inline void StaStatusUpdate::set_ip(const void* value, size_t size) {
+  set_has_ip();
+  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.ip)
+}
+inline ::std::string* StaStatusUpdate::mutable_ip() {
+  set_has_ip();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.ip)
+  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_ip() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.ip)
+  clear_has_ip();
+  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_ip(::std::string* ip) {
+  if (ip != NULL) {
+    set_has_ip();
+  } else {
+    clear_has_ip();
+  }
+  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.ip)
+}
+
+// optional bytes netmask = 16;
+inline bool StaStatusUpdate::has_netmask() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void StaStatusUpdate::set_has_netmask() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void StaStatusUpdate::clear_has_netmask() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void StaStatusUpdate::clear_netmask() {
+  netmask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_netmask();
+}
+inline const ::std::string& StaStatusUpdate::netmask() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.netmask)
+  return netmask_.GetNoArena();
+}
+inline void StaStatusUpdate::set_netmask(const ::std::string& value) {
+  set_has_netmask();
+  netmask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.netmask)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_netmask(::std::string&& value) {
+  set_has_netmask();
+  netmask_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.netmask)
+}
+#endif
+inline void StaStatusUpdate::set_netmask(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_netmask();
+  netmask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.netmask)
+}
+inline void StaStatusUpdate::set_netmask(const void* value, size_t size) {
+  set_has_netmask();
+  netmask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.netmask)
+}
+inline ::std::string* StaStatusUpdate::mutable_netmask() {
+  set_has_netmask();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.netmask)
+  return netmask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_netmask() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.netmask)
+  clear_has_netmask();
+  return netmask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_netmask(::std::string* netmask) {
+  if (netmask != NULL) {
+    set_has_netmask();
+  } else {
+    clear_has_netmask();
+  }
+  netmask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), netmask);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.netmask)
+}
+
+// optional bytes gateway = 17;
+inline bool StaStatusUpdate::has_gateway() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void StaStatusUpdate::set_has_gateway() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void StaStatusUpdate::clear_has_gateway() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void StaStatusUpdate::clear_gateway() {
+  gateway_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_gateway();
+}
+inline const ::std::string& StaStatusUpdate::gateway() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.gateway)
+  return gateway_.GetNoArena();
+}
+inline void StaStatusUpdate::set_gateway(const ::std::string& value) {
+  set_has_gateway();
+  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.gateway)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_gateway(::std::string&& value) {
+  set_has_gateway();
+  gateway_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.gateway)
+}
+#endif
+inline void StaStatusUpdate::set_gateway(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_gateway();
+  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.gateway)
+}
+inline void StaStatusUpdate::set_gateway(const void* value, size_t size) {
+  set_has_gateway();
+  gateway_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.gateway)
+}
+inline ::std::string* StaStatusUpdate::mutable_gateway() {
+  set_has_gateway();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.gateway)
+  return gateway_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_gateway() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.gateway)
+  clear_has_gateway();
+  return gateway_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_gateway(::std::string* gateway) {
+  if (gateway != NULL) {
+    set_has_gateway();
+  } else {
+    clear_has_gateway();
+  }
+  gateway_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gateway);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.gateway)
+}
+
+// optional bytes dnsPref = 18;
+inline bool StaStatusUpdate::has_dnspref() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+inline void StaStatusUpdate::set_has_dnspref() {
+  _has_bits_[0] |= 0x00000020u;
+}
+inline void StaStatusUpdate::clear_has_dnspref() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+inline void StaStatusUpdate::clear_dnspref() {
+  dnspref_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_dnspref();
+}
+inline const ::std::string& StaStatusUpdate::dnspref() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.dnsPref)
+  return dnspref_.GetNoArena();
+}
+inline void StaStatusUpdate::set_dnspref(const ::std::string& value) {
+  set_has_dnspref();
+  dnspref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.dnsPref)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_dnspref(::std::string&& value) {
+  set_has_dnspref();
+  dnspref_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.dnsPref)
+}
+#endif
+inline void StaStatusUpdate::set_dnspref(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_dnspref();
+  dnspref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.dnsPref)
+}
+inline void StaStatusUpdate::set_dnspref(const void* value, size_t size) {
+  set_has_dnspref();
+  dnspref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.dnsPref)
+}
+inline ::std::string* StaStatusUpdate::mutable_dnspref() {
+  set_has_dnspref();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.dnsPref)
+  return dnspref_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_dnspref() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.dnsPref)
+  clear_has_dnspref();
+  return dnspref_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_dnspref(::std::string* dnspref) {
+  if (dnspref != NULL) {
+    set_has_dnspref();
+  } else {
+    clear_has_dnspref();
+  }
+  dnspref_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dnspref);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.dnsPref)
+}
+
+// optional bytes dnsAlt = 19;
+inline bool StaStatusUpdate::has_dnsalt() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+inline void StaStatusUpdate::set_has_dnsalt() {
+  _has_bits_[0] |= 0x00000040u;
+}
+inline void StaStatusUpdate::clear_has_dnsalt() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+inline void StaStatusUpdate::clear_dnsalt() {
+  dnsalt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+  clear_has_dnsalt();
+}
+inline const ::std::string& StaStatusUpdate::dnsalt() const {
+  // @@protoc_insertion_point(field_get:StaStatusUpdate.dnsAlt)
+  return dnsalt_.GetNoArena();
+}
+inline void StaStatusUpdate::set_dnsalt(const ::std::string& value) {
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
+  // @@protoc_insertion_point(field_set:StaStatusUpdate.dnsAlt)
+}
+#if LANG_CXX11
+inline void StaStatusUpdate::set_dnsalt(::std::string&& value) {
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(
+    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
+  // @@protoc_insertion_point(field_set_rvalue:StaStatusUpdate.dnsAlt)
+}
+#endif
+inline void StaStatusUpdate::set_dnsalt(const char* value) {
+  GOOGLE_DCHECK(value != NULL);
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
+  // @@protoc_insertion_point(field_set_char:StaStatusUpdate.dnsAlt)
+}
+inline void StaStatusUpdate::set_dnsalt(const void* value, size_t size) {
+  set_has_dnsalt();
+  dnsalt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
+      ::std::string(reinterpret_cast<const char*>(value), size));
+  // @@protoc_insertion_point(field_set_pointer:StaStatusUpdate.dnsAlt)
+}
+inline ::std::string* StaStatusUpdate::mutable_dnsalt() {
+  set_has_dnsalt();
+  // @@protoc_insertion_point(field_mutable:StaStatusUpdate.dnsAlt)
+  return dnsalt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline ::std::string* StaStatusUpdate::release_dnsalt() {
+  // @@protoc_insertion_point(field_release:StaStatusUpdate.dnsAlt)
+  clear_has_dnsalt();
+  return dnsalt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
+}
+inline void StaStatusUpdate::set_allocated_dnsalt(::std::string* dnsalt) {
+  if (dnsalt != NULL) {
+    set_has_dnsalt();
+  } else {
+    clear_has_dnsalt();
+  }
+  dnsalt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dnsalt);
+  // @@protoc_insertion_point(field_set_allocated:StaStatusUpdate.dnsAlt)
+}
+
+// -------------------------------------------------------------------
+
+// BtReqRequestFw
+
+// -------------------------------------------------------------------
+
+// BtRspRequestFw
+
+// optional .WlanIpcCmdRsp rsp = 1;
+inline bool BtRspRequestFw::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void BtRspRequestFw::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void BtRspRequestFw::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void BtRspRequestFw::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+inline ::WlanIpcCmdRsp BtRspRequestFw::rsp() const {
+  // @@protoc_insertion_point(field_get:BtRspRequestFw.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+inline void BtRspRequestFw::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:BtRspRequestFw.rsp)
+}
+
+// -------------------------------------------------------------------
+
+// BtReqDeclineFw
+
+// -------------------------------------------------------------------
+
+// BtRspDeclineFw
+
+// optional .WlanIpcCmdRsp rsp = 1;
+inline bool BtRspDeclineFw::has_rsp() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void BtRspDeclineFw::set_has_rsp() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void BtRspDeclineFw::clear_has_rsp() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void BtRspDeclineFw::clear_rsp() {
+  rsp_ = 0;
+  clear_has_rsp();
+}
+inline ::WlanIpcCmdRsp BtRspDeclineFw::rsp() const {
+  // @@protoc_insertion_point(field_get:BtRspDeclineFw.rsp)
+  return static_cast< ::WlanIpcCmdRsp >(rsp_);
+}
+inline void BtRspDeclineFw::set_rsp(::WlanIpcCmdRsp value) {
+  assert(::WlanIpcCmdRsp_IsValid(value));
+  set_has_rsp();
+  rsp_ = value;
+  // @@protoc_insertion_point(field_set:BtRspDeclineFw.rsp)
+}
+
+// -------------------------------------------------------------------
+
+// WlanIpcCmdData
+
+// optional .StaReqScan reqScan = 1;
+inline bool WlanIpcCmdData::has_reqscan() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void WlanIpcCmdData::set_has_reqscan() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void WlanIpcCmdData::clear_has_reqscan() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void WlanIpcCmdData::clear_reqscan() {
+  if (reqscan_ != NULL) reqscan_->::StaReqScan::Clear();
+  clear_has_reqscan();
+}
+inline const ::StaReqScan& WlanIpcCmdData::reqscan() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqScan)
+  return reqscan_ != NULL ? *reqscan_
+                         : *::StaReqScan::internal_default_instance();
+}
+inline ::StaReqScan* WlanIpcCmdData::mutable_reqscan() {
+  set_has_reqscan();
+  if (reqscan_ == NULL) {
+    reqscan_ = new ::StaReqScan;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqScan)
+  return reqscan_;
+}
+inline ::StaReqScan* WlanIpcCmdData::release_reqscan() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqScan)
+  clear_has_reqscan();
+  ::StaReqScan* temp = reqscan_;
+  reqscan_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_reqscan(::StaReqScan* reqscan) {
+  delete reqscan_;
+  reqscan_ = reqscan;
+  if (reqscan) {
+    set_has_reqscan();
+  } else {
+    clear_has_reqscan();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqScan)
+}
+
+// optional .StaRspScan rspScan = 2;
+inline bool WlanIpcCmdData::has_rspscan() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void WlanIpcCmdData::set_has_rspscan() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void WlanIpcCmdData::clear_has_rspscan() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void WlanIpcCmdData::clear_rspscan() {
+  if (rspscan_ != NULL) rspscan_->::StaRspScan::Clear();
+  clear_has_rspscan();
+}
+inline const ::StaRspScan& WlanIpcCmdData::rspscan() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspScan)
+  return rspscan_ != NULL ? *rspscan_
+                         : *::StaRspScan::internal_default_instance();
+}
+inline ::StaRspScan* WlanIpcCmdData::mutable_rspscan() {
+  set_has_rspscan();
+  if (rspscan_ == NULL) {
+    rspscan_ = new ::StaRspScan;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspScan)
+  return rspscan_;
+}
+inline ::StaRspScan* WlanIpcCmdData::release_rspscan() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspScan)
+  clear_has_rspscan();
+  ::StaRspScan* temp = rspscan_;
+  rspscan_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_rspscan(::StaRspScan* rspscan) {
+  delete rspscan_;
+  rspscan_ = rspscan;
+  if (rspscan) {
+    set_has_rspscan();
+  } else {
+    clear_has_rspscan();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspScan)
+}
+
+// optional .StaReqConnect reqConnect = 3;
+inline bool WlanIpcCmdData::has_reqconnect() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void WlanIpcCmdData::set_has_reqconnect() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void WlanIpcCmdData::clear_has_reqconnect() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void WlanIpcCmdData::clear_reqconnect() {
+  if (reqconnect_ != NULL) reqconnect_->::StaReqConnect::Clear();
+  clear_has_reqconnect();
+}
+inline const ::StaReqConnect& WlanIpcCmdData::reqconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqConnect)
+  return reqconnect_ != NULL ? *reqconnect_
+                         : *::StaReqConnect::internal_default_instance();
+}
+inline ::StaReqConnect* WlanIpcCmdData::mutable_reqconnect() {
+  set_has_reqconnect();
+  if (reqconnect_ == NULL) {
+    reqconnect_ = new ::StaReqConnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqConnect)
+  return reqconnect_;
+}
+inline ::StaReqConnect* WlanIpcCmdData::release_reqconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqConnect)
+  clear_has_reqconnect();
+  ::StaReqConnect* temp = reqconnect_;
+  reqconnect_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_reqconnect(::StaReqConnect* reqconnect) {
+  delete reqconnect_;
+  reqconnect_ = reqconnect;
+  if (reqconnect) {
+    set_has_reqconnect();
+  } else {
+    clear_has_reqconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqConnect)
+}
+
+// optional .StaRspConnect rspConnect = 4;
+inline bool WlanIpcCmdData::has_rspconnect() const {
+  return (_has_bits_[0] & 0x00000008u) != 0;
+}
+inline void WlanIpcCmdData::set_has_rspconnect() {
+  _has_bits_[0] |= 0x00000008u;
+}
+inline void WlanIpcCmdData::clear_has_rspconnect() {
+  _has_bits_[0] &= ~0x00000008u;
+}
+inline void WlanIpcCmdData::clear_rspconnect() {
+  if (rspconnect_ != NULL) rspconnect_->::StaRspConnect::Clear();
+  clear_has_rspconnect();
+}
+inline const ::StaRspConnect& WlanIpcCmdData::rspconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspConnect)
+  return rspconnect_ != NULL ? *rspconnect_
+                         : *::StaRspConnect::internal_default_instance();
+}
+inline ::StaRspConnect* WlanIpcCmdData::mutable_rspconnect() {
+  set_has_rspconnect();
+  if (rspconnect_ == NULL) {
+    rspconnect_ = new ::StaRspConnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspConnect)
+  return rspconnect_;
+}
+inline ::StaRspConnect* WlanIpcCmdData::release_rspconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspConnect)
+  clear_has_rspconnect();
+  ::StaRspConnect* temp = rspconnect_;
+  rspconnect_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_rspconnect(::StaRspConnect* rspconnect) {
+  delete rspconnect_;
+  rspconnect_ = rspconnect;
+  if (rspconnect) {
+    set_has_rspconnect();
+  } else {
+    clear_has_rspconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspConnect)
+}
+
+// optional .StaReqDisconnect reqDisconnect = 5;
+inline bool WlanIpcCmdData::has_reqdisconnect() const {
+  return (_has_bits_[0] & 0x00000010u) != 0;
+}
+inline void WlanIpcCmdData::set_has_reqdisconnect() {
+  _has_bits_[0] |= 0x00000010u;
+}
+inline void WlanIpcCmdData::clear_has_reqdisconnect() {
+  _has_bits_[0] &= ~0x00000010u;
+}
+inline void WlanIpcCmdData::clear_reqdisconnect() {
+  if (reqdisconnect_ != NULL) reqdisconnect_->::StaReqDisconnect::Clear();
+  clear_has_reqdisconnect();
+}
+inline const ::StaReqDisconnect& WlanIpcCmdData::reqdisconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqDisconnect)
+  return reqdisconnect_ != NULL ? *reqdisconnect_
+                         : *::StaReqDisconnect::internal_default_instance();
+}
+inline ::StaReqDisconnect* WlanIpcCmdData::mutable_reqdisconnect() {
+  set_has_reqdisconnect();
+  if (reqdisconnect_ == NULL) {
+    reqdisconnect_ = new ::StaReqDisconnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqDisconnect)
+  return reqdisconnect_;
+}
+inline ::StaReqDisconnect* WlanIpcCmdData::release_reqdisconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqDisconnect)
+  clear_has_reqdisconnect();
+  ::StaReqDisconnect* temp = reqdisconnect_;
+  reqdisconnect_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_reqdisconnect(::StaReqDisconnect* reqdisconnect) {
+  delete reqdisconnect_;
+  reqdisconnect_ = reqdisconnect;
+  if (reqdisconnect) {
+    set_has_reqdisconnect();
+  } else {
+    clear_has_reqdisconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqDisconnect)
+}
+
+// optional .StaRspDisconnect rspDisconnect = 6;
+inline bool WlanIpcCmdData::has_rspdisconnect() const {
+  return (_has_bits_[0] & 0x00000020u) != 0;
+}
+inline void WlanIpcCmdData::set_has_rspdisconnect() {
+  _has_bits_[0] |= 0x00000020u;
+}
+inline void WlanIpcCmdData::clear_has_rspdisconnect() {
+  _has_bits_[0] &= ~0x00000020u;
+}
+inline void WlanIpcCmdData::clear_rspdisconnect() {
+  if (rspdisconnect_ != NULL) rspdisconnect_->::StaRspDisconnect::Clear();
+  clear_has_rspdisconnect();
+}
+inline const ::StaRspDisconnect& WlanIpcCmdData::rspdisconnect() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspDisconnect)
+  return rspdisconnect_ != NULL ? *rspdisconnect_
+                         : *::StaRspDisconnect::internal_default_instance();
+}
+inline ::StaRspDisconnect* WlanIpcCmdData::mutable_rspdisconnect() {
+  set_has_rspdisconnect();
+  if (rspdisconnect_ == NULL) {
+    rspdisconnect_ = new ::StaRspDisconnect;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspDisconnect)
+  return rspdisconnect_;
+}
+inline ::StaRspDisconnect* WlanIpcCmdData::release_rspdisconnect() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspDisconnect)
+  clear_has_rspdisconnect();
+  ::StaRspDisconnect* temp = rspdisconnect_;
+  rspdisconnect_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_rspdisconnect(::StaRspDisconnect* rspdisconnect) {
+  delete rspdisconnect_;
+  rspdisconnect_ = rspdisconnect;
+  if (rspdisconnect) {
+    set_has_rspdisconnect();
+  } else {
+    clear_has_rspdisconnect();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspDisconnect)
+}
+
+// optional .BtReqRequestFw reqRequestFw = 301;
+inline bool WlanIpcCmdData::has_reqrequestfw() const {
+  return (_has_bits_[0] & 0x00000040u) != 0;
+}
+inline void WlanIpcCmdData::set_has_reqrequestfw() {
+  _has_bits_[0] |= 0x00000040u;
+}
+inline void WlanIpcCmdData::clear_has_reqrequestfw() {
+  _has_bits_[0] &= ~0x00000040u;
+}
+inline void WlanIpcCmdData::clear_reqrequestfw() {
+  if (reqrequestfw_ != NULL) reqrequestfw_->::BtReqRequestFw::Clear();
+  clear_has_reqrequestfw();
+}
+inline const ::BtReqRequestFw& WlanIpcCmdData::reqrequestfw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqRequestFw)
+  return reqrequestfw_ != NULL ? *reqrequestfw_
+                         : *::BtReqRequestFw::internal_default_instance();
+}
+inline ::BtReqRequestFw* WlanIpcCmdData::mutable_reqrequestfw() {
+  set_has_reqrequestfw();
+  if (reqrequestfw_ == NULL) {
+    reqrequestfw_ = new ::BtReqRequestFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqRequestFw)
+  return reqrequestfw_;
+}
+inline ::BtReqRequestFw* WlanIpcCmdData::release_reqrequestfw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqRequestFw)
+  clear_has_reqrequestfw();
+  ::BtReqRequestFw* temp = reqrequestfw_;
+  reqrequestfw_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_reqrequestfw(::BtReqRequestFw* reqrequestfw) {
+  delete reqrequestfw_;
+  reqrequestfw_ = reqrequestfw;
+  if (reqrequestfw) {
+    set_has_reqrequestfw();
+  } else {
+    clear_has_reqrequestfw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqRequestFw)
+}
+
+// optional .BtRspRequestFw rspRequestFw = 302;
+inline bool WlanIpcCmdData::has_rsprequestfw() const {
+  return (_has_bits_[0] & 0x00000080u) != 0;
+}
+inline void WlanIpcCmdData::set_has_rsprequestfw() {
+  _has_bits_[0] |= 0x00000080u;
+}
+inline void WlanIpcCmdData::clear_has_rsprequestfw() {
+  _has_bits_[0] &= ~0x00000080u;
+}
+inline void WlanIpcCmdData::clear_rsprequestfw() {
+  if (rsprequestfw_ != NULL) rsprequestfw_->::BtRspRequestFw::Clear();
+  clear_has_rsprequestfw();
+}
+inline const ::BtRspRequestFw& WlanIpcCmdData::rsprequestfw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspRequestFw)
+  return rsprequestfw_ != NULL ? *rsprequestfw_
+                         : *::BtRspRequestFw::internal_default_instance();
+}
+inline ::BtRspRequestFw* WlanIpcCmdData::mutable_rsprequestfw() {
+  set_has_rsprequestfw();
+  if (rsprequestfw_ == NULL) {
+    rsprequestfw_ = new ::BtRspRequestFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspRequestFw)
+  return rsprequestfw_;
+}
+inline ::BtRspRequestFw* WlanIpcCmdData::release_rsprequestfw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspRequestFw)
+  clear_has_rsprequestfw();
+  ::BtRspRequestFw* temp = rsprequestfw_;
+  rsprequestfw_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_rsprequestfw(::BtRspRequestFw* rsprequestfw) {
+  delete rsprequestfw_;
+  rsprequestfw_ = rsprequestfw;
+  if (rsprequestfw) {
+    set_has_rsprequestfw();
+  } else {
+    clear_has_rsprequestfw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspRequestFw)
+}
+
+// optional .BtReqDeclineFw reqDeclineFw = 303;
+inline bool WlanIpcCmdData::has_reqdeclinefw() const {
+  return (_has_bits_[0] & 0x00000100u) != 0;
+}
+inline void WlanIpcCmdData::set_has_reqdeclinefw() {
+  _has_bits_[0] |= 0x00000100u;
+}
+inline void WlanIpcCmdData::clear_has_reqdeclinefw() {
+  _has_bits_[0] &= ~0x00000100u;
+}
+inline void WlanIpcCmdData::clear_reqdeclinefw() {
+  if (reqdeclinefw_ != NULL) reqdeclinefw_->::BtReqDeclineFw::Clear();
+  clear_has_reqdeclinefw();
+}
+inline const ::BtReqDeclineFw& WlanIpcCmdData::reqdeclinefw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.reqDeclineFw)
+  return reqdeclinefw_ != NULL ? *reqdeclinefw_
+                         : *::BtReqDeclineFw::internal_default_instance();
+}
+inline ::BtReqDeclineFw* WlanIpcCmdData::mutable_reqdeclinefw() {
+  set_has_reqdeclinefw();
+  if (reqdeclinefw_ == NULL) {
+    reqdeclinefw_ = new ::BtReqDeclineFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.reqDeclineFw)
+  return reqdeclinefw_;
+}
+inline ::BtReqDeclineFw* WlanIpcCmdData::release_reqdeclinefw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.reqDeclineFw)
+  clear_has_reqdeclinefw();
+  ::BtReqDeclineFw* temp = reqdeclinefw_;
+  reqdeclinefw_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_reqdeclinefw(::BtReqDeclineFw* reqdeclinefw) {
+  delete reqdeclinefw_;
+  reqdeclinefw_ = reqdeclinefw;
+  if (reqdeclinefw) {
+    set_has_reqdeclinefw();
+  } else {
+    clear_has_reqdeclinefw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.reqDeclineFw)
+}
+
+// optional .BtRspDeclineFw rspDeclineFw = 304;
+inline bool WlanIpcCmdData::has_rspdeclinefw() const {
+  return (_has_bits_[0] & 0x00000200u) != 0;
+}
+inline void WlanIpcCmdData::set_has_rspdeclinefw() {
+  _has_bits_[0] |= 0x00000200u;
+}
+inline void WlanIpcCmdData::clear_has_rspdeclinefw() {
+  _has_bits_[0] &= ~0x00000200u;
+}
+inline void WlanIpcCmdData::clear_rspdeclinefw() {
+  if (rspdeclinefw_ != NULL) rspdeclinefw_->::BtRspDeclineFw::Clear();
+  clear_has_rspdeclinefw();
+}
+inline const ::BtRspDeclineFw& WlanIpcCmdData::rspdeclinefw() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.rspDeclineFw)
+  return rspdeclinefw_ != NULL ? *rspdeclinefw_
+                         : *::BtRspDeclineFw::internal_default_instance();
+}
+inline ::BtRspDeclineFw* WlanIpcCmdData::mutable_rspdeclinefw() {
+  set_has_rspdeclinefw();
+  if (rspdeclinefw_ == NULL) {
+    rspdeclinefw_ = new ::BtRspDeclineFw;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.rspDeclineFw)
+  return rspdeclinefw_;
+}
+inline ::BtRspDeclineFw* WlanIpcCmdData::release_rspdeclinefw() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.rspDeclineFw)
+  clear_has_rspdeclinefw();
+  ::BtRspDeclineFw* temp = rspdeclinefw_;
+  rspdeclinefw_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_rspdeclinefw(::BtRspDeclineFw* rspdeclinefw) {
+  delete rspdeclinefw_;
+  rspdeclinefw_ = rspdeclinefw;
+  if (rspdeclinefw) {
+    set_has_rspdeclinefw();
+  } else {
+    clear_has_rspdeclinefw();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.rspDeclineFw)
+}
+
+// optional .StaScanResults scanRes = 401;
+inline bool WlanIpcCmdData::has_scanres() const {
+  return (_has_bits_[0] & 0x00000400u) != 0;
+}
+inline void WlanIpcCmdData::set_has_scanres() {
+  _has_bits_[0] |= 0x00000400u;
+}
+inline void WlanIpcCmdData::clear_has_scanres() {
+  _has_bits_[0] &= ~0x00000400u;
+}
+inline void WlanIpcCmdData::clear_scanres() {
+  if (scanres_ != NULL) scanres_->::StaScanResults::Clear();
+  clear_has_scanres();
+}
+inline const ::StaScanResults& WlanIpcCmdData::scanres() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.scanRes)
+  return scanres_ != NULL ? *scanres_
+                         : *::StaScanResults::internal_default_instance();
+}
+inline ::StaScanResults* WlanIpcCmdData::mutable_scanres() {
+  set_has_scanres();
+  if (scanres_ == NULL) {
+    scanres_ = new ::StaScanResults;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.scanRes)
+  return scanres_;
+}
+inline ::StaScanResults* WlanIpcCmdData::release_scanres() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.scanRes)
+  clear_has_scanres();
+  ::StaScanResults* temp = scanres_;
+  scanres_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_scanres(::StaScanResults* scanres) {
+  delete scanres_;
+  scanres_ = scanres;
+  if (scanres) {
+    set_has_scanres();
+  } else {
+    clear_has_scanres();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.scanRes)
+}
+
+// optional .StaStatusUpdate staStatus = 402;
+inline bool WlanIpcCmdData::has_stastatus() const {
+  return (_has_bits_[0] & 0x00000800u) != 0;
+}
+inline void WlanIpcCmdData::set_has_stastatus() {
+  _has_bits_[0] |= 0x00000800u;
+}
+inline void WlanIpcCmdData::clear_has_stastatus() {
+  _has_bits_[0] &= ~0x00000800u;
+}
+inline void WlanIpcCmdData::clear_stastatus() {
+  if (stastatus_ != NULL) stastatus_->::StaStatusUpdate::Clear();
+  clear_has_stastatus();
+}
+inline const ::StaStatusUpdate& WlanIpcCmdData::stastatus() const {
+  // @@protoc_insertion_point(field_get:WlanIpcCmdData.staStatus)
+  return stastatus_ != NULL ? *stastatus_
+                         : *::StaStatusUpdate::internal_default_instance();
+}
+inline ::StaStatusUpdate* WlanIpcCmdData::mutable_stastatus() {
+  set_has_stastatus();
+  if (stastatus_ == NULL) {
+    stastatus_ = new ::StaStatusUpdate;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcCmdData.staStatus)
+  return stastatus_;
+}
+inline ::StaStatusUpdate* WlanIpcCmdData::release_stastatus() {
+  // @@protoc_insertion_point(field_release:WlanIpcCmdData.staStatus)
+  clear_has_stastatus();
+  ::StaStatusUpdate* temp = stastatus_;
+  stastatus_ = NULL;
+  return temp;
+}
+inline void WlanIpcCmdData::set_allocated_stastatus(::StaStatusUpdate* stastatus) {
+  delete stastatus_;
+  stastatus_ = stastatus;
+  if (stastatus) {
+    set_has_stastatus();
+  } else {
+    clear_has_stastatus();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcCmdData.staStatus)
+}
+
+// -------------------------------------------------------------------
+
+// WlanIpcMsg
+
+// required int32 ver = 1;
+inline bool WlanIpcMsg::has_ver() const {
+  return (_has_bits_[0] & 0x00000002u) != 0;
+}
+inline void WlanIpcMsg::set_has_ver() {
+  _has_bits_[0] |= 0x00000002u;
+}
+inline void WlanIpcMsg::clear_has_ver() {
+  _has_bits_[0] &= ~0x00000002u;
+}
+inline void WlanIpcMsg::clear_ver() {
+  ver_ = 0;
+  clear_has_ver();
+}
+inline ::google::protobuf::int32 WlanIpcMsg::ver() const {
+  // @@protoc_insertion_point(field_get:WlanIpcMsg.ver)
+  return ver_;
+}
+inline void WlanIpcMsg::set_ver(::google::protobuf::int32 value) {
+  set_has_ver();
+  ver_ = value;
+  // @@protoc_insertion_point(field_set:WlanIpcMsg.ver)
+}
+
+// required .WlanIpcCmdType type = 2;
+inline bool WlanIpcMsg::has_type() const {
+  return (_has_bits_[0] & 0x00000004u) != 0;
+}
+inline void WlanIpcMsg::set_has_type() {
+  _has_bits_[0] |= 0x00000004u;
+}
+inline void WlanIpcMsg::clear_has_type() {
+  _has_bits_[0] &= ~0x00000004u;
+}
+inline void WlanIpcMsg::clear_type() {
+  type_ = 1;
+  clear_has_type();
+}
+inline ::WlanIpcCmdType WlanIpcMsg::type() const {
+  // @@protoc_insertion_point(field_get:WlanIpcMsg.type)
+  return static_cast< ::WlanIpcCmdType >(type_);
+}
+inline void WlanIpcMsg::set_type(::WlanIpcCmdType value) {
+  assert(::WlanIpcCmdType_IsValid(value));
+  set_has_type();
+  type_ = value;
+  // @@protoc_insertion_point(field_set:WlanIpcMsg.type)
+}
+
+// optional .WlanIpcCmdData data = 3;
+inline bool WlanIpcMsg::has_data() const {
+  return (_has_bits_[0] & 0x00000001u) != 0;
+}
+inline void WlanIpcMsg::set_has_data() {
+  _has_bits_[0] |= 0x00000001u;
+}
+inline void WlanIpcMsg::clear_has_data() {
+  _has_bits_[0] &= ~0x00000001u;
+}
+inline void WlanIpcMsg::clear_data() {
+  if (data_ != NULL) data_->::WlanIpcCmdData::Clear();
+  clear_has_data();
+}
+inline const ::WlanIpcCmdData& WlanIpcMsg::data() const {
+  // @@protoc_insertion_point(field_get:WlanIpcMsg.data)
+  return data_ != NULL ? *data_
+                         : *::WlanIpcCmdData::internal_default_instance();
+}
+inline ::WlanIpcCmdData* WlanIpcMsg::mutable_data() {
+  set_has_data();
+  if (data_ == NULL) {
+    data_ = new ::WlanIpcCmdData;
+  }
+  // @@protoc_insertion_point(field_mutable:WlanIpcMsg.data)
+  return data_;
+}
+inline ::WlanIpcCmdData* WlanIpcMsg::release_data() {
+  // @@protoc_insertion_point(field_release:WlanIpcMsg.data)
+  clear_has_data();
+  ::WlanIpcCmdData* temp = data_;
+  data_ = NULL;
+  return temp;
+}
+inline void WlanIpcMsg::set_allocated_data(::WlanIpcCmdData* data) {
+  delete data_;
+  data_ = data;
+  if (data) {
+    set_has_data();
+  } else {
+    clear_has_data();
+  }
+  // @@protoc_insertion_point(field_set_allocated:WlanIpcMsg.data)
+}
+
+#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+// -------------------------------------------------------------------
+
+
+// @@protoc_insertion_point(namespace_scope)
+
+
+#ifndef SWIG
+namespace google {
+namespace protobuf {
+
+template <> struct is_proto_enum< ::WlanIpcCmdType> : ::google::protobuf::internal::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::WlanIpcCmdType>() {
+  return ::WlanIpcCmdType_descriptor();
+}
+template <> struct is_proto_enum< ::WlanIpcCmdRsp> : ::google::protobuf::internal::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::WlanIpcCmdRsp>() {
+  return ::WlanIpcCmdRsp_descriptor();
+}
+template <> struct is_proto_enum< ::StaScanType> : ::google::protobuf::internal::true_type {};
+template <>
+inline const EnumDescriptor* GetEnumDescriptor< ::StaScanType>() {
+  return ::StaScanType_descriptor();
+}
+
+}  // namespace protobuf
+}  // namespace google
+#endif  // SWIG
+
+// @@protoc_insertion_point(global_scope)
+
+#endif  // PROTOBUF_wlan_5fipc_2eproto__INCLUDED
diff -Ndur '--exclude=.git' ./test/Makefile /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/test/Makefile
--- ./test/Makefile	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/test/Makefile	2018-04-12 13:44:00.864000000 -0400
@@ -49,6 +49,7 @@
 SRCS += $(SRCDIR)/service/hostapd/hostapd.cpp
 SRCS += $(SRCDIR)/service/hostapd/hostapd_cmds.cpp
 SRCS += $(SRCDIR)/service/drv_ctrl/drv_ctrl.cpp
+SRCS += $(SRCDIR)/service/vnm_ipc/vnm_ipc.cpp
 
 INCLUDES += -I$(SRCDIR)/service/
 INCLUDES += -I$(SRCDIR)/service/wlan_srv
@@ -59,12 +60,13 @@
 INCLUDES += -I$(SRCDIR)/service/wpa_supp
 INCLUDES += -I$(SRCDIR)/service/hostapd
 INCLUDES += -I$(SRCDIR)/service/drv_ctrl
+INCLUDES += -I$(SRCDIR)/service/vnm_ipc
 INCLUDES += -I$(SRCDIR)/public
 
 ifeq ($(FORD_ECU),tcu)
-LIBS += -ltelemetry
+LIBS += -ltelemetry -lvnmipc
 else ifeq ($(FORD_ECU),sync)
-LIBS += -ltelemetry
+LIBS += -ltelemetry -lvnmipc
 endif
 
 # add feature specific stuff
@@ -93,13 +95,9 @@
 SRCS += $(SRCDIR)/service/tcu_ipc/tcu_ipc_client.cpp
 SRCS += $(SRCDIR)/service/tcu_ipc/tcu_ipc_utils.cpp
 SRCS += $(SRCDIR)/service/tcu_ipc/service_cand.cpp
-SRCS += $(SRCDIR)/service/tcu_ipc/service_spcm.cpp
 SRCS += $(INSTALL_HDIR)/idl/cand/TcuIpcCand.pb.cc
-SRCS += $(INSTALL_HDIR)/idl/spcm/TcuIpcSpcm.pb.cc
-SRCS += $(INSTALL_HDIR)/idl/spcm/tcu_spcm_common.pb.cc
 INCLUDES += -I$(SRCDIR)/service/tcu_ipc/
 INCLUDES += -I$(INSTALL_HDIR)/idl
-INCLUDES += -I${FORD_ECU_ROOT}/fnv/spcm/include
 LIBS += -lprotobuf -ltcuipc-client -lwlanidl
 CFLAGS += -DCONFIG_TCUIPC_FEATURE
 endif
diff -Ndur '--exclude=.git' ./test/makefile.linux /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/test/makefile.linux
--- ./test/makefile.linux	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/test/makefile.linux	2018-04-12 13:44:00.864000000 -0400
@@ -1 +1 @@
-LIBS += -lpthread
+LIBS += -lpthread -lrt
diff -Ndur '--exclude=.git' ./test/makefile.qnx /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/test/makefile.qnx
--- ./test/makefile.qnx	2018-04-12 10:31:17.292000000 -0400
+++ /home/kjohn402/Projects/workspace/apps_proc/vendor/ford/fnv/wlan_service/test/makefile.qnx	2018-04-12 13:44:00.864000000 -0400
@@ -1 +1 @@
-LIBS += -lsocket
+LIBS += -lsocket -lmq
